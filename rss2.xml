<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rancho Blog</title>
    <link>https://rancho333.github.io/</link>
    
    <atom:link href="https://rancho333.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>No pain, no gain!</description>
    <pubDate>Thu, 14 Jul 2022 02:33:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>路由标记</title>
      <link>https://rancho333.github.io/2022/07/12/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AE%B0/</link>
      <guid>https://rancho333.github.io/2022/07/12/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AE%B0/</guid>
      <pubDate>Tue, 12 Jul 2022 06:59:07 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;路由标记其实就是路由的一个属性。有了tag属性，可以对具有相同tag属性的一组路由进行操作(过滤、修改路由类型，修改metric值等)。BGP中有个非常类似的属性：community属性。&lt;br&gt;一般情况下内部路由不打标记，外部路由打标记。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>路由标记其实就是路由的一个属性。有了tag属性，可以对具有相同tag属性的一组路由进行操作(过滤、修改路由类型，修改metric值等)。BGP中有个非常类似的属性：community属性。<br>一般情况下内部路由不打标记，外部路由打标记。</p><span id="more"></span><h2 id="ospf打标记"><a href="#ospf打标记" class="headerlink" title="ospf打标记"></a>ospf打标记</h2><p>ospf将外部路由重分布进ospf时支持直接打标机（也可以使用路由策略route-map）。拓扑图如下：</p><p><img src="https://rancho333.github.io/pictures/routing_tag.png"><br>R1,R2的eth0上运行ospf，R2上创建lp0接口，将lp0重分布到ospf中，并打上标记，使R1学到。配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">R1</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line"> ip ospf 110 area 0</span><br><span class="line">！</span><br><span class="line">router ospf 110</span><br><span class="line"></span><br><span class="line">R2</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.12 255.255.255.0</span><br><span class="line"> ip ospf 110 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 110</span><br><span class="line"> redistribute connected subnets tag 12                  &#x2F;&#x2F; 重分布直连路由进ospf，并打上tag：12</span><br></pre></td></tr></table></figure><p>在R1上查看2.2.2.2的ospf database信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R1#show ip ospf database                  </span><br><span class="line">Type-5 AS External Link States</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Tag</span><br><span class="line">2.2.2.2         12.1.1.12       609         0x80000002 0x009ED2 12</span><br></pre></td></tr></table></figure><p>发现已经打上tag：12的标记。之后就可以创建route-map，match这个tag，之后就可以set各种操作。</p><p>此外，还可以通过<code>route-map</code>来打tag.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R2(config)#route-map tag permit 10           &#x2F;&#x2F; 创建一个route-map，名字叫tag</span><br><span class="line">R2(config-route-map)#set tag 20              &#x2F;&#x2F; 动作时设置tag20</span><br><span class="line">R2(config-router)#redistribute connected route-map tag          &#x2F;&#x2F; 重分布时使能该route-map</span><br></pre></td></tr></table></figure><p>在R1上查看ospf的database信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R1#show ip ospf database </span><br><span class="line">Type-5 AS External Link States</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Tag</span><br><span class="line">2.2.2.2         12.1.1.12       4           0x80000001 0x003139 20</span><br></pre></td></tr></table></figure><p>ospf和eigrp都支持tag，两者在重分布时会携带tag到对方的路由域。</p><h2 id="eigrp打标记"><a href="#eigrp打标记" class="headerlink" title="eigrp打标记"></a>eigrp打标记</h2><p>eigrp中不能直接打tag，只能通过route-map方式打标记。命令和ospf一样。eigrp上查看标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R1#show ip eigrp topology </span><br><span class="line">P 2.2.2.2&#x2F;32, 1 successors, FD is 409600, tag is 20         &#x2F;&#x2F; tag是上面route-map定义的</span><br><span class="line">        via 12.1.1.12 (409600&#x2F;128256), Ethernet0&#x2F;0</span><br></pre></td></tr></table></figure><p>eigrp在命名模式下可以给内部路由打标记，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R2(config-router)#eigrp upgrade-cli rancho              &#x2F;&#x2F; 可以直接从经典模式升级到命名模式，好处是邻居状态不会发生变化</span><br><span class="line">R2(config-router)#address-family ipv4 autonomous-system 90</span><br><span class="line">R2(config-router-af)#eigrp default-route-tag 45</span><br><span class="line"></span><br><span class="line">R2(config-router-af)#eigrp default-route-tag 10.10.10.10        &#x2F;&#x2F; 如果是使用点分十进制打tag，那么对端显示的是十进制数字</span><br><span class="line">R1(config)#route-tag notation dotted-decimal                    &#x2F;&#x2F; 需要修改route tag的显示方式</span><br></pre></td></tr></table></figure><h2 id="tag结合distribute-list过滤路由"><a href="#tag结合distribute-list过滤路由" class="headerlink" title="tag结合distribute-list过滤路由"></a>tag结合distribute-list过滤路由</h2><p>在R1上创建route-map，匹配R2上打的tag，分发列表中调用该route-map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R1(config)#route-map deny-tag deny 10           &#x2F;&#x2F; 创建route-map</span><br><span class="line">R1(config-route-map)#match tag 20               &#x2F;&#x2F; 匹配tag 20</span><br><span class="line">R1(config)#router eigrp 90</span><br><span class="line">R1(config-router)#distribute-list route-map deny-tag in     &#x2F;&#x2F;使能分发列表</span><br><span class="line"></span><br><span class="line">R1(config)#route-map deny-tag permit 20         &#x2F;&#x2F; 创建deny-tag的permit语句，否则分发列表会隐式过滤所有路由</span><br><span class="line"></span><br><span class="line">R2(config)#interface loopback 1</span><br><span class="line">R2(config-if)#ip address 3.3.3.3 255.255.255.255</span><br><span class="line">R2(config)#router eigrp 90</span><br><span class="line">R2(config-router)#network 3.3.3.3</span><br></pre></td></tr></table></figure><p>查看R1上路由表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R1#show ip route          </span><br><span class="line">      3.0.0.0&#x2F;32 is subnetted, 1 subnets</span><br><span class="line">D        3.3.3.3 [90&#x2F;409600] via 12.1.1.12, 00:00:06, Ethernet0&#x2F;0</span><br><span class="line">      12.0.0.0&#x2F;8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        12.1.1.0&#x2F;24 is directly connected, Ethernet0&#x2F;0</span><br><span class="line">L        12.1.1.1&#x2F;32 is directly connected, Ethernet0&#x2F;0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到<code>2.2.2.2</code>的路由已经被过滤了，没有路由tag的3.3.3.3可以正常看到。</p><h2 id="rip打tag"><a href="#rip打tag" class="headerlink" title="rip打tag"></a>rip打tag</h2><p>rip只能在version2上打标记，方法和eigrp相同。</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/routing/">routing</category>
      
      
      <comments>https://rancho333.github.io/2022/07/12/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双点双向重分布</title>
      <link>https://rancho333.github.io/2022/07/12/%E5%8F%8C%E7%82%B9%E5%8F%8C%E5%90%91%E9%87%8D%E5%88%86%E5%B8%83/</link>
      <guid>https://rancho333.github.io/2022/07/12/%E5%8F%8C%E7%82%B9%E5%8F%8C%E5%90%91%E9%87%8D%E5%88%86%E5%B8%83/</guid>
      <pubDate>Tue, 12 Jul 2022 01:58:53 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;不同的路由网络之间互联的时候，需要相互导入对方的路由完成路由重分布。进行双向重分布的路由器就显得格外重要，存在单点故障隐患，可通过双点双向重分布来解决这个问题。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>不同的路由网络之间互联的时候，需要相互导入对方的路由完成路由重分布。进行双向重分布的路由器就显得格外重要，存在单点故障隐患，可通过双点双向重分布来解决这个问题。</p><span id="more"></span><h1 id="拓扑描述"><a href="#拓扑描述" class="headerlink" title="拓扑描述"></a>拓扑描述</h1><p>双点双向重分布拓扑如下:</p><p><img src="https://rancho333.github.io/pictures/double_point_double_redistribute.png"></p><p>左边的区域运行rip，右边的区域运行ospf，在R2、R4上做双向重分布，最终效果：在R1上到3.3.3.3有两个下一跳，在R3上到1.1.1.1上有两个下一跳。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="接口ip及动态路由协议配置"><a href="#接口ip及动态路由协议配置" class="headerlink" title="接口ip及动态路由协议配置"></a>接口ip及动态路由协议配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R1：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 14.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line"> router rip</span><br><span class="line"> version 2                          &#x2F;&#x2F; 使用rip version2版本，version1只能使用有类别的ip</span><br><span class="line"> network 1.0.0.0</span><br><span class="line"> network 12.0.0.0</span><br><span class="line"> network 14.0.0.0</span><br><span class="line"> no auto-summary                    &#x2F;&#x2F; rip默认开启路由汇聚，将其关闭</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">R2:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line"> ip ospf 110 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 23.1.1.2 255.255.255.0</span><br><span class="line"> ip ospf 110 area 0                             &#x2F;&#x2F; eth0&#x2F;1参加ospf110的计算</span><br><span class="line">！</span><br><span class="line">router ospf 110</span><br><span class="line">!</span><br><span class="line">router rip</span><br><span class="line"> version 2</span><br><span class="line"> network 12.0.0.0</span><br><span class="line"> no auto-summary</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">R4：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line"> ip ospf 110 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 14.1.1.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 34.1.1.3 255.255.255.0</span><br><span class="line"> ip ospf 110 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 110</span><br><span class="line">!</span><br><span class="line">router rip</span><br><span class="line"> version 2</span><br><span class="line"> network 14.0.0.0</span><br><span class="line"> no auto-summary                                 &#x2F;&#x2F; 配置和R2基本一致</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">R3：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line"> ip ospf 110 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 23.1.1.3 255.255.255.0</span><br><span class="line"> ip ospf 110 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 34.1.1.3 255.255.255.0</span><br><span class="line"> ip ospf 110 area 0                         &#x2F;&#x2F; R3的接口全部加入ospf110的计算</span><br><span class="line">!</span><br><span class="line">router ospf 110</span><br></pre></td></tr></table></figure><p>配置完成之后产看一些状态，看结果是不是符合预期。在R2，R4上应该通过rip学到1.1.1.1的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R2#show ip route | include 1.1.1.1</span><br><span class="line">R        1.1.1.1 [120&#x2F;1] via 12.1.1.1, 00:00:20, Ethernet0&#x2F;0</span><br><span class="line"></span><br><span class="line">R4#show ip route | include 1.1.1.1</span><br><span class="line">R        1.1.1.1 [120&#x2F;1] via 14.1.1.1, 00:00:16, Ethernet0&#x2F;0</span><br></pre></td></tr></table></figure><p>在R2，R4上面应该通过ospf学到3.3.3.3的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R2#show ip route | include 3.3.3.3</span><br><span class="line">O        3.3.3.3 [110&#x2F;11] via 23.1.1.3, 00:08:19, Ethernet0&#x2F;1</span><br><span class="line"></span><br><span class="line">R4#show ip route | include 3.3.3.3</span><br><span class="line">O        3.3.3.3 [110&#x2F;11] via 34.1.1.3, 00:06:15, Ethernet0&#x2F;1</span><br></pre></td></tr></table></figure><p>此时没有做重分布，所以R1上没有到3.3.3.3的路由， R3上也没有到1.1.1.1的路由。</p><h2 id="重分布配置"><a href="#重分布配置" class="headerlink" title="重分布配置"></a>重分布配置</h2><p>现在R2上做双向重分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R2(config)#router ospf 110</span><br><span class="line">R2(config-router)#redistribute rip subnets              &#x2F;&#x2F; 在ospf中引入rip的路由，注意指定subnets选项</span><br><span class="line"></span><br><span class="line">R2(config)#router rip</span><br><span class="line">R2(config-router)#redistribute ospf 110 metric 3        &#x2F;&#x2F; 在rip中引入ospf的路由，注意指定metric值，否则是无穷大</span><br></pre></td></tr></table></figure><p>此时就完成了拓扑中的单点双向重分布。分别检查R1和R3上的路由表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">R1#show ip route | begin 1.1.1.1</span><br><span class="line">C        1.1.1.1 is directly connected, Loopback0</span><br><span class="line">      2.0.0.0&#x2F;32 is subnetted, 1 subnets</span><br><span class="line">R        2.2.2.2 [120&#x2F;3] via 12.1.1.2, 00:00:03, Ethernet0&#x2F;0</span><br><span class="line">      3.0.0.0&#x2F;32 is subnetted, 1 subnets</span><br><span class="line">R        3.3.3.3 [120&#x2F;3] via 12.1.1.2, 00:00:03, Ethernet0&#x2F;0</span><br><span class="line">      4.0.0.0&#x2F;32 is subnetted, 1 subnets</span><br><span class="line">R        4.4.4.4 [120&#x2F;3] via 12.1.1.2, 00:00:03, Ethernet0&#x2F;0</span><br><span class="line">      12.0.0.0&#x2F;8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        12.1.1.0&#x2F;24 is directly connected, Ethernet0&#x2F;0</span><br><span class="line">L        12.1.1.1&#x2F;32 is directly connected, Ethernet0&#x2F;0</span><br><span class="line">      14.0.0.0&#x2F;8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        14.1.1.0&#x2F;24 is directly connected, Ethernet0&#x2F;1</span><br><span class="line">L        14.1.1.1&#x2F;32 is directly connected, Ethernet0&#x2F;1</span><br><span class="line">      23.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">R        23.1.1.0 [120&#x2F;3] via 12.1.1.2, 00:00:03, Ethernet0&#x2F;0</span><br><span class="line">      34.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">R        34.1.1.0 [120&#x2F;3] via 12.1.1.2, 00:00:03, Ethernet0&#x2F;0</span><br></pre></td></tr></table></figure><p>可以发现R1通过rip学到了3.3.3.3的路由，并且右边ospf区域内的路由全部是通过eth0到R2，符合预期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">R3#show ip route | begin 1.1.1.1</span><br><span class="line">O E2     1.1.1.1 [110&#x2F;20] via 23.1.1.2, 00:08:22, Ethernet0&#x2F;0</span><br><span class="line">      2.0.0.0&#x2F;32 is subnetted, 1 subnets</span><br><span class="line">O        2.2.2.2 [110&#x2F;11] via 23.1.1.2, 00:19:29, Ethernet0&#x2F;0</span><br><span class="line">      3.0.0.0&#x2F;32 is subnetted, 1 subnets</span><br><span class="line">C        3.3.3.3 is directly connected, Loopback0</span><br><span class="line">      4.0.0.0&#x2F;32 is subnetted, 1 subnets</span><br><span class="line">O        4.4.4.4 [110&#x2F;11] via 34.1.1.4, 00:16:58, Ethernet0&#x2F;1</span><br><span class="line">      12.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">O E2     12.1.1.0 [110&#x2F;20] via 23.1.1.2, 00:08:22, Ethernet0&#x2F;0</span><br><span class="line">      14.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">O E2     14.1.1.0 [110&#x2F;20] via 23.1.1.2, 00:08:22, Ethernet0&#x2F;0</span><br><span class="line">      23.0.0.0&#x2F;8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        23.1.1.0&#x2F;24 is directly connected, Ethernet0&#x2F;0</span><br><span class="line">L        23.1.1.3&#x2F;32 is directly connected, Ethernet0&#x2F;0</span><br><span class="line">      34.0.0.0&#x2F;8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        34.1.1.0&#x2F;24 is directly connected, Ethernet0&#x2F;1</span><br><span class="line">L        34.1.1.3&#x2F;32 is directly connected, Ethernet0&#x2F;1</span><br></pre></td></tr></table></figure><p>可以发现R3通过ospf学到了1.1.1.1的路由，并且左边rip区域内的路由全部是通过eth0到R2，符合预期。ping测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R3#ping 1.1.1.1 source 3.3.3.3</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 1.1.1.1, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 3.3.3.3 </span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;1 ms</span><br><span class="line">R3#                                                                 &#x2F;&#x2F; 1.1.1.1和3.3.3.3之间是通的，符合预期</span><br></pre></td></tr></table></figure><p>检查一下R4的路由表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R4#show ip route | include 34.1.1.3</span><br><span class="line">O E2     1.1.1.1 [110&#x2F;20] via 34.1.1.3, 00:18:13, Ethernet0&#x2F;1           &#x2F;&#x2F;   ***</span><br><span class="line">O        2.2.2.2 [110&#x2F;21] via 34.1.1.3, 00:26:51, Ethernet0&#x2F;1</span><br><span class="line">O        3.3.3.3 [110&#x2F;11] via 34.1.1.3, 00:26:51, Ethernet0&#x2F;1</span><br><span class="line">O E2     12.1.1.0 [110&#x2F;20] via 34.1.1.3, 00:18:13, Ethernet0&#x2F;1          &#x2F;&#x2F; ***</span><br><span class="line">O        23.1.1.0 [110&#x2F;20] via 34.1.1.3, 00:26:51, Ethernet0&#x2F;1</span><br></pre></td></tr></table></figure><p>发现原本在通过rip学习到的两条路由<code>1.1.1.1</code>和<code>12.1.1.0</code>现在是通过ospf学到的，并且是E2的标记。原因如图示：</p><p><img src="https://rancho333.github.io/pictures/inferior_path.png"></p><p>以1.1.1.1路由为例，R4会在两个方向学到该路由。红线部分是通过rip学习到的，ad值是120. 蓝线部分是rip重定向到ospf区域学到，ad值是110.<br>对于相同的prefix，通过不同路由协议学到，选ad值小的，所以R4到1.1.1.1的下一跳是R3，很明显，这是一条次优路径。同理12.1.1.0网段路由也是如此。</p><p>R4通过收到type5的LSA学到充rip中重定向的路由，所以修改下外部路由的ad值就可以避免这个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R4(config-router)#distance ospf external 121            &#x2F;&#x2F; 改成比rip ad大即可</span><br></pre></td></tr></table></figure><p>再次查看R4的路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R4#show ip route | include 14.1.1.1</span><br><span class="line">R        1.1.1.1 [120&#x2F;1] via 14.1.1.1, 00:00:18, Ethernet0&#x2F;0</span><br><span class="line">R        12.1.1.0 [120&#x2F;1] via 14.1.1.1, 00:00:18, Ethernet0&#x2F;0</span><br></pre></td></tr></table></figure><p>发现次优路径的问题已经没有了。</p><h3 id="双点双向重分布"><a href="#双点双向重分布" class="headerlink" title="双点双向重分布"></a>双点双向重分布</h3><p>本次实验要点是双点双向重分布，之前只是在R2单点上进行重分布，现在在R4上也执行重分布操作, 配置与R2上一致。</p><p>需要注意的是，现在R2也会遇到之前R4的次优路径的问题，因为现在R2也会从rip和ospf两个域收到1.1.1.1的路由，所以同样需要在ospf中修改外部路由ad值。分别查看R1和R3上的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R1#show ip route | begin 3.3.3.3</span><br><span class="line">R        3.3.3.3 [120&#x2F;3] via 14.1.1.4, 00:00:22, Ethernet0&#x2F;1</span><br><span class="line">                 [120&#x2F;3] via 12.1.1.2, 00:00:26, Ethernet0&#x2F;0</span><br><span class="line">&#x2F;&#x2F; R1分别学到从R2、R4重分布过来的3.3.3.3的路由，形成ecmp</span><br><span class="line"></span><br><span class="line">R3#show ip route | begin 1.1.1.1</span><br><span class="line">O E2     1.1.1.1 [110&#x2F;20] via 34.1.1.4, 00:06:13, Ethernet0&#x2F;1</span><br><span class="line">                 [110&#x2F;20] via 23.1.1.2, 00:04:31, Ethernet0&#x2F;0</span><br><span class="line">&#x2F;&#x2F; R3上分别学到从R2、R4重分布过来的1.1.1.1的路由，形成ecmp</span><br></pre></td></tr></table></figure><p>完全符合预期。</p><h2 id="路由标记解决路由回馈的问题"><a href="#路由标记解决路由回馈的问题" class="headerlink" title="路由标记解决路由回馈的问题"></a>路由标记解决路由回馈的问题</h2><p>以本实验为例，R2上在ospf中引入的rip路由，某些情况下，R4上会将这部分路由从重分布到rip。rip中没有邻居的概念，将R1的eth1 shutdown之后，在R4上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R4#clear ip route *                &#x2F;&#x2F; 刷新R4上的路由表</span><br><span class="line"></span><br><span class="line">R4#show ip route | include 1.1.1.1</span><br><span class="line">O E2     1.1.1.1 [121&#x2F;20] via 34.1.1.3, 00:04:34, Ethernet0&#x2F;1     &#x2F;&#x2F; 此时1.1.1.1的路由是从ospf学到的(R2上rip重分布到ospf中)</span><br></pre></td></tr></table></figure><p>在R2的eth1上抓包如下：<br><img src="https://rancho333.github.io/pictures/routing_backward.png"></p><p>可以发现R4将本属于rip路由域中<code>1.1.1.1</code>和<code>12.1.1.0</code>这两条路由重新发回到了rip，这会<em>引起路由环路的风险</em>。</p><p>通过路由标记可以解决这个问题。本质是本路由域从别的路由域中学到的路由不会再重新分发回去(自己发出的自己不再接收)。实际操作是：</p><ol><li>当从别的路由域引入路由的时候，给这些路由打上标记</li><li>将本路由域中的路由重分布出去的时候，不分布这些有标记的路由</li></ol><p>接着上面的实验，R2上ospf中引入的rip路由打上标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R2(config)#router ospf 110</span><br><span class="line">R2(config-router)#redistribute rip subnets tag 120</span><br></pre></td></tr></table></figure><p>在R4上查看ospf中带有tag的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R4#show ip ospf database | include 120</span><br><span class="line">1.1.1.1         2.2.2.2         704         0x80000003 0x00F128 120</span><br><span class="line">12.1.1.0        2.2.2.2         704         0x80000003 0x006CA3 120</span><br></pre></td></tr></table></figure><p>R4上在rip中引入ospf路由时过滤这些带有tag的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">route-map otr deny 5                      &#x2F;&#x2F; 常见route-map ospf two rip，deny</span><br><span class="line"> match tag 120                            &#x2F;&#x2F; tag为120的路由全部deny</span><br><span class="line">!</span><br><span class="line">route-map otr permit 10                   &#x2F;&#x2F;允许不带tag 120的路由通过</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"> redistribute ospf 110 metric 3 route-map otr               &#x2F;&#x2F; 在rip中引入ospf的路由时使能该route-map</span><br></pre></td></tr></table></figure><p>等待拓扑收敛后再次抓包查看：<br><img src="https://rancho333.github.io/pictures/routing_backward_fix.png"></p><p>由于是双点双向重分布，所以需要在4个redistribute的点上分别打tag和使能对应的route-map，这里不做重复操作。</p><h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><p>本实验的关键是AD值的理解。双点双向重分布中有以下几个关键点：</p><ol><li>次优路径。高AD向低AD重分布时产生次优路径。R2重分布后，R4到1.1.1.1是次优路径。</li><li>重分布失败。重分布的本质：在重分布路由表中一定要有对应路由协议的路由。R2重分布后，R4的路由表中没有rip 1.1.1.1的路由，r4自然无法将1.1.1.1从rip重分布到ospf，此时R3上到1.1.1.1的下一跳只有R2.</li><li>路由回馈(路由倒灌)：当一个协议的路由重分布进另一个协议后，如果不做任何控制，在双点双向的场景中，源自于该协议的路由很可能被重新分布回去，就会有环路风险。</li></ol><p>本质就是路由重分布之后，边界路由器可能从不同的路由域中收到相同prefix的路由，ad值小的下发到路由表，此时可能造成次优路径等问题。</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/%E8%B7%AF%E7%94%B1/">路由</category>
      
      <category domain="https://rancho333.github.io/tags/AD/">AD</category>
      
      
      <comments>https://rancho333.github.io/2022/07/12/%E5%8F%8C%E7%82%B9%E5%8F%8C%E5%90%91%E9%87%8D%E5%88%86%E5%B8%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>glbp简述</title>
      <link>https://rancho333.github.io/2022/07/07/glbp%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/07/glbp%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 07 Jul 2022 09:09:31 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;GLBP(gateway load balancing protocol)是FHRP的一种实现，思科私有协议。HSRP和VRRP都只能做到单活网关，而GLBP可以实现多活网关。&lt;br&gt;VRRP/HSRP中的负载均衡是将不同网段的active放在不同的设备上，即互为对方网段的backup，这是一种伪负载均衡。而GLBP通过vip与多vmac的映射可以实现同一网段流量的负载均衡。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>GLBP(gateway load balancing protocol)是FHRP的一种实现，思科私有协议。HSRP和VRRP都只能做到单活网关，而GLBP可以实现多活网关。<br>VRRP/HSRP中的负载均衡是将不同网段的active放在不同的设备上，即互为对方网段的backup，这是一种伪负载均衡。而GLBP通过vip与多vmac的映射可以实现同一网段流量的负载均衡。</p><span id="more"></span><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>AVG(active virtual gateway): 一个虚拟组中只有一个AVG，选举产生。AVG给虚拟组中其它交换机分配vmac。只有AVG响应ARP报文。选举和抢占规则和HSRP一致，高优先级或ip地址大的成为AVG，次优的成为standby，剩下的处于listen阶段，不同于hsrp只有active和standby发送hello，glbp中所有交换机都发送hello。</p><p>AVF(active virtual forward)：相同的vip，不同的vmac，都作为网关转发流量。通过权值进行选举，最多有4个AVF，也就是5台路由器组成虚拟组，其中一台是闲置的，当然这样没必要，一般两三台就够了。</p><p>AVG就是整个虚拟组的控制面，负责vmac的分配，avf是数据面，根据vmac进行转发。</p><p>GLBAP虚拟组所有成员每隔3秒发送hello报文用以保活，目的地址是224.0.0.102。承载在UDP之后，端口号是3222(source和dest一样)。</p><p>load balancing的三种模式：</p><ul><li>round-robin：根据收到arp的先后顺序，依次响应AVF1、AVF2、AVF3的vmac，然后再循环1,2,3</li><li>host-dependent：基于arp中请求者的mac地址做分配，相同的请求者始终分配相同的vmac</li><li>weighted：不同的avfs分配不同的权重值，基于此响应arp<br>AVG对ARP回应vmac的策略就是GLBP上负载均衡的策略。</li></ul><p>*GLBP的一个先决条件：一个物理端口支持配置多个mac地址(一般交换芯片都支持)*，hsrp、vrrp、glbp本质上都是一个三层接口可以配置多个ip/mac。通过ip/mac可以定位到唯一的端口，但是端口并不一定只能通过唯一的ip、mac找到。类似于一辆车上有多个车牌。</p><h3 id="vmac分配"><a href="#vmac分配" class="headerlink" title="vmac分配"></a>vmac分配</h3><p>每个虚拟组最多有4个vmac. AVG负责虚拟组内vmac分配。组成员发现AVG后通过hello消息请求vmac。通过AVG分配vmac的成为primary virtual forwarder(即通过该vmac作为网关进行数据转发)。通过hello报文学到其它forwarder的vmac的称为secondary virtual forwarder(组内的任一forwarder会学到其它所有forwarder对应的vmac)。</p><p><code>0007.b400.XXYY</code>是vmac的组成形式，XX是group id，YY是组内vmac的序列号，<code>show glbp brief</code>中<code>Fwd</code>字段可以看到。</p><h3 id="glbp优先级"><a href="#glbp优先级" class="headerlink" title="glbp优先级"></a>glbp优先级</h3><p>优先级最高的成为AVG，次之的成为standby，其它的是listen状态。如果优先级一致，ip越大越优。<br>AVG抢占默认关闭，需要手动开启。</p><h3 id="glbp权重"><a href="#glbp权重" class="headerlink" title="glbp权重"></a>glbp权重</h3><p>用权重来表示avf的数据转发能力。权重可以决定avf是否转发流量<br>可以设置一个权重阈值，当到该值值时不转发流量<br>也可以设置到指定值转发流量的阈值，可以和tracking进行联动。</p><h3 id="AVG冗余"><a href="#AVG冗余" class="headerlink" title="AVG冗余"></a>AVG冗余</h3><p>AVG挂掉后，standby接替，然后从listen状态的交换机中选举出新的standby.</p><h3 id="AVF冗余"><a href="#AVF冗余" class="headerlink" title="AVF冗余"></a>AVF冗余</h3><p>当AVF挂掉后，会从其它的secondary virtual forwarder中选出一个继续使用挂掉avf的vmac，这样用户的流量就不会中断。<br>AVF默认开启抢占。</p><h3 id="GLBP存在的问题"><a href="#GLBP存在的问题" class="headerlink" title="GLBP存在的问题"></a>GLBP存在的问题</h3><p>GLBP原本是思科私有协议，现在开源了，但是用的人并不多，因为glbp天生与stp不对付，glbp中需要各avf链路才有LB的效果，但是stp却极有可能阻塞其中的一些链路。</p><h2 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h2><p>实验拓扑图如下：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/glbp_basic_topology.png?raw=true"></p><p>S2、S3、S4在一个虚拟组内，通过interface vlan1为vlan1所在网段提供网关服务，虚拟网关ip为<code>192.168.1.254</code>，VPC5、VPC6、VPC7都在vlan1中。</p><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S2:</span><br><span class="line">interface Vlan1</span><br><span class="line"> ip address 192.168.1.2 255.255.255.0</span><br><span class="line"> glbp 1 ip 192.168.1.254</span><br><span class="line"></span><br><span class="line">S3:</span><br><span class="line">interface Vlan1</span><br><span class="line"> ip address 192.168.1.3 255.255.255.0</span><br><span class="line"> glbp 1 ip 192.168.1.254</span><br><span class="line"></span><br><span class="line">S4:</span><br><span class="line">interface Vlan1</span><br><span class="line"> ip address 192.168.1.4 255.255.255.0</span><br><span class="line"> glbp 1 ip 192.168.1.254</span><br></pre></td></tr></table></figure><p>通过<code>show glbp brief</code>查看glbp的状态：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/glbp_show_brief.png?raw=true"></p><p>对show的状态做一个简单说明：</p><ul><li><code>Grp</code>表示接口所在的glbp组id</li><li><code>Fwd</code>表示avf编号，注意第一行没有编号，显示的是AVG信息，图中可以看到AVG是S4，standby avg是S3，S2则出于listen状态。站在avf的视角下，每个avf都分配到一个vmac，对应一个fwd编号，那么他就是这个fwd编号的active，其它avf在这个编号中都是listen，当active挂掉后，从listen中选出一个继续为该fwd编号对应的vmac服务。forwarder恢复后，会收回该vmac的使用权。</li></ul><p>GLBP默认使用的LB方式是round-robin, 即根据收到arp报文的顺序，依次循环分配fwd1、2、3对应的vmac，在VPC5、6、7上依次ping网关，查看arp表项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VPC5&gt; show arp</span><br><span class="line"></span><br><span class="line">00:07:b4:00:01:01  192.168.1.254 expires in 37 seconds</span><br><span class="line"></span><br><span class="line">VPC6&gt; show arp</span><br><span class="line"></span><br><span class="line">00:07:b4:00:01:02  192.168.1.254 expires in 115 seconds</span><br><span class="line"></span><br><span class="line">VPC7&gt; show arp</span><br><span class="line"></span><br><span class="line">00:07:b4:00:01:03  192.168.1.254 expires in 113 seconds</span><br></pre></td></tr></table></figure><p>在VPC7上清除arp信息，重新ping网关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VPC7&gt; clear arp</span><br><span class="line">VPC7&gt; show arp</span><br><span class="line">arp table is emptys</span><br><span class="line">VPC7&gt; ping 192.168.1.254</span><br><span class="line"></span><br><span class="line">84 bytes from 192.168.1.254 icmp_seq&#x3D;1 ttl&#x3D;255 time&#x3D;0.409 ms</span><br><span class="line">^C0</span><br><span class="line">VPC7&gt; show arp</span><br><span class="line"></span><br><span class="line">00:07:b4:00:01:01  192.168.1.254 expires in 116 seconds</span><br></pre></td></tr></table></figure><p>和预期一致，重新分配fwd1的vmac。此外，LB还可以基于主机，基于avf权重。这里就不一一尝试了。</p>]]></content:encoded>
      
      
      
      
      <comments>https://rancho333.github.io/2022/07/07/glbp%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hsrp简述</title>
      <link>https://rancho333.github.io/2022/07/07/hsrp%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/07/hsrp%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 07 Jul 2022 09:09:02 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在介绍HSRP之前先简单说明一下FHRP(first hop redundancy protocol)，第一跳冗余协议。第一跳即网关，终端设备单网卡往往只能配置一个网关，所以会存在单点故障，传输网中则可以通过路由协议提供链路冗余。FHRP就是为了解决这一问题而出现的，需要注意的是FHRP更多的是一种场景的描述，并不是具体协议，真正的实现则是由HSRP、VRRP、GLBP、L3 mlag来完成的。类似于Ethernetchannel，其真正的实现则是由LACP、PAgP、static这些方式来完成。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在介绍HSRP之前先简单说明一下FHRP(first hop redundancy protocol)，第一跳冗余协议。第一跳即网关，终端设备单网卡往往只能配置一个网关，所以会存在单点故障，传输网中则可以通过路由协议提供链路冗余。FHRP就是为了解决这一问题而出现的，需要注意的是FHRP更多的是一种场景的描述，并不是具体协议，真正的实现则是由HSRP、VRRP、GLBP、L3 mlag来完成的。类似于Ethernetchannel，其真正的实现则是由LACP、PAgP、static这些方式来完成。</p><span id="more"></span><p>HSRP(hot standby routing protocol)和GLBP(gateway load balancing protocol)是cisco的私有协议，vrrp(virtual router redundancy protocol)是公有的。这里主要介绍HSRP的基本原理，然后做一个HSRP+PVSTP的实验来说明不同网段的负载均衡。</p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>一组交换机(实际上是交换机的三层接口)加入一个group中，这个group向外提供虚拟ip作为网关。这些交换机通过交换hsrp hello报文选举出active和standby，其它的交换机是candidates，active网关进行数据转发，当active挂掉之后，standby成为新的active，并从candidate中选举出新的standby。注意，HSRP是单活的。</p><p>只有active才会对arp进行应答，standby忽略。选举出active后，active会立即向外发送免费ARP报文，在拓扑收敛场景下，这会立马环境中的arp缓存和旧的mac地址表。</p><h2 id="简单配置说明"><a href="#简单配置说明" class="headerlink" title="简单配置说明"></a>简单配置说明</h2><p>拓扑图如下：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/hsrp_basic_topology.png?raw=true"></p><p>S8做接入交换机，网关设置在汇聚层，由S7和S9形成的虚拟IP<code>192.168.1.254</code>承担。配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">S7</span><br><span class="line">interface Vlan1</span><br><span class="line"> ip address 192.168.1.1 255.255.255.0          &#x2F;&#x2F; 配置三层接口地址，hsrp报文原地址</span><br><span class="line"> standby 1 ip 192.168.1.254                    &#x2F;&#x2F; 加入虚拟组1，虚拟ip为192.168.1.254</span><br><span class="line"></span><br><span class="line">S9</span><br><span class="line">interface Vlan1</span><br><span class="line"> ip address 192.168.1.2 255.255.255.0</span><br><span class="line"> standby 1 ip 192.168.1.254</span><br></pre></td></tr></table></figure><p>通过<code>show standby brief</code>可以查看hsrp状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S7#show standby brief </span><br><span class="line">                     P indicates configured to preempt.</span><br><span class="line">                     |</span><br><span class="line">Interface   Grp  Pri P State   Active          Standby         Virtual IP</span><br><span class="line">Vl1         1    101 P Active  local           192.168.1.2     192.168.1.254</span><br></pre></td></tr></table></figure><p>hsrp的配置非常简单，实际上就一条命令。注意standby命令的配置一定要加上group id，如果不加默认是给group 0做配置。如<code>standby ip 192.168.1.56</code>，表示端口加入虚拟组0，虚拟ip是192.168.1.56. 一个三层接口可以加入多个虚拟组。</p><h2 id="HSRP报文说明"><a href="#HSRP报文说明" class="headerlink" title="HSRP报文说明"></a>HSRP报文说明</h2><p>HSRP hello报文格式如下</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/hsrp_hello_packet.png?raw=true"></p><ul><li>version: 0表示HSRP v1, 1表示HSRP v2</li><li>op code: 0表示hello报文，1表示coup报文，3表示advertise报文</li><li>state：端口状态，见下表</li><li>hellotime: active周期性发送hello报文，standby通过监听hello报文确定active的状态。默认3秒</li><li>holdtime：active超时时间，standby在holdtime时间内没有收到active的hello报文，重新选举active。默认10秒</li><li>priority：端口优先级，优先最大的选举成为active，如果优先级一致，IP地址越大越优</li><li>group：虚拟组，三层接口加入相同虚拟组，之后选举出active/standby，虚拟组对外提供网关服务</li><li>authentication: 认证方式，可以设置认证口令，如果group相同，认证不通过，那么不能参与到虚拟组中</li><li>virtual ip add: 虚拟网关的ip. 虚拟组中的成员端口需要配置相同的vip。</li></ul><p>端口状态如下：</p><table><thead><tr><th align="left">状态</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">initial</td><td align="left">HSRP启动的初始状态</td></tr><tr><td align="left">listen</td><td align="left">路由器知道了vip，开启侦听其它HSRP路由器发送的hello报文，candidates处于该状态</td></tr><tr><td align="left">speak</td><td align="left">发送hello报文，参与选举</td></tr><tr><td align="left">standby</td><td align="left">备用网关，继续发送hello报文，<strong>源mac是发送接口的mac</strong></td></tr><tr><td align="left">active</td><td align="left">作为网关转发数据流量，继续发送hello报文，<strong>源mac是虚拟MAC</strong></td></tr></tbody></table><h2 id="Vip与Vmac"><a href="#Vip与Vmac" class="headerlink" title="Vip与Vmac"></a>Vip与Vmac</h2><p>加入同一个虚拟组的三层接口下配置相同的vip，这个ip作为终端的网关。<br>vmac是根据虚拟组ID构造出来的一个mac地址：</p><ul><li>在v1中是0000.0c07.acXX (XX = group number)</li><li>在v2中是0000.0c9f.fxxx (XXX = group number)</li></ul><h2 id="preempt抢占"><a href="#preempt抢占" class="headerlink" title="preempt抢占"></a>preempt抢占</h2><p>HSRP默认不开启抢占机制，即active/standby角色确定后，即使改变优先级比active大，也不会发生抢占。可以通过<code>S3(config-if)#standby 10 preempt</code>命令开启抢占功能。</p><p>状态稳定后，只有修改优先级才会发生抢占。不会根据IP地址的大小做出改变。</p><h2 id="md5认证"><a href="#md5认证" class="headerlink" title="md5认证"></a>md5认证</h2><p>HSRP支持认证，可以选择明文或md5. md5配置方式如下：<br><code>S2(config-if)#standby 10 authentication md5 key-string rancho</code><br>这可以避免未经授权的交换机参与HSRP计算。</p><h2 id="HSRP-Version-1-和-2"><a href="#HSRP-Version-1-和-2" class="headerlink" title="HSRP Version 1 和 2"></a>HSRP Version 1 和 2</h2><p>HSRP有两个版本，呃，貌似没什么太大区别，简单过下吧：<br>|| V1 | V2 |<br>| :— | :— | :— |<br>| group nums | 0-255 | 0-4096 |<br>| vmac | 0000.0c07.acXX (XX = group number) | 0000.0c9f.fxxx (XXX = group number)|<br>| multicast add | 224.0.0.2 | 224.0.0.102 |<br>注意两个版本是不兼容的，都同时支持ipv4和ipv6.</p><h2 id="object-tracking"><a href="#object-tracking" class="headerlink" title="object tracking"></a>object tracking</h2><p>沿用<code>简单配置说明</code>中的拓扑图。当前环境下，S7是active，如果eth1链路故障或者S7挂掉或者interface vlan1挂掉，那么S9在10秒内没有收到active的hello报文后会成为新的active。但是如果是S7的eth2挂掉，即S7没有了上行链路，eth1依然会周期性发送hello，S9并不会感知到active网关不能正常工作。</p><p>S7会向vpc发送<code>icmp redirect</code>报文让其修改默认网关，但更好的方式是让S9成为active网关。(实验时将S7上eth2 shutdown，vpc上ping R6的loopback1, 可以ping通，发现S7依然是active，S8发送的icmp报文依然是送到S7，S7将icmp的src mac改成自己mac，目的mac改成S9的mac，进而到达R6)</p><p>这种场景下需要使用<code>object tracking</code>功能来追踪S7上eth2的状态，如果上行链路故障，就降低本地hsrp优先级，使standby转换成active工作。</p><p>HSRP提供端口追踪的特性，我们可以选取一个端口进行追踪，如果挂了，就可以降低设备hsrp优先级，使其它的standby变成active。配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S7(config)#track 1 interface ethernet 0&#x2F;2 line-protocol    &#x2F;&#x2F; 创建track object 1, track内容是ethernet 0&#x2F;2的状态，如果down就触发</span><br><span class="line">S7(config-if)#standby 1 track 1 decrement 50    &#x2F;&#x2F; 在group 1上关联track object 1，如果触发将优先级降低50</span><br></pre></td></tr></table></figure><p>将S7的eth2 shutdown之后，发现优先级降低，active变了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S7#show standby brief </span><br><span class="line">                     P indicates configured to preempt.</span><br><span class="line">                     |</span><br><span class="line">Interface   Grp  Pri P State   Active          Standby         Virtual IP</span><br><span class="line">Vl1         1    50  P Speak   192.168.1.2     unknown         192.168.1.254</span><br></pre></td></tr></table></figure><p>另外一种方式是关联<code>ip sla</code>. 配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S7(config)#ip sla 1                 &#x2F;&#x2F; 创建一条sla，id是1</span><br><span class="line">S7(config-ip-sla)#icmp-echo 192.168.4.1       &#x2F;&#x2F; 测试与192.168.4.1的连通性</span><br><span class="line">S7(config-ip-sla-echo)#frequency 5            &#x2F;&#x2F;每5秒ping一次</span><br><span class="line">S7(config)#ip sla schedule 1 start-time now life forever     &#x2F;&#x2F; sla 1从现在开始运行并且一直运行下去</span><br><span class="line"></span><br><span class="line">S7(config)#track 1 ip sla 1         &#x2F;&#x2F; 创建track object 1, 与ip sla 1关联</span><br><span class="line">S7(config-if)#standby 1 track 1 decrement 80     &#x2F;&#x2F; 将track 1与group 1关联</span><br></pre></td></tr></table></figure><p>这种方式下发现S7 ping 192.168.4.1的吓一跳变成S9，因为他们之间跑了ospf。但是没关系，原理是这么个原理，把ospf关了就可以触发了。</p><h3 id="track-list特性"><a href="#track-list特性" class="headerlink" title="track list特性"></a>track list特性</h3><p>当有多个track对象，最终的结果是依赖这些对象跟踪结果时，可以使用<code>track list</code>特性。<br>沿用<code>简单配置说明</code>中的图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">track 2 interface Ethernet0&#x2F;1 line-protocol             &#x2F;&#x2F; 创建track object 2，跟踪eth1的链路状态</span><br><span class="line">!</span><br><span class="line">track 3 interface Ethernet0&#x2F;2 line-protocol             &#x2F;&#x2F; 创建track object 3，跟踪eth2的链路状态</span><br><span class="line">!</span><br><span class="line">track 4 list boolean and                                &#x2F;&#x2F; 创建track list 4, list中的对象逻辑与结果是track 4的最终结果</span><br><span class="line"> object 2                                               &#x2F;&#x2F; 给track list 4添加list监控对象2</span><br><span class="line"> object 3                                               &#x2F;&#x2F; 给track list 4添加list监控对象3</span><br><span class="line">&#x2F;&#x2F; 当eth2和eth3都是up的时候，track 4结果是up，否则down</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S7#show track brief </span><br><span class="line">Track Type        Instance                   Parameter        State Last Change</span><br><span class="line">1     ip sla      1                          state            Down  00:09:17</span><br><span class="line">2     interface   Ethernet0&#x2F;1                line-protocol    Up    00:07:55</span><br><span class="line">3     interface   Ethernet0&#x2F;2                line-protocol    Up    00:06:38</span><br><span class="line">4     list                                   boolean          Up    00:05:08</span><br></pre></td></tr></table></figure><p>当HSRP有两个上行链路时，track 2、3分别监控两个上行链路，只用在hsrp中关联track4就行，减少关联对象。</p><h2 id="HSRP结合PVSTP做不同网段流量的负载均衡"><a href="#HSRP结合PVSTP做不同网段流量的负载均衡" class="headerlink" title="HSRP结合PVSTP做不同网段流量的负载均衡"></a>HSRP结合PVSTP做不同网段流量的负载均衡</h2><p>实验拓扑如下：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/hsrp_pvstp.png?raw=true"></p><p>HSRP与PVSTP同时使用时，做不同网段的负载均衡，应注意该网段(vlan)HSRP的active与PVSTP的根桥应在同一设备上，不然流量会集中到某一台设备上，导致该设备负载过大，而另一台没有流量需要转发。配置思路如下：</p><ol><li>划分vlan，配置交换机互联trunk<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S1</span><br><span class="line">    vlan 10,20</span><br><span class="line">    interface Ethernet0&#x2F;0</span><br><span class="line">        switchport access vlan 10</span><br><span class="line">    interface Ethernet0&#x2F;1</span><br><span class="line">         switchport trunk encapsulation dot1q</span><br><span class="line">         switchport mode trunk</span><br><span class="line">    interface Ethernet0&#x2F;2</span><br><span class="line">         switchport trunk encapsulation dot1q</span><br><span class="line">         switchport mode trunk</span><br><span class="line">    interface Ethernet0&#x2F;3</span><br><span class="line">         switchport access vlan 20</span><br><span class="line">S2, S3做类似配置</span><br></pre></td></tr></table></figure></li><li>设置vlan的根桥，S2是vlan10的根桥，S3是vlan20的根桥<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S2</span><br><span class="line">    spanning-tree vlan 10 priority 4096</span><br><span class="line">S3</span><br><span class="line">    spanning-tree vlan 20 priority 4096</span><br></pre></td></tr></table></figure></li><li>创建interface vlan; 设置hsrp，S2是vlan10所在网段的active，S3是vlan20所在网段 的active<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">S2</span><br><span class="line">    interface Vlan10</span><br><span class="line">        ip address 192.168.1.1 255.255.255.0</span><br><span class="line">        standby 10 ip 192.168.1.254</span><br><span class="line">        standby 10 priority 101</span><br><span class="line">        standby 10 preempt</span><br><span class="line">S3</span><br><span class="line">    interface Vlan10</span><br><span class="line">        ip address 192.168.1.3 255.255.255.0</span><br><span class="line">        standby 10 ip 192.168.1.254</span><br><span class="line">        standby 20 preempt</span><br><span class="line">&#x2F;&#x2F;S2作为vlan10网段的active</span><br><span class="line"></span><br><span class="line">S2</span><br><span class="line">    interface Vlan20</span><br><span class="line">       ip address 192.168.2.1 255.255.255.0</span><br><span class="line">       standby 20 ip 192.168.2.254</span><br><span class="line">       standby 10 preempt</span><br><span class="line">S3</span><br><span class="line">    interface Vlan20</span><br><span class="line">       ip address 192.168.2.3 255.255.255.0</span><br><span class="line">       standby 20 ip 192.168.2.254</span><br><span class="line">       standby 20 priority 101</span><br><span class="line">       standby 20 preempt</span><br><span class="line">&#x2F;&#x2F; S3作为vlan20网段的active</span><br></pre></td></tr></table></figure>完成后的流量路径如下图所示：</li></ol><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/hsrp_pvstp_1.png?raw=true"></p><p>在多实例中我们将不同vlan的根桥放置在不同的设备上，这样可以让不同实例的流量路径不一致，从而最大限度的利用带宽，减少流量拥塞，避免带宽浪费，同时也避免单一设备负载过高。</p><p>网关一般设置在汇聚层，我们假象下，如果vlan的根桥是S2，而active是S3，那么vpc4的流量需要经过S1到S2再转到S3(S3的eth2是block的)，无疑多了一次转发，这是不必要的，我们应当避免。</p>]]></content:encoded>
      
      
      
      
      <comments>https://rancho333.github.io/2022/07/07/hsrp%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VRRP简述</title>
      <link>https://rancho333.github.io/2022/07/07/VRRP%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/07/VRRP%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 07 Jul 2022 09:07:29 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;VRRP(virtual router redundancy protocol)和&lt;code&gt;HSRP&lt;/code&gt;非常相似，原理相同，只不过VRRP是公有的(RFC 3768)，HSRP是思科私有的。&lt;code&gt;《HSRP简述》&lt;/code&gt;中对虚拟路由冗余协议做了基本的阐述和实验说明，这篇文章主要描述两者之间的差异，然后做个实验来验证下。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>VRRP(virtual router redundancy protocol)和<code>HSRP</code>非常相似，原理相同，只不过VRRP是公有的(RFC 3768)，HSRP是思科私有的。<code>《HSRP简述》</code>中对虚拟路由冗余协议做了基本的阐述和实验说明，这篇文章主要描述两者之间的差异，然后做个实验来验证下。</p><span id="more"></span><h1 id="VRRP与HSRP的差异"><a href="#VRRP与HSRP的差异" class="headerlink" title="VRRP与HSRP的差异"></a>VRRP与HSRP的差异</h1><table><thead><tr><th align="left"></th><th align="left">HSRP</th><th align="left">VRRP</th></tr></thead><tbody><tr><td align="left">protocol</td><td align="left">cisco proprietary</td><td align="left">IETF-RFC3768</td></tr><tr><td align="left">number of groups</td><td align="left">0-255,0是默认</td><td align="left">1-255</td></tr><tr><td align="left">active/standby</td><td align="left">一个active, 一个standby，多个候选者</td><td align="left">术语叫法不同，一个master，多个backups</td></tr><tr><td align="left">Vip</td><td align="left">不能和三层接口ip相同</td><td align="left">可以相同，如果相同，优先级直接变成最高</td></tr><tr><td align="left">Vmac</td><td align="left">v1，v2有差异，见hsrp简述</td><td align="left">00:00:5e:00:01:xx, xx是group id</td></tr><tr><td align="left">multicast address</td><td align="left">224.0.0.2</td><td align="left">224.0.0.18</td></tr><tr><td align="left">tracking</td><td align="left">interfaces or objects, 触发后降低优先级或退出组</td><td align="left">objeects，触发后降低优先级，没有退出组</td></tr><tr><td align="left">timers</td><td align="left">hello timer 3秒，hold time 10秒</td><td align="left">hello 1秒，holdtime 3秒</td></tr><tr><td align="left">authentication</td><td align="left">支持</td><td align="left">rfc中不支持，厂家支持</td></tr><tr><td align="left">preempt</td><td align="left">默认不开启，可配置</td><td align="left">默认开启抢占</td></tr><tr><td align="left">报文封装</td><td align="left">UDP 1985</td><td align="left">基于IP</td></tr><tr><td align="left">version</td><td align="left">默认v1</td><td align="left">v2,v3两个版本，默认v2，v3才支持ipv6</td></tr><tr><td align="left">load balancing</td><td align="left">支持不同组之间</td><td align="left">支持不同组之间</td></tr><tr><td align="left">priority</td><td align="left">不支持辞职，优先级为0可以手动配置，没有特殊含义</td><td align="left">优先级为0表示放弃master位置，优先级0不能手动配置</td></tr></tbody></table><p>关于辞职，当master路由器接口shutdown时，会立即发送优先级为0的通告，vrrp中优先级为0表示不参与虚拟组计算，收到的backups之间会立即重新选举出新的master，否则就要等待3秒的报文超时再选举，这样可以加快收敛时间。优先级为0的报文如下：</p><p><img src="!%5B%5D(https://github.com/Rancho333/pictures_hub/blob/master/non_auto/vrrp_packet_priority_0.png?raw=true"></p><p>在HSRP中，tracking中触发支持shutdown，如果active路由器接口shutdown，那么standby只能等待10秒超时后变成active. VRRP tracking中不支持shutdown，嗯，也就是说只有路由接口手动shutdown或物理线路挂掉才会触发优先级为0的报文，而上行链路挂掉tracking无法触发？</p><h1 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h1><p>实验拓扑图如下：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/vrrp_basic_topology.png?raw=true"></p><p>S2、S3、S4的interface vlan1加入虚拟组组成虚拟路由器，虚拟组对外提供网关服务。基本配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S2</span><br><span class="line">    interface Vlan1</span><br><span class="line">        ip address 192.168.1.1 255.255.255.0        &#x2F;&#x2F; svi配置IP地址</span><br><span class="line">        vrrp 1 ip 192.168.1.254                     &#x2F;&#x2F; svi加入虚拟组1，虚拟ip为192.168.1.254</span><br><span class="line">S3</span><br><span class="line">    interface Vlan1</span><br><span class="line">        ip address 192.168.1.2 255.255.255.0</span><br><span class="line">        vrrp 1 ip 192.168.1.254</span><br><span class="line">S4</span><br><span class="line">    interface Vlan1</span><br><span class="line">        ip address 192.168.1.3 255.255.255.0</span><br><span class="line">        vrrp 1 ip 192.168.1.254</span><br></pre></td></tr></table></figure><p><code>show vrrp brief</code>查看vrrp状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S4#show vrrp brief </span><br><span class="line">Interface          Grp Pri Time  Own Pre State   Master addr     Group addr</span><br><span class="line">Vl1                1   100 3609       Y  Master  192.168.1.3     192.168.1.254</span><br></pre></td></tr></table></figure><p>vrrp的默认优先级也是100，超期时间单位是毫秒，有计算公式，是hello的三倍多点，<code>own</code>表示是否是虚拟组的拥有者，当物理接口ip和虚拟组ip一致时成为owner, 通过将优先级置位最大值255实，如将S3设置成owner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S3(config-if)#ip address 192.168.1.254 255.255.255.0</span><br><span class="line">S3#show vrrp brief </span><br><span class="line">Interface          Grp Pri Time  Own Pre State   Master addr     Group addr</span><br><span class="line">Vl1                1   255 3003   Y   Y  Master  192.168.1.254   192.168.1.254</span><br></pre></td></tr></table></figure><p>优先级为255的报文为：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/vrrp_packet_priority_255.png?raw=true"></p><p>owner不能被配置优先级。 vrrp默认开启preempt，所以<code>pre</code>是<code>Y</code>。注意vrrp组中除master外，其余都是backup，即master挂掉后，会从backup中重新选举出新的master。而hsrp中master挂掉后，standby接替，之后在candidate中选举出新的standby。</p><p><strong>所以VRRP中只有master发送announcement，backup监听。hsrp中active和backup都需要发送hello报文。</strong></p><p>当然，FHRP中一般搞两台路由器做网关冗余就行了。</p><h2 id="其它实验"><a href="#其它实验" class="headerlink" title="其它实验"></a>其它实验</h2><p>tracking上行链路故障，不同组之间的负载均衡，和HSRP没区别，这里就不重复了。</p><h2 id="双活网关"><a href="#双活网关" class="headerlink" title="双活网关"></a>双活网关</h2><p>HSRP/VRRP只能实现单活网关，只有active进行arp应答和转发业务流量，standby则完全闲置。结合MLAG则可实现双活网关:</p><ol><li>active负责arp应答，standby会将arp中继给active</li><li>控制面视角而言，依然是active/standby，数据面而言active/active转发</li><li>接入交换机上mac地址表中vmac对应的端口是mlag聚合端口，所以active/standby都有可能收到报文，收到后按路由表正常转发即可。如果不是mlag场景，standby收到目的地址是vmac的报文。</li><li>eveng中不支持vpc模拟，vpc的peer-link需要10G端口才能运行，不然会后各种问题。</li></ol><h2 id="为甚vip不会冲突"><a href="#为甚vip不会冲突" class="headerlink" title="为甚vip不会冲突"></a>为甚vip不会冲突</h2><p>在两台设备上部署了相同的vip+vmac，为什么不会冲突？<br>IP通信通过arp报文获取mac，主机请求网关vip时，只有active才会做出回应，所以除了active外，网络中并不会有其它设备感知到standby。<br>从另外一个角度来说？一般设备配置ip地址后会向外发送免费arp报文，一是避免ip冲突，而是主动告知其它设备自己arp信息。交换机变成active后也会主动发送免费arp，standby收到后也不会处理，所以就不冲突了。<br>从实际通信报文的角度来看，standby是收不到vmac的报文的，如果能收到，也能正常转发，这就是mlag+vrrp实现双活网关的原理。</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/VRRP/">VRRP</category>
      
      
      <comments>https://rancho333.github.io/2022/07/07/VRRP%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>mstp802.1s简述</title>
      <link>https://rancho333.github.io/2022/07/07/mstp802-1s%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/07/mstp802-1s%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 07 Jul 2022 08:22:19 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;STP和RSTP无法实现负载均衡，cisco的PVST和PVRSTP虽然能够实现，但是每个vlan对应一个实例，在vlan较多的情况下，这对CPU以及内存资源会有极大的浪费。所以MSTP横空出世，其核心理念是：将一组vlan映射到一个实例中，每个实例运行一个stp树。MSTP的实现标准是802.1s.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>STP和RSTP无法实现负载均衡，cisco的PVST和PVRSTP虽然能够实现，但是每个vlan对应一个实例，在vlan较多的情况下，这对CPU以及内存资源会有极大的浪费。所以MSTP横空出世，其核心理念是：将一组vlan映射到一个实例中，每个实例运行一个stp树。MSTP的实现标准是802.1s.</p><span id="more"></span><h1 id="MST中的几个概念"><a href="#MST中的几个概念" class="headerlink" title="MST中的几个概念"></a>MST中的几个概念</h1><h2 id="域-region"><a href="#域-region" class="headerlink" title="域(region)"></a>域(region)</h2><p>具有<code>相同属性</code>的交换机在同一个域中：</p><ul><li>MST域名</li><li>MST版本号</li><li>MST中vlan与实例的映射关系</li></ul><p>MST域名是给该域配置的名字，可以随便起。版本号也可以随便起(类似VTP中的版本号，只有一样才会同步)。映射到同一个实例中的vlan属于同一个stp树，有相同的根桥，转发路径，阻塞路径等。类似于端口与vlan的映射，所有的vlan最开始属于默认实例(cisco中是instance 0).</p><h2 id="IST"><a href="#IST" class="headerlink" title="IST"></a>IST</h2><p>IST是internal spanning tree的缩写，表示默认实例。MST只会通过IST向其它域通告BPDU.</p><h2 id="CIST"><a href="#CIST" class="headerlink" title="CIST"></a>CIST</h2><p>CIST是common and internal spanning tree，公共和内部生成树，是整个大二层网络所有交换机组成的单生成树(所有域共同组成)，将每个域看做一台设备，CST(common spanning tree)就是由这些设备组成的树</p><h2 id="MSTI"><a href="#MSTI" class="headerlink" title="MSTI"></a>MSTI</h2><p>MSTI是multi spanning tree instance的缩写，多实例生成树的实例</p><h2 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h2><p>MSTP中的选举规则和STP完全一致，快速收敛机制则和RSTP完全一致。</p><h2 id="MST的BPDU"><a href="#MST的BPDU" class="headerlink" title="MST的BPDU"></a>MST的BPDU</h2><p>区别于pvstp中每个vlan都会发送一个BPDU，MSTP中并不是每个实例发送一个BPDU，而是一台交换机只会发送一个BPDU，这一个BPDU中包含了所有的实例。具体到字段而言：</p><ul><li>protocol version字段是0x03</li><li>BPDU type字段和rstp一样是0x02</li><li>flags字段和rstp保持一致</li><li>BID字段中的扩展ID则为0<br>其它字段简介如下：<br><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/mstp_bpdu.png?raw=true"></li></ul><p>MSTP配置比较复杂，特别是在多域使用尤其复杂，本文只通过单域对MSTP有一个简单的了解。</p><h1 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h1><p>经典的三角环形拓扑， 创建一个MSTP域，域内创建两个实例instance 1、2, vlan 10-15映射到实例1， vlan 16-20映射到实例2。实例0的根桥是S1，实例1的根桥是S2，实例2的根桥是S3. 拓扑图如下：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/920baf1e40926adc604b727854fd10b7861dc24e/non_auto/mstp_topology.png?raw=true"></p><p>实验步骤如下：<br>创建Vlan 10-20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1(config)#vlan 10-20</span><br><span class="line">&#x2F;&#x2F; S2和S3做相同配置</span><br></pre></td></tr></table></figure><p>交换机之间配置trunk连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S1(config)#interface range ethernet 0&#x2F;0-1</span><br><span class="line">S1(config-if-range)#switchport trunk encapsulation dot1q</span><br><span class="line">S1(config-if-range)#switchport mode trunk</span><br><span class="line">&#x2F;&#x2F; S2和S3做相同配置</span><br></pre></td></tr></table></figure><p>配置stp版本为MSTP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1(config)#spanning-tree mode mst</span><br><span class="line">&#x2F;&#x2F; S2和S3做相同配置</span><br></pre></td></tr></table></figure><p>配置MSTP域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S1(config)#spanning-tree mst configuration      &#x2F;&#x2F; 进入mst域配置视图</span><br><span class="line">S1(config-mst)#name rancho                      &#x2F;&#x2F; 设置域名</span><br><span class="line">S1(config-mst)#instance 1 vlan 10-15            &#x2F;&#x2F; 设置实例1与vlan的映射</span><br><span class="line">S1(config-mst)#instance 2 vlan 16-20            &#x2F;&#x2F; 设置实例2与vlan的映射</span><br><span class="line">S1(config-mst)#revision 1                       &#x2F;&#x2F; 设置版本号</span><br><span class="line">&#x2F;&#x2F; S2与S3做相同配置，注意：域名、vlan与实例的映射，版本号这三者必须一致</span><br></pre></td></tr></table></figure><p>给实例配置不同的根桥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S2(config)#spanning-tree mst 1 priority 4096    &#x2F;&#x2F; 设置S2为实例1中最优BID</span><br><span class="line">S3(config)#spanning-tree mst 2 priority 4096    &#x2F;&#x2F; 设置S3为实例2中最优BID</span><br><span class="line">&#x2F;&#x2F; S1的mac地址最小，实例0中三台交换机优先级都是32768，所以实例0中S1是根桥</span><br></pre></td></tr></table></figure><p>实验结果对比检查：<br>确认配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S1#show spanning-tree mst configuration </span><br><span class="line">Name      [rancho]</span><br><span class="line">Revision  1     Instances configured 3</span><br><span class="line"></span><br><span class="line">Instance  Vlans mapped</span><br><span class="line">--------  ---------------------------------------------------------------------</span><br><span class="line">0         1-9,21-4094</span><br><span class="line">1         10-15</span><br><span class="line">2         16-20</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">&#x2F;&#x2F; S2与S3中做相同检查</span><br></pre></td></tr></table></figure><p>确认实例0中根桥及端口状态：<br><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/mstp_instance_0.png?raw=true"></p><p>可以看到实例0中，S1是根桥，S3的eth0处于blocking状态。</p><p>确认实例1中根桥及端口状态：<br><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/mstp_instance_1.png?raw=true"></p><p>可以看到实例1中，S2是根桥，S3的eth1处于blocking状态。</p><p>确认实例2中根桥及端口状态：<br><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/mstp_instance_2.png?raw=true"></p><p>可以看到实例2中，S3是根桥，S2的eth0处于blocking状态。</p><p>三个实例中对应的转发路径如下图所示：<br><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/mstp_instance_forward_path.png?raw=true"></p><p>可以看到不同实例的流量之间负载均衡。</p><h1 id="兼容性说明"><a href="#兼容性说明" class="headerlink" title="兼容性说明"></a>兼容性说明</h1><p>MSTP向下兼容RSTP和STP，不建议这么使用。</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/STP/">STP</category>
      
      
      <comments>https://rancho333.github.io/2022/07/07/mstp802-1s%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RSTP802.1w简述</title>
      <link>https://rancho333.github.io/2022/07/07/RSTP802-1w%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/07/RSTP802-1w%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 07 Jul 2022 07:49:15 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;&lt;code&gt;《STP(802.1d)简述》&lt;/code&gt;中描述了STP协议实现loop-free的原理，举例说明了根桥及端口的选举规则，当发生链路故障时的收敛过程，最后列举了加快STP收敛的特性及安全特性。STP的最大收敛时间可达50秒左右，为了加快收敛时间，RSTP(rapid STP)诞生了。RSTP主要通过&lt;code&gt;P/A机制&lt;/code&gt;减少端口状态切换时间，通过处理&lt;code&gt;inferior BPDU&lt;/code&gt;减少BPDU老化时间，并且集成了portfast、uplinkfast、backbonefast机制。下面主要阐述两者之间的差异，以及RSTP实现快速收敛的一些细节。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><code>《STP(802.1d)简述》</code>中描述了STP协议实现loop-free的原理，举例说明了根桥及端口的选举规则，当发生链路故障时的收敛过程，最后列举了加快STP收敛的特性及安全特性。STP的最大收敛时间可达50秒左右，为了加快收敛时间，RSTP(rapid STP)诞生了。RSTP主要通过<code>P/A机制</code>减少端口状态切换时间，通过处理<code>inferior BPDU</code>减少BPDU老化时间，并且集成了portfast、uplinkfast、backbonefast机制。下面主要阐述两者之间的差异，以及RSTP实现快速收敛的一些细节。</p><span id="more"></span><h1 id="RSTP与STP的差异"><a href="#RSTP与STP的差异" class="headerlink" title="RSTP与STP的差异"></a>RSTP与STP的差异</h1><p>RSTP中根桥的选举规则，端口的选举规则和STP保持一致。superior BPDU依然是其中的核心。差异主要体现在下面几点。</p><h2 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h2><p>STP中的disabled、blocking、listening三种状态合并到RSTP的discarding。STP中的端口状态过于细分，比如blocking只能接收BPDU，而listening可以接收和发送BPDU，两者都不能学习MAC地址。过多的状态切块增加了收敛时间。当然，多的状态可以极大的减少网络环路的风险。两者端口状态对比如下：</p><table><thead><tr><th align="left">STP</th><th align="left">RSTP</th><th align="left">是否在活动的拓扑中</th><th align="left">是否学习mac地址</th></tr></thead><tbody><tr><td align="left">disabled</td><td align="left">discarding</td><td align="left">no</td><td align="left">no</td></tr><tr><td align="left">blocking</td><td align="left">discarding</td><td align="left">no</td><td align="left">no</td></tr><tr><td align="left">listening</td><td align="left">discarding</td><td align="left">no</td><td align="left">no</td></tr><tr><td align="left">learning</td><td align="left">learning</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">forwarding</td><td align="left">forwarding</td><td align="left">yes</td><td align="left">yes</td></tr></tbody></table><p>究其原因，RSTP中通过P/A机制主动协商可以直接将端口从discarding状态转换到forwarding，而不是STP中通过定时器机制经过forward_delay后再切换状态。</p><h2 id="端口角色"><a href="#端口角色" class="headerlink" title="端口角色"></a>端口角色</h2><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/rstp_election.png?raw=true"></p><p>RSTP中增加了一种端口角色<code>backup port</code>. 如上图所示，S2的eth2端口为BP。非根交换机收到自己发出的BPDU时，对比端口上发出和收到的BPDU，如果发出的是<code>superior BPDU</code>，那么成为DP，否则成为BP。注意与AP端口的差异：</p><ul><li>AP是端口收到从<code>其它交换机</code>发来的superior BPDU，是RP的备份，这是uplinkfast实现的原理</li><li>BP是端口收到从<code>自身交换机</code>发来的superior BPDU, 是DP的备份，uplinkfast对BP不生效，BP在现实网络中很少见，基本用不到。图中通过在S2和S3中加一个hub来实现，如果没有hub，S2的eth1和eth2都是DP。</li></ul><h2 id="BPDU的变化"><a href="#BPDU的变化" class="headerlink" title="BPDU的变化"></a>BPDU的变化</h2><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/rstp_bpdu.png?raw=true"></p><p>RSTP的BPDU与STP的主要在三个字段上有差异：</p><ul><li>protocol version identifier：stp为0，rstp为2. rstp向下兼容stp</li><li>BPDU type: stp为0, rstp为2。rstp中没有类型为0x80的TCN报文，在配置BPDU中使用TC flag替代</li><li>flags：stp中只使用TC和TCA两个flags，rstp中使用上了剩下的6 bits, 其中bit3和bit2表示端口角色：<ul><li>0x00 表示未知类型</li><li>0x01 表示RP</li><li>0x10 表示AP或BP</li><li>0x11 表示DP</li></ul></li></ul><h3 id="BPDU的发送"><a href="#BPDU的发送" class="headerlink" title="BPDU的发送"></a>BPDU的发送</h3><p>STP中根桥周期(hello time)发送BPDU，非根桥从RP收到然后从DP中继出去。RSTP非根桥自己生成BPDU(根据缓存的根桥cache)，周期(hello time)通过DP向外发送</p><h3 id="BPDU的超时"><a href="#BPDU的超时" class="headerlink" title="BPDU的超时"></a>BPDU的超时</h3><p>STP上如果端口有存储的BPDU，max_age时间内没有收到superior BPDU后便会对其超时。RSTP通过BPDU实现类似ospf中的keepalive机制，如果连续三个hello_time时间内没有从邻居收到BPDU，那么就认为该链路故障，并且立即清除所有MAC地址。</p><h3 id="边缘端口"><a href="#边缘端口" class="headerlink" title="边缘端口"></a>边缘端口</h3><p>STP的收敛优化里面有<code>portfast</code>的概念，在rstp中则称之为<code>edge port</code>, 即连接主机的端口。开启edge port的端口不需要经历discarding、learning的过度，而是直接变成forwarding，端口up、down也不会产生TC。注意边缘端口的链路类型只能是p2p, 即全双工链路，区别于半双工链路(shared类型)。<br>需要注意的是RSTP中同样需要管理员手动指定edge port。uplinkfast和backbonefast特性则是自动运行的。</p><h3 id="PA协商机制-重要区别"><a href="#PA协商机制-重要区别" class="headerlink" title="PA协商机制(重要区别)"></a>PA协商机制(重要区别)</h3><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/rstp_pa_mechanism.png?raw=true"></p><p>PA机制的基本原理就是：将下游block之后，再将上游forwarding，这种过程向下传导，直至整个RSTP开始运转，下游block的时候依然可以传输BPDU，进行角色选举。需要把STP的选举机制联想起来，不要孤立的看待PA机制。<br>通过上图来介绍P/A协商机制的原理。</p><ol><li>当设备上电后，S1、S2均认为自己是根桥并向外发送BPDU(proposal flag置位)，端口状态均为blocking</li><li>S2的eth0收到S1的eth0发来的superior BPDU，确定S1是根桥，S2的eth0成为RP(立即切换成forwarding)，将所有非边缘DP(eth1,eth2)状态置为block, 并通过非边缘DP发送BPDU(根桥是S1，proposal flag置位)，之后向根桥发送BPDU(TC置位, agreement置位，该BPDU是proposal BPDU的一个拷贝, 所以BID和sender BID都是S1，只是去掉了proposal的flag，增加了agreement的flag，这可以让接收到agreement的端口知道具体是那个端口发出的proposal)，具体报文如下图：</li></ol><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/rstp_pa_packet.png?raw=true"></p><ol start="3"><li>S1收到agreement置位的BPDU后，将eth0由block置为forwarding，如果没有收到，则会通过discarding、learning切换到forwarding状态(比如下游设备运行STP时就会出现这种场景)</li><li>以上为一个同步的完成流程，之后S2与S3，S2与S4之间会进行同样的同步协商动作。即S2向S3,S4发送proposal报文，S3,S4选出RP，block非边缘DP，并向下游发送proposal报文(改实例中没有)，S3,S4向S2发送agreement报文，并将自身RP置位forwarding，S2将收到agreement报文的DP置位forwarding状态</li><li>端口状态变成forwarding，之后发送的BPDU就不会有proposal置位了。</li><li>PA同步机制其实就是传递一组PA报文(A是P的拷贝), 由于没有定时器机制，以上流程发生非常快，亚秒级就可完成端口状态的切换。</li><li>如果发出P=1的报文没有收到A=1的回复，则使用STP一样的机制进行状态转换。比如DP-AP之间，边缘端口但是没有配置portfast的时候。</li></ol><h3 id="拓扑变化机制-重要区别"><a href="#拓扑变化机制-重要区别" class="headerlink" title="拓扑变化机制(重要区别)"></a>拓扑变化机制(重要区别)</h3><p>RSTP的拓扑变化机制与STP有很大的区别，触发机制和传播TC信息都有区别。<br>STP中链路故障会触发TC(topology change，up or down)，RSTP中不会讲链路故障视作TC。RSTP中只有<code>非边缘DP端口</code>状态转换成forwarding时才会视作TC。当RSTP检测到TC时：</p><ul><li>开启2倍hello time作为TC持续时间。在非边缘DP和RP上生效。</li><li>flush该端口上学到的MAC地址表</li><li>在TC持续时间内,BPDU中TC置位，从非边缘DP和RP向外发送。</li></ul><p>当了邻居收到TC报文后：</p><ul><li>flush除收到TC报文之外的所有端口上的MAC地址表</li><li>开启TC持续时间计时器，在非边缘DP和RP上生效，并发送TC置位BPDU。</li></ul><p>区别于STP中只向RP发送TCN，等待根桥发送TC/TCA置位BPDU，然后等待forward_delay的时间让MAC地址表超时，RSTP可以很快让全网知道TC并flush mac地址表，这样做有利有弊，可能会增加潜在的flooding流量，但同时也快速的清理了潜在的无效MAC地址表信息。</p><h3 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h3><p>RSTP向下兼容STP，但是快速收敛的特性就没有了。STP不会处理RSTP的报文。</p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>STP中虽然通过portfast、uplinkfast、backbonefast的机制一定程度上加快了STP在特定场景下的收敛，但这些特性时私有了，个厂家实现有差异，而RSTP中将其集成到了标准之中。而P/A协商机制，TC拓扑变化机制的引入更是将拓扑收敛时间降到了一秒内，相对于STP是巨大的提升。但是RSTP也带来了一些问题：</p><ul><li>必stp配置复杂</li><li>消耗更多的CPU资源</li><li>使用根桥cache信息，可能会导致count-in-infinity的问题</li></ul><p>RSTP比STP收敛更快的原因是：</p><ol><li>PA机制</li><li>TC机制</li><li>邻居keepalive机制(3个hello time)</li><li>集成backbonefast，配置边缘端口(uplinkfast实际是PA机制)</li></ol><h2 id="两个实验"><a href="#两个实验" class="headerlink" title="两个实验"></a>两个实验</h2><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/rstp_convergence_experiment.png?raw=true"></p><p>实验拓扑如上，操作步骤如下：</p><ol><li>vpc1和vpc2在同一网段，vpc1持续ping vpc2</li><li>模拟TC，观察ping中断时间以及端口角色、状态变化</li></ol><p>注意实验之前需要正确配置边缘端口，cisco上和配置stp中portfast特性命令一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config-if)#spanning-tree portfast edge        &#x2F;&#x2F; 将接口配置成边缘端口</span><br></pre></td></tr></table></figure><p>如果没有配置，根据P/A协商机制，当S2的eth0 down掉后，eth1会在discarding、learning、forwarding状态间进行时延转换(30秒)。原因是从eth1发出的proposal报文没有收到agreement回复。<br>STP中portfast只是让端口跳过状态切换，并且状态变换不会产生TCN，但是RSTP中边缘端口和PA机制有相互作用，<em>注意</em>！</p><h3 id="backbonefast特性测试"><a href="#backbonefast特性测试" class="headerlink" title="backbonefast特性测试"></a>backbonefast特性测试</h3><p>在S2上shutdown端口eth0，S2的eth2发送inferior BPDU，模拟backbonefast特性测试。ping结果如下：</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/rstp_convergence_ping.png?raw=true"></p><p>没有发现丢包，只是shutdown瞬间一个包时延大了一些, 相较于STP开启backfast之后依然断流30秒(S3上eth0状态切换时延)，提升很巨大。S2上端口状态如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Switch#show spanning-tree | begin Interface</span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0&#x2F;1               Desg FWD 100       128.2    P2p Edge </span><br><span class="line">Et0&#x2F;2               Root FWD 100       128.3    P2p </span><br><span class="line">Et0&#x2F;3               Desg BLK 100       128.4    P2p</span><br></pre></td></tr></table></figure><p>可以看到eth2通过PA协商立即变成RP的forwarding状态，eth1上配置了边缘端口，不参与PA，所以依然是forwarding，eth3上没有配置边缘端口，处于blocking,经过30秒时延转换成forwarding。</p><p>S3上eth0端口则在瞬间有AP变成DP forwarding状态，这里不做展示。</p><h3 id="uplinkfast特性测试"><a href="#uplinkfast特性测试" class="headerlink" title="uplinkfast特性测试"></a>uplinkfast特性测试</h3><p>在S3上shutdown端口eth1，eth0从AP变成RP forwarding状态。ping测试结果保持和上面一致，没有丢包，只是时延增加。S3上端口状态如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Switch#show spanning-tree | begin Interface</span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0&#x2F;0               Root FWD 100       128.1    P2p </span><br><span class="line">Et0&#x2F;2               Desg FWD 100       128.3    P2p Edge </span><br><span class="line">Et0&#x2F;3               Desg LRN 100       128.4    P2p</span><br></pre></td></tr></table></figure><p>对于STP，在vpc1持续ping vpc2刷新mac地址的场景下，在S3上开启uplinkfast特性，shutdown S3的eth1后，大概需要<code>15秒</code>才能恢复通信，eth0从AP直接转换成DP forwarding状态，并发送TCN报文到S2，S2从eth0发送到根桥，收到根桥发来的TC报文后，设置15秒的MAC地址表老化超时，S2上VPC2的MAC地址指向eth0,15秒超时后重新学习，通信恢复。S3收到TCA后停止发送TCN。</p><p><strong>参考资料：</strong><br><a href="https://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/24062-146.html">Understanding Rapid Spanning Tree Protocol (802.1w)</a></p><p><em>《802.1w-2001》</em></p><p><em>《802.1d-2004》</em></p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/STP/">STP</category>
      
      
      <comments>https://rancho333.github.io/2022/07/07/RSTP802-1w%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>STP802.1d简述</title>
      <link>https://rancho333.github.io/2022/07/07/STP802-1d%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/07/STP802-1d%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 07 Jul 2022 07:35:21 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文旨在描述STP(802.1d)的一些基本概念，搞清楚其消除二层环路的原理，为后面的RSTP已经MSTP的学习做铺垫。STP是一个高度自动化的协议，一两条简单的命令就可以让其自动计算，链路故障时也可以自动恢复，但只有真正掌握其实现原理，才能在故障时进行修复，才能合理的使用其安全特性和优化特性。现有的STP有多个版本，包括标准STP(802.1d),快速RSTP(802.1w), 多实例MSTP(802.1s)。思科使用PVSTP(per-vlan stp)替代标准STP.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文旨在描述STP(802.1d)的一些基本概念，搞清楚其消除二层环路的原理，为后面的RSTP已经MSTP的学习做铺垫。STP是一个高度自动化的协议，一两条简单的命令就可以让其自动计算，链路故障时也可以自动恢复，但只有真正掌握其实现原理，才能在故障时进行修复，才能合理的使用其安全特性和优化特性。现有的STP有多个版本，包括标准STP(802.1d),快速RSTP(802.1w), 多实例MSTP(802.1s)。思科使用PVSTP(per-vlan stp)替代标准STP.</p><span id="more"></span><h1 id="STP的作用"><a href="#STP的作用" class="headerlink" title="STP的作用"></a>STP的作用</h1><p>STP不仅仅是为了消除二层环路，其根本的作用是<code>提供L2线路冗余的同时避免环路</code>。二层环路会带来下面几个问题：</p><ol><li>广播风暴</li><li>重复帧</li><li>MAC地址跳跃</li></ol><h1 id="STP如何实现冗余及避免环路的"><a href="#STP如何实现冗余及避免环路的" class="headerlink" title="STP如何实现冗余及避免环路的"></a>STP如何实现冗余及避免环路的</h1><p>当有环的时候通过阻塞某些端口破坏环路，当线路挂掉的时候通过恢复之前阻塞的端口继续提供服务。要达到这样的效果，需要额外的检查，STP通过BPDU(bridge protocol data unit)来实现这种额外的检查。</p><p>这种检查的基本逻辑是，确定设备的角色，然后再确定设备上端口的角色，确定端口的状态，根据角色、状态这两个属性确定端口对报文的接收、发送、转发、学习、丢弃能力。</p><h1 id="STP中的一些重要概念"><a href="#STP中的一些重要概念" class="headerlink" title="STP中的一些重要概念"></a>STP中的一些重要概念</h1><h2 id="BID"><a href="#BID" class="headerlink" title="BID"></a>BID</h2><p>BID由优先级和参与STP计算的最小端口MAC地址组成，默认优先级是<code>32768</code>, 思科默认运行的PVSRT中会将vlan ID加到优先级中，所以它的默认优先级是<code>32768+1</code>。</p><h2 id="根桥"><a href="#根桥" class="headerlink" title="根桥"></a>根桥</h2><p>STP的目的是形成一颗以根桥为起点的无环树状结构，根桥是BID最小的网桥。</p><h2 id="3中端口角色"><a href="#3中端口角色" class="headerlink" title="3中端口角色"></a>3中端口角色</h2><table><thead><tr><th align="left">端口角色</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">root port(RP)</td><td align="left">非根交换机到跟交换机cost最小的端口，上联根桥的端口</td></tr><tr><td align="left">designated port(DP)</td><td align="left">根桥和非根桥上都有，根桥的所有端口都是DP，连接下游的端口</td></tr><tr><td align="left">Alternate port(AP)</td><td align="left">剩下的端口都是AP,AP端口一般都处于blocking状态, 只接收BPDU，不做任何转发处理</td></tr></tbody></table><h2 id="5种端口状态"><a href="#5种端口状态" class="headerlink" title="5种端口状态"></a>5种端口状态</h2><table><thead><tr><th align="left">状态</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">disabled</td><td align="left">该状态下的端口没有激活，不参与STP的任何动作，不转发用户流量</td></tr><tr><td align="left">blocking</td><td align="left">只能接收BPDU</td></tr><tr><td align="left">listening</td><td align="left">该状态下的端口可以接收和发送BPDU，但不转发用户流量，不学习mac地址</td></tr><tr><td align="left">learning</td><td align="left">该状态下建立无环的转发表，不转发用户流量，学习mac地址</td></tr><tr><td align="left">forwarding</td><td align="left">接收和发送BPDU，也转发用户流量</td></tr></tbody></table><h2 id="四个计时器"><a href="#四个计时器" class="headerlink" title="四个计时器"></a>四个计时器</h2><p>STP很多工作的完成都依赖计时器，这些计时器可以保证拓扑进入无环状态才转发数据，链路故障时完成收敛，同时也是其收敛时间过长的原因。不同厂家在此都有一些优化策略。</p><table><thead><tr><th align="left">计时器</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">message age</td><td align="left">每经过交换机relay一次加1秒，类似IP报文中的TTL，大于MAX_age后不处理，防止网络半径太大</td></tr><tr><td align="left">max age</td><td align="left">消息老化时间，默认20秒</td></tr><tr><td align="left">hello time</td><td align="left">发送两个消息之间的间隔，默认2秒</td></tr><tr><td align="left">forward delag</td><td align="left">控制listening和learning之间的状态切换延时，默认15秒</td></tr></tbody></table><h2 id="BPDU"><a href="#BPDU" class="headerlink" title="BPDU"></a>BPDU</h2><p>BPDU是STP协议的核心，BPDU承载上述的某些参数，完成根桥的选举，端口的选举。BPDU报文字段如下：</p><table><thead><tr><th align="left">protocol identical</th><th align="left">protocol version</th><th align="left">BPDU type</th><th align="left">flags</th><th align="left">root identifier</th><th align="left">root path cost</th><th align="left">bridge identifier</th><th align="left">port identifier</th><th align="left">message age</th><th align="left">max age</th><th align="left">hello time</th><th align="left">forward delay</th></tr></thead><tbody><tr><td align="left">ID为0</td><td align="left">stp为0，rstp为2，mstp为3</td><td align="left">0x00:配置BPDU,0x80:TCN BPDU，0x02：RST BPDU或MST BPDU</td><td align="left">最高位为1表示TCA，最低位为1表示TC</td><td align="left">根桥ID</td><td align="left">发送桥到根桥的开销</td><td align="left">sender BID</td><td align="left">sender PID</td><td align="left">同上</td><td align="left">同上</td><td align="left">同上</td><td align="left">同上</td></tr></tbody></table><p><code>root past cost</code>与带宽相关，一般ethernet(10M)的cost是100, 数值越小优先级越高。<br><code>port ID</code>由<code>优先级.端口号</code>组成，优先级默认为128, 如Eth0的port ID为<code>128.1</code><br>这些参数可以在<code>show spanning</code>命令下看到。</p><p>根桥的选举，端口角色的选举，本质就是不同设备BPDU的对比，不同端口收到的BPDU的选举。这里介绍一个概念<code>superior BPDU</code>. superior BPDU满足如下条件：</p><ol><li>BID最优</li><li>如果条件1一致，root past cost最优的为superior BPDU</li><li>如果条件1,2一致，sender BID最优的为superior BPDU</li><li>如果1,2,3一致，sender PID最优的为superior BPDU</li><li>如果1,2,3,4一致，receiver PID最优的为superior BPDU<br>STP中涉及到参数比较的都是数值越小优先级越高，BID和PID类似，都是先比较优先级，如果优先级一致，再比较mac地址或端口号。与之相对不满足上述条件的则成为<code>inferior BPDU</code>。</li></ol><p>此外需要知道一个细节，端口会存储最近收到的superior BPDU(加上该端口的cost)，并对他进行老化，老化时间为max_age-message_age。典型场景是AP收不到superior BPDU, 20秒后老化变成DP，这样可以保证超时信息从拓扑中移除。只有RP和AP上会存储superior BPDU, DP只负责转发。</p><h1 id="STP的选举流程"><a href="#STP的选举流程" class="headerlink" title="STP的选举流程"></a>STP的选举流程</h1><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/stp_election.png?raw=true"></p><ol><li><p>根桥的选举<br>刚开始时，所有的交换机认为自己是根桥，所有端口都是DP(listening)，将<code>root id</code>和<code>bridge id</code>字段都填充自己的BID向外发送(组播)，经过一段时间收敛后，BID最优的被选成根桥。本质就是不同交换机之间BPDU的比较，根桥的BPDU为superior BPDU.根桥选定之后，只有根桥向外发送配置BPDU，其它交换机只负责接收和转发，端口都是DP(listening).<br>如图所示，S1的BID优先级最小，选举成为根桥。</p></li><li><p>根端口的选举<br>在成环的拓扑中，非根桥会从多个端口收到根桥发来的BPDU，从这些BPDU中选出superior BPDU作为根端口。<br>如图所示，以S3为例，会从eth0,eth2,eth3三个端口收到根桥发来的BPDU，eth3收到的是S2中继的BPDU，cost值大，而eth0和eth2收到的BPDU的cost为0, 所以在eth0和eth2之间选。sender BID都是S1，看PID，S3上eth0收到的是S1上eth1发出，PID小(优先级一样，看端口号), 所以S3上eth0是RP。换言之，S3的3个端口收到的BPDU中，eth0收到的是superior BPDU。</p></li><li><p>指定端口的选举<br>根桥上的所有端口都是DP，对于非根桥设备，除RP外，将端口收到的BPDU与发出的BPDU对比，superior BPDU的作为DP，inferior BPDU则作为AP.<br>任一链路中肯定有一个DP，如图所示，以S2为例，eth0是RP，剩下eth2进行DP选举，eth2中继eth0收到的BPDU给S3的eth3(发出的BPDU)，S3的eth3中继eth0收到的BPDU给S2的eth2(收到的BPDU)，cost一致，比较sender BID，两者优先级一致，但S2的MAC更小，所以S2的eth2是DP, 同理，S3的eth3是AP。换言之，S2的eth2发出的BPDU相较于收到的BPDU是superior BPDU。</p></li></ol><p>选举完成之后，DP和RP经过listening和learning的时延后进入forwarding状态，AP则处于blocking状态，破除拓扑的环路。根桥周期向外发送配置BPDU，非根桥从RP接收superior BPDU，加上RP的cost，将<code>bridge ID</code>字段改成自己的，从DP向外中继该BPDU(源MAC改成DP的MAC). </p><h1 id="STP收敛场景描述"><a href="#STP收敛场景描述" class="headerlink" title="STP收敛场景描述"></a>STP收敛场景描述</h1><p>只有当RP挂点后才有收敛的意义(链路必定有一端是RP)。交换机通过两种方式可以感知到线路故障。</p><h2 id="直接感知"><a href="#直接感知" class="headerlink" title="直接感知"></a>直接感知</h2><p>链路物理上是直连的。这种场景下又可以分两种情况。</p><h3 id="交换机上没有存储BPDU的端口"><a href="#交换机上没有存储BPDU的端口" class="headerlink" title="交换机上没有存储BPDU的端口"></a>交换机上没有存储BPDU的端口</h3><p>当交换机感知到端口down掉后，会立马清除该端口上存储的BPDU, 如果没有其它存储BPDU的端口，那么该交换机就会宣告自己是新的根桥，并将自己的配置BPDU向外发送，由于真实根桥依然存在，其它交换机收到的是inferior BPDU, 不会对其做任何处理，直至收到inferior BPDU的端口超时。</p><p>如STP选举流程中的图示，当S2的eth0端口down掉之后，S2认为自己是根桥，通过eth2给S3的eth3发送inferior BPDU(TC置位)，S3的eth3一直收不到superior BPDU，最终会超时(20秒)，之后变成DP(经过listening，learning的30秒时延后变成forwarding状态，通过RP发送TCN)，并立即向S2中继superior BPDU，S2收到之后知道根桥的存在，停止发送BPDU，并将eth2选举成RP(原则上应该经历listening，learning再转成forwarding，思科上直接变成forwarding，应该是做了优化)，RP变成forwarding状态后发送TCN报文，所以收敛的总耗时接近50秒(超时没有算message_age).</p><h3 id="交换机上有存储BPDU的端口"><a href="#交换机上有存储BPDU的端口" class="headerlink" title="交换机上有存储BPDU的端口"></a>交换机上有存储BPDU的端口</h3><p>同上，如果交换机上有其它存储BPDU的端口，那么会在这些端口中选出superior BPDU的端口作为新的RP。</p><p>如STP选举流程中的图示，当S3的eth0端口down掉之后，S3会在eth2和eth3之间选举出新的RP，很明显eth2上市superior BPDU，eth2成为RP，经过listening和learning之后变成forwarding，并发送TCN报文。收敛时间是30秒。</p><h2 id="间接感知"><a href="#间接感知" class="headerlink" title="间接感知"></a>间接感知</h2><p>链路物理上是非直连的，比如中间链路中间有个hub。这种情况下只能等待BPDU报文超时触发。之后的处理流程和<code>直接感知</code>一致，需要加上额外的20秒BPDU报文超时时间。</p><h1 id="STP拓扑变化带来的问题"><a href="#STP拓扑变化带来的问题" class="headerlink" title="STP拓扑变化带来的问题"></a>STP拓扑变化带来的问题</h1><p>L2依据Mac地址表进行转发，拓扑变换可能导致Mac地址表失效. 当stp收敛之后，虽然会重新学习到正确的mac地址，但是会耗费相当多的时间，特别是当某条mac地址不存在或超时时间恰好是最大值(默认300秒). 为此，当拓扑变化时，通过TCN BPDU通知根桥，根桥通过TCN ACK BPDU通知所有交换机，收到此报文的交换机将mac地址表超时改成forward_time，发送TCN BPDU的交换机收到ACK后会停止发送TCN.</p><p>缩短mac地址的老化时间会使拓扑不稳定，会存在泛洪流量，当大量拓扑发生改变时，这种情况是很危险的。RSTP中也有这个问题。</p><h1 id="STP收敛的几个优化配置"><a href="#STP收敛的几个优化配置" class="headerlink" title="STP收敛的几个优化配置"></a>STP收敛的几个优化配置</h1><p>思科设备上提供了几种优化配置来减少收敛时间, 降低不必要的mac地址表刷新。</p><p><img src="https://github.com/Rancho333/pictures_hub/blob/master/non_auto/stp_convergence.png?raw=true"></p><p><code>portfast</code>在edge port上开启，当端口状态发生变化时，不会发送TCN BPDU，避免刷新MAC地址表，端口可以直接从block状态变成forwarding状态，不需要等待30秒。开启命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config-if)#spanning-tree portfast edge &#x2F;&#x2F; 在eth2上开启portfast</span><br></pre></td></tr></table></figure><p>如上图，在eth2上开启portfast后，eth2会直接变成forwarding状态，并且不会发送TCN报文。</p><p><code>uplinkfast</code>当RP失效后，AP跳过listening和learning的30秒，直接变成RP的forwarding状态, 开启命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#spanning-tree uplinkfast&#x2F;&#x2F; 全局开启uplinkfast</span><br></pre></td></tr></table></figure><p>如上图，shutdown S3上的RP eth0, eth1会从AP直接变成RP的forwarding状态。<br>注意，配置uplinkfast后，交换机优先级会调整32768+4096(不会选成根桥)，端口cost会增加3000(不会选成DP)</p><p><code>backbonefast</code>AP端口收到inferior BPDU后ignore，直到max_age超时后变成DP，耗时20秒，开启backbonefast后，不用等到超时，AP直接变成DP，开启命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)#spanning-tree backbonefast&#x2F;&#x2F; 需要在所有交换机上开启才生效,原理上应该只需要在收到inferior BPDU的switch上开启就行，模拟器bug?</span><br></pre></td></tr></table></figure><p>如上图，S2的eth0 down掉后，认为自己是根桥向S3发送inferior BPDU，正常情况下S3忽略，直到eth1超时变成DP(20秒), 然后S3向S2转发superior BPDU，eth1再经过listening和learning的30秒时延后进入forwarding状态，完成收敛。开启backbonefast后，eth1不用等待20秒超时，直接变成DP，然后再经过30秒状态变化后进入forwarding，收敛时间由50秒变成30秒。<br>很多文档中有direct和indirect的区分，其实没啥必要，命令行中也没体现，直接分析错误场景，分析BPDU的比较即可。</p><h1 id="几种安全机制"><a href="#几种安全机制" class="headerlink" title="几种安全机制"></a>几种安全机制</h1><p><code>BPDU gard/filter</code>如果端口使能BPDU gard，当端口收到BPDU时将端口down掉(error disable)。应该在所有的access端口使能，即只有交换机互联的端口跑STP。可以避免交换机attacks(攻击者伪装成根交换机监听流量)和incident(非 STP/RSTP 感知交换机插入网络导致环路)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Switch(config-if)#spanning-tree bpduguard enable&#x2F;&#x2F; 端口下开启bpduguard，收到bpdu将端口errordisable</span><br><span class="line">Switch(config-if)#spanning-tree bpdufilter enable&#x2F;&#x2F; 不shutdown端口，只是ignore收到的bpdu，其它流量正常转发，在AP上开启，BPDU超时后会变成DP，形成环路</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/STP/">STP</category>
      
      
      <comments>https://rancho333.github.io/2022/07/07/STP802-1d%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vrf简述及仿真实验</title>
      <link>https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</link>
      <guid>https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</guid>
      <pubDate>Wed, 20 Oct 2021 05:14:53 GMT</pubDate>
      
      <description>&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFvrf&quot;&gt;什么是VRF&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E7%9A%84%E4%BD%9C%E7%94%A8&quot;&gt;vrf的作用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C&quot;&gt;VRF仿真实验&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E8%A7%A3%E5%86%B3%E5%9C%B0%E5%9D%80%E9%87%8D%E5%8F%A0--ip%E9%9A%94%E7%A6%BB&quot;&gt;VRF解决地址重叠 &amp;amp;&amp;amp; IP隔离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E8%B7%AF%E7%94%B1%E9%9A%94%E7%A6%BB%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2&quot;&gt;VRF路由隔离以及路由泄露&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2%E5%AE%9E%E9%AA%8C%E5%A4%B1%E8%B4%A5&quot;&gt;vrf路由泄露实验失败&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;</description>
      
      
      
      <content:encoded><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFvrf">什么是VRF</a><ul><li><a href="#vrf%E7%9A%84%E4%BD%9C%E7%94%A8">vrf的作用</a></li></ul></li><li><a href="#vrf%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C">VRF仿真实验</a><ul><li><a href="#vrf%E8%A7%A3%E5%86%B3%E5%9C%B0%E5%9D%80%E9%87%8D%E5%8F%A0--ip%E9%9A%94%E7%A6%BB">VRF解决地址重叠 &amp;&amp; IP隔离</a></li><li><a href="#vrf%E8%B7%AF%E7%94%B1%E9%9A%94%E7%A6%BB%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2">VRF路由隔离以及路由泄露</a><ul><li><a href="#vrf%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2%E5%AE%9E%E9%AA%8C%E5%A4%B1%E8%B4%A5">vrf路由泄露实验失败</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="什么是VRF"><a href="#什么是VRF" class="headerlink" title="什么是VRF"></a>什么是VRF</h1><p>VRF(virtual routing and forwarding)是一种允许在单台路由器上有多个路由表的技术。VRFs的典型使用是与MPLS VPNs结合。没有使用MPLS的VRFs称为VRF lite.</p><p>在Linux上，VRF设备通过与ip规则结合在Linux网络栈中提供创建虚拟路由和转发的能力。一个典型的应用场景就是多租户各自需要独立的路由表，少数场景下需要不同的默认路由。</p><p>程序通过socket与不同的VRF设备绑定感知VRF。数据包通过socket使用与VRF设备相关的路由表。VRF设备实现的一个重要特征就是它只影响L3而对L2工具（比如LLDP）没有影响(它们是全局的而不必运行在每一个VRF域中).这种设计允许使用更高优先级的ip rules(policy based routing, PBR)优先于VRF设备规则，根据需要引导特定流量。此外，VRF设备允许VRFs嵌套在namespace中。namespace提供物理层的接口隔离，vlan提供L2的隔离，vrf提供L3的隔离。VRF设备是使用关联的路由表创建的。</p><p>简而言之，VRF在逻辑上将一个路由器模拟成多台路由器，是一种网络虚拟化技术,VRF是路由器的虚拟化，VLAN是交换机的虚拟化，trunk是对网络连接的虚拟化。VDOM(virtual domain)是防火墙的虚拟化, VM是服务器的虚拟化。</p><p>注意：一个L3接口同一时间只能属于一个VRF域</p><h2 id="vrf的作用"><a href="#vrf的作用" class="headerlink" title="vrf的作用"></a>vrf的作用</h2><p>两点：<br>    1. 流量隔离：隔离不同的vpn用户,解决地址重叠问题<br>    2. 网络虚拟化</p><h1 id="VRF仿真实验"><a href="#VRF仿真实验" class="headerlink" title="VRF仿真实验"></a>VRF仿真实验</h1><p>针对vrf的路由隔离和解决地址重叠这两个特性，在GNS3上面做两个简单的仿真实验。</p><h2 id="VRF解决地址重叠-amp-amp-IP隔离"><a href="#VRF解决地址重叠-amp-amp-IP隔离" class="headerlink" title="VRF解决地址重叠 &amp;&amp; IP隔离"></a>VRF解决地址重叠 &amp;&amp; IP隔离</h2><p>实验拓扑如下：<br><img src="https://rancho333.github.io/pictures/vrf_overlap_topo.png"><br>其中，R1、R2、R4、R5模拟主机，R3上面创建两个<code>vrf</code>域, R1、R2属于<code>vrf-2</code>, R4、R5属于<code>vrf-1</code>。实验预期是R1可以ping通R2，R4可以ping通R5。<br>5台设备的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">R1&#x2F;R3:</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> no shutdown</span><br><span class="line"> ip address 192.168.1.2 255.255.255.0</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.1.1                # 模拟主机，配置网关</span><br><span class="line"></span><br><span class="line">R2&#x2F;R4:</span><br><span class="line">interface Ethernet0&#x2F;3</span><br><span class="line"> no shutdown</span><br><span class="line"> ip address 202.100.10.2 255.255.255.0</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 202.100.10.1</span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">ip vrf vrf-1                                        # 创建vrf-1</span><br><span class="line">!   </span><br><span class="line">ip vrf vrf-2                                        # 创建vrf-2</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-1                            # 接口加入vrf-1</span><br><span class="line"> ip address 192.168.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-2                            # 接口加入vrf-2</span><br><span class="line"> ip address 192.168.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;2</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-1                            # 接口加入vrf-1</span><br><span class="line"> ip address 202.100.10.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;3</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-2                            # 接口加入vrf-2</span><br><span class="line"> ip address 202.100.10.1 255.255.255.0</span><br></pre></td></tr></table></figure><p>查看R3的路由表：<br><img src="https://rancho333.github.io/pictures/vrf_overlap_route.png"><br>路由表结果与预期相符，默认路由表中没有内容，vrf-1和vrf-2中分别是各自接口的直连路由。</p><p>同时在R2和R5上抓包，在R1和R3上ping 202.100.10.2，发现只有在相同的vrf域中才能收到icmp(即R1可以ping通R2，R4可以ping通R5)，实验结果符合预期。</p><h2 id="VRF路由隔离以及路由泄露"><a href="#VRF路由隔离以及路由泄露" class="headerlink" title="VRF路由隔离以及路由泄露"></a>VRF路由隔离以及路由泄露</h2><p>VRF可以隔离不同VPN用户之间的路由，即可以实现L3层级的隔离，同时通过vrf-leak可以实现不同vrf之间的互通。路由隔离与泄露使用相同的拓扑：<br><img src="https://rancho333.github.io/pictures/vrf_separation_topo.png"><br>配置参照<code>VRF解决地址重叠</code>的实验，根据拓扑修改对应端口，以及模拟主机的4台路由器上修改默认网关即可。</p><p>查看R3上的路由表，默认路由表依然为空，这里就不看了：<br><img src="https://rancho333.github.io/pictures/vrf_separation_route.png"><br>VRF分别包含各自网段的路由。</p><p>在R2上分别ping R1和R4，结果如下：<br><img src="https://rancho333.github.io/pictures/r2_ping_separation.png"><br>R2可以ping通同一路由域中的R1，不能ping通其它路由域中的R4，实验结果符合预期。</p><h3 id="vrf路由泄露实验失败-后面有机会再搞吧-大概率是配置错了"><a href="#vrf路由泄露实验失败-后面有机会再搞吧-大概率是配置错了" class="headerlink" title="vrf路由泄露实验失败, 后面有机会再搞吧(大概率是配置错了)"></a>vrf路由泄露实验失败, 后面有机会再搞吧(大概率是配置错了)</h3><p>vrf的路由泄露有三种方向，分别为：</p><ul><li>默认vrf——&gt;vrf</li><li>vrf——&gt;vrf</li><li>vrf——&gt;默认vrf<br>默认vrf即为全局路由表。</li></ul><p>vrf-leak可以通过static和dynamic两种方式实现，在此进行static实验。修改配置进行vrf-leak实验，在R3上添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># SONiC test case of VRF</span><br><span class="line"></span><br><span class="line">基本问题描述：test case场景下，单个VRF中存在12.8K(6.4K的IPv4和6.4K的IPv6)路由条目，删除VRF时，一定时间内需要删除大量路由。里面有两个问题：</span><br><span class="line">  1. zebra的fpm client不能将所有数据同步给fpm server</span><br><span class="line">  2. 删除VRF中默认路由时出错</span><br><span class="line"></span><br><span class="line">## 创建VRF时需要关注的几个对象</span><br><span class="line">![](https:&#x2F;&#x2F;rancho333.github.io&#x2F;pictures&#x2F;vrf_about_obiects.png)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">  1. 一个VRF中包含一个或多个L3 接口，创建接口会增加该VRF的reference count</span><br><span class="line">  2. 一个L3 接口上包含一个或多个IP，创建IP会增加该接口的reference count</span><br><span class="line">  3. 一个IP对应一个邻居，增加neighbour会增加该IP的reference count</span><br><span class="line">  4. 有了neighbour之后，路由协议会创建路由条目(route entry)，增加route entry会增加对VRF的reference count</span><br><span class="line">  5. route entry中的一个重要参数是next hop(可能会有多个next hop)，增加next hop会增加对route entry的reference count</span><br><span class="line"></span><br><span class="line">当一个对象的reference count不为0时，是不能将其删除的，必须彻底的解决其依赖关系。</span><br><span class="line"></span><br><span class="line">## SONiC数据同步机制的缺陷，以删除VRF为例</span><br><span class="line">![](https:&#x2F;&#x2F;rancho333.github.io&#x2F;pictures&#x2F;vrf_del_vrf.png)</span><br><span class="line">vrfmgrd会陷入loop等待vrforch删除数据库中stateobjectvrf条目，如果vrforch执行失败，vrfmgrd会陷入死循环。</span><br><span class="line"></span><br><span class="line">## zebra到fpmsyncd(bgp)同步路由的过程以及之前版本的缺陷(以删除ip为例)</span><br><span class="line">![](https:&#x2F;&#x2F;rancho333.github.io&#x2F;pictures&#x2F;vrf_del_ip.png)</span><br><span class="line"></span><br><span class="line">基本流程：</span><br><span class="line">1. SONiC通过Linux shell删除L3的IP</span><br><span class="line">2. zebra通过netlink同步信息并通知给个路由进程</span><br><span class="line">3. 路由进程决策路由信息通知给zebra</span><br><span class="line">4. zebra决策路由信息，通过netlink同步给kernel，通过fpm同步给sonic端的fpmsyncd</span><br><span class="line">5. zebra端fpm client写机制有缺陷(write buffer较小，有写次数的限制)，导致数据丢失</span><br><span class="line">6. 修改方式，在步骤1中删除IP后添加时延，减少zebra单位时间内处理的路由信息，给frr添加如下patch，解决fpm client写缺陷</span><br></pre></td></tr></table></figure><p> zebra/zebra_fpm.c |    4 ++–<br> 1 file changed, 2 insertions(+), 2 deletions(-)</p><p>diff –git a/zebra/zebra_fpm.c b/zebra/zebra_fpm.c<br>index 7b0611bf9..4efa8c896 100644<br>— a/zebra/zebra_fpm.c<br>+++ b/zebra/zebra_fpm.c<br>@@ -62,7 +62,7 @@ DEFINE_MTYPE_STATIC(ZEBRA, FPM_MAC_INFO, “FPM_MAC_INFO”);</p><ul><li>The maximum number of times the FPM socket write callback can call</li><li>‘write’ before it yields.</li><li>/</li></ul><p>-#define ZFPM_MAX_WRITES_PER_RUN 10<br>+#define ZFPM_MAX_WRITES_PER_RUN 100</p><p> /*</p><ul><li>Interval over which we collect statistics.<br>@@ -929,7 +929,7 @@ enum {<br>FPM_GOTO_NEXT_Q = 1<br>};</li></ul><p>-#define FPM_QUEUE_PROCESS_LIMIT 10000<br>+#define FPM_QUEUE_PROCESS_LIMIT 50000</p><p>```<br>注意SONiC中frr的编译机制，sonic-frr目录下的Makefile会checkout到指定分支，所以直接修改的代码内容会被覆盖。</p><h2 id="关于删除VRF中默认路由出错"><a href="#关于删除VRF中默认路由出错" class="headerlink" title="关于删除VRF中默认路由出错"></a>关于删除VRF中默认路由出错</h2><p>alpm模式下，broadcom TH4芯片在创建VRF时会创建一条默认路由(只存在于ASIC中，上层协议不可见)<br>当VRF只存在默认路由时，删除VRF会自动删除默认路由，如果此时显示删除默认路由，可以成功；<br>当VRF中存在默认路由以及其它路由时，不能显示删除默路由</p><p>原有，SONiC上层逻辑SWSS中，当删除default VRF中的默认路由时，将其设置为blackhole路由，当删除VRF中的默认路由时，下发删除指令，由于VRF中还有其它路由信息，SDK报错</p><p>修改为：当SONiC下发删除VRF中默认路由指令时，在SAI中将其实际行为修改为：将该默认路由配置成黑洞路由<br>      如果修改SONiC中的删除指令为配置成黑洞路由，那么在该VRF中，依然存在一个route entry，那么该VRF就存在reference count，那么该VRF就无法删除</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://datatracker.ietf.org/doc/html/rfc2685">rfc2685</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc4364">rfc4364</a></p><p><a href="https://github.com/Azure/SONiC/blob/master/doc/vrf/sonic-vrf-hld.md">SONiC VRF support design spec draft</a></p><p><a href="https://www.cisco.com/c/en/us/td/docs/net_mgmt/prime/network/3-8/reference/guide/vrf.html">VPN and VRF of cisco</a></p><p><a href="https://www.cisco.com/c/en/us/td/docs/switches/lan/catalyst4500/12-2/15-02SG/configuration/guide/config/vrf.html#85589">Config vrf of cisco</a></p><p><a href="https://www.kernel.org/doc/html/latest/networking/vrf.html">Vrf of linux kernel</a></p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/vrf/">vrf</category>
      
      
      <comments>https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC自动化编译简述</title>
      <link>https://rancho333.github.io/2021/10/08/SONiC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2021/10/08/SONiC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Fri, 08 Oct 2021 02:58:42 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;关于SONiC自动化编译&quot;&gt;&lt;a href=&quot;#关于SONiC自动化编译&quot; class=&quot;headerlink&quot; title=&quot;关于SONiC自动化编译&quot;&gt;&lt;/a&gt;关于SONiC自动化编译&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当gitlab仓库有push动作时触发自动编译，仓库地址为：&lt;a href=&quot;http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git&quot;&gt;http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="关于SONiC自动化编译"><a href="#关于SONiC自动化编译" class="headerlink" title="关于SONiC自动化编译"></a>关于SONiC自动化编译</h1><ul><li><p>当gitlab仓库有push动作时触发自动编译，仓库地址为：<a href="http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git">http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git</a></p><span id="more"></span></li><li><p>编译环境部署在泰国服务器，设备ip为：10.196.48.47</p></li><li><p>考虑网络问题以及SONiC编译偶尔会抽疯，编译失败后再次执行，5次失败后退出编译</p></li><li><p>镜像版本号为“SONiC.202012-brixia-时间-版本”，如“SONiC.202012-brixia-20210930-r4”，其中时间为当天编译时间，r后面的数字依次递增，r5,r6……</p></li><li><p>编译好的版本，命名规则为”sonic-broadcom-时间-版本.bin”，会自动推送到文件服务器：<a href="http://10.204.112.155:8081/sonic/brixia/">http://10.204.112.155:8081/sonic/brixia/</a></p></li><li><p>jenkins环境部署在：10.204.112.155:8080, 后续稳定后考虑迁移到testbed的环境，当前上面只有一个账号(rancho/123456)，有兴趣的同学请自行参观使用</p></li><li><p>针对不需要gitlab+jenkins的场景，提供shell脚本实现自动化编译，在自己家目录下执行 bash ~/auto_build.sh即可</p></li></ul><h1 id="自动化编译一些小问题"><a href="#自动化编译一些小问题" class="headerlink" title="自动化编译一些小问题"></a>自动化编译一些小问题</h1><ul><li><p>自动化编译每次均为全量编译，时间较长，加上从泰国服务器拷贝image，时间较长，如果是特性或编译临时版本，并不建议使用，推荐增量编译或模块化编译。</p></li><li><p>自动化编译只会编译基础SONiC镜像，debug版本或加特性(如syncd-rpc)不会在自动化编译中(主要考虑编译时间、传输时间、存储空间以及使用率)</p></li><li><p>自动化编译单次只会编译一个target，对于无依赖关系target不能并行处理，并行处理大概率会报错，需要手动纠错</p></li><li><p>jenkins在远程主机上执行shell命令使用的是SSH，该shell是非交互式非登录式shell，需要注意shell配置文件的加载以及环境变量的配置</p></li><li><p>在host上清除已经编译过的环境需要root权限(fsroot文件夹)，使用脚本中的b.out可以完成该操作<br>  修改Makefile, 在target中加入sonic-slave-run, 使用 <code>make sonic-slave-run SONIC_RUN_CMDS=&quot;rm -rf fsroot&quot;</code>删除不能删除的部分</p></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      <category domain="https://rancho333.github.io/tags/jenkins/">jenkins</category>
      
      
      <comments>https://rancho333.github.io/2021/10/08/SONiC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
