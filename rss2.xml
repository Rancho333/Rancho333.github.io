<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rancho Blog</title>
    <link>https://rancho333.github.io/</link>
    
    <atom:link href="https://rancho333.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>No pain, no gain!</description>
    <pubDate>Thu, 13 Oct 2022 09:22:22 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>vrf lite route leaking</title>
      <link>https://rancho333.github.io/2022/10/13/vrf-lite-route-leaking/</link>
      <guid>https://rancho333.github.io/2022/10/13/vrf-lite-route-leaking/</guid>
      <pubDate>Thu, 13 Oct 2022 08:07:22 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;之前在&lt;a href=&quot;https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/&quot;&gt;vrf简述及仿真实验&lt;/a&gt;对vrf有了一个基本的了解，但是vrf lite route leaking实验失败了。现在补做回来。&lt;/p&gt;
&lt;p&gt;vrf之间的路由泄漏有静态配置和MP-BGP两种方式，本文只做静态配置的实验。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>之前在<a href="https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/">vrf简述及仿真实验</a>对vrf有了一个基本的了解，但是vrf lite route leaking实验失败了。现在补做回来。</p><p>vrf之间的路由泄漏有静态配置和MP-BGP两种方式，本文只做静态配置的实验。</p><span id="more"></span><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>之前的实验时是由于配置出的问题，参考cisco的<a href="https://www.cisco.com/c/en/us/support/docs/multiprotocol-label-switching-mpls/multiprotocol-label-switching-vpns-mpls-vpns/47807-routeleaking.html#diffvrfs">Route Leaking in MPLS/VPN Networks</a>, 两个vrf之间不能直接泄露路由，必须从global中转一下才行。</p><p>实验拓扑如下图所示：<br><img src="https://rancho333.github.io/pictures/vrf_leaking_topology.png"></p><p>vpc2属于vrf 2, vpc3属于vrf 3, vpc4属于global. 通过配置使三者之间可以相互通信。<br>对于vrf -&gt; global，在vrf中写到达global中prefix路由，在global中写到达vrf中prefix的路由。<br>对于vrf -&gt; vrf，在vrf中写到达另一个vrf中prefix的路由(下一跳在global中)，在global中写到达该prefix的路由，对于另一个vrf，做相同的操作。</p><p>下面开始配置。基本的ip网段配置规则按设备名称来，这里不贴出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">R1(config)#ip vrf 2             &#x2F;&#x2F; 创建vrf2</span><br><span class="line">R1(config)#ip vrf 3             &#x2F;&#x2F; 创建vrf3</span><br><span class="line"></span><br><span class="line">R1(config-if)#interface ethernet 0&#x2F;0</span><br><span class="line">R1(config-if)#ip vrf forwarding 2                   &#x2F;&#x2F; 将eth0将入vrf 2</span><br><span class="line">R1(config-if)#ip address 12.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">R1(config-if)#interface ethernet 0&#x2F;1</span><br><span class="line">R1(config-if)#ip vrf forwarding 3                   &#x2F;&#x2F; 将eth1将入vrf 3</span><br><span class="line">R1(config-if)#ip address 13.1.1.1 255.255.255.0</span><br></pre></td></tr></table></figure><p>测试下基本的联通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vpc4&gt; ping 14.1.1.1 -c 1                &#x2F;&#x2F; 可以ping通自己的网关</span><br><span class="line"></span><br><span class="line">84 bytes from 14.1.1.1 icmp_seq&#x3D;1 ttl&#x3D;255 time&#x3D;0.335 ms</span><br><span class="line"></span><br><span class="line">vpc4&gt; ping 12.1.1.2 -c 1                &#x2F;&#x2F; 不能和vrf 2通信</span><br><span class="line"></span><br><span class="line">*14.1.1.1 icmp_seq&#x3D;1 ttl&#x3D;255 time&#x3D;0.497 ms (ICMP type:3, code:1, Destination host unreachable)</span><br><span class="line"></span><br><span class="line">vpc4&gt; ping 13.1.1.3 -c 1                &#x2F;&#x2F; 不能和vrf 3通信</span><br><span class="line"></span><br><span class="line">*14.1.1.1 icmp_seq&#x3D;1 ttl&#x3D;255 time&#x3D;0.492 ms (ICMP type:3, code:1, Destination host unreachable)</span><br></pre></td></tr></table></figure><p>符合预期。</p><p>对于vrf 2与global之间的通信：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R1(config)#ip route vrf 2 14.1.1.0 255.255.255.0 14.1.1.4 global            &#x2F;&#x2F; 在vrf 2中添加global中prefix的路由，global关键词表明：如果在vrf 2中收到prefix是14.1.1.0&#x2F;24的报文时，到global路由表中找路由出去，由于14.1.1.0&#x2F;24是global中的直连网段，所以报文可以转发</span><br><span class="line">R1(config)#ip route 12.1.1.0 255.255.255.0 ethernet 0&#x2F;0             &#x2F;&#x2F; global中添加到vrf 2中prefix的路由，注意下一跳需要指定是物理接口，如果指定ip的话，不能正常路由</span><br><span class="line"></span><br><span class="line">vpc4&gt; ping 12.1.1.2 -c 1                &#x2F;&#x2F; vrf 2与global之间三层可达</span><br><span class="line"></span><br><span class="line">84 bytes from 12.1.1.2 icmp_seq&#x3D;1 ttl&#x3D;63 time&#x3D;1.219 ms</span><br></pre></td></tr></table></figure><p>vrf 3与global之间的通信类似配置。<br>对于vrf 2与vrf 3之间的通信：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R1(config)#ip route vrf 2 13.1.1.0 255.255.255.0 13.1.1.3 global            &#x2F;&#x2F; 在vrf 2中添加vrf 3中prefix的路由，下一跳去global中找</span><br><span class="line">R1(config)#ip route 13.1.1.0 255.255.255.0 ethernet 0&#x2F;1                     &#x2F;&#x2F; global中没有到vrf 3的路由，所以需要在global中添加到vrf 3中prefix的路由</span><br><span class="line"></span><br><span class="line">R1(config)#ip route vrf 3 12.1.1.0 255.255.255.0 12.1.1.2 global            &#x2F;&#x2F; 同理在vrf 3中添加到vrf 2中prefix的路由</span><br><span class="line">R1(config)#ip route 12.1.1.0 255.255.255.0 ethernet 0&#x2F;0        </span><br><span class="line"></span><br><span class="line">vpc2&gt; ping 13.1.1.3 -c 1                    &#x2F;&#x2F; vrf 2与vrf 3之间三层可达</span><br><span class="line"></span><br><span class="line">84 bytes from 13.1.1.3 icmp_seq&#x3D;1 ttl&#x3D;63 time&#x3D;3.980 ms</span><br></pre></td></tr></table></figure><p>由于global中已经有了到vrf 2和vrf 3的路由，所以对于vrf 3访问global，只需要添加一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R1(config)#ip route vrf 3 14.1.1.0 255.255.255.0 14.1.1.4 global</span><br><span class="line"></span><br><span class="line">vpc4&gt; ping 13.1.1.3 -c 1                &#x2F;&#x2F; vrf 3与global之间三层可达</span><br><span class="line"></span><br><span class="line">84 bytes from 13.1.1.3 icmp_seq&#x3D;1 ttl&#x3D;63 time&#x3D;2.165 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里面的一个基本思路是：如果一个vrf想要访问其它vrf的网段(无论是不是default vrf)</p><ol><li>下一跳都要指定到global中去找，global中如果没有对应的路由，就要在global中补上</li><li>同时global中一定要有返回该vrf的路由</li><li>网络是双向的，来回都需要有路由。</li></ol><p>分下一下路由表，这是最本质的东西了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">对于vrf 2的路由表:</span><br><span class="line">R1#show ip route vrf 2 static         </span><br><span class="line">      13.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">S        13.1.1.0 [1&#x2F;0] via 13.1.1.3                    &#x2F;&#x2F; 去往vrf 3的路由，到global中找下一跳13.1.1.3  (路由表中好像并没有什么地方体现出到global去找)</span><br><span class="line">      14.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">S        14.1.1.0 [1&#x2F;0] via 14.1.1.4                    &#x2F;&#x2F; 去往global的路由</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于global路由表</span><br><span class="line">R1#show ip route static </span><br><span class="line">      12.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">S        12.1.1.0 is directly connected, Ethernet0&#x2F;0</span><br><span class="line">      13.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">S        13.1.1.0 is directly connected, Ethernet0&#x2F;1    &#x2F;&#x2F; 指明13.1.1.0网段的出口</span><br><span class="line"></span><br><span class="line">R1#show ip route vrf 3 static </span><br><span class="line">      12.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">S        12.1.1.0 [1&#x2F;0] via 12.1.1.2                    &#x2F;&#x2F; 12.1.1.0的回程路由</span><br><span class="line">      14.0.0.0&#x2F;24 is subnetted, 1 subnets</span><br><span class="line">S        14.1.1.0 [1&#x2F;0] via 14.1.1.4                    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一张图来收尾吧：<br><img src="https://rancho333.github.io/pictures/vrf_leaking_route.png"></p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/vrf/">vrf</category>
      
      
      <comments>https://rancho333.github.io/2022/10/13/vrf-lite-route-leaking/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PVLAN浅析</title>
      <link>https://rancho333.github.io/2022/10/12/PVLAN%E6%B5%85%E6%9E%90/</link>
      <guid>https://rancho333.github.io/2022/10/12/PVLAN%E6%B5%85%E6%9E%90/</guid>
      <pubDate>Wed, 12 Oct 2022 02:34:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;Vlan里面有两个常见的概念：透传与终结。所谓vlan透传就是某个vlan不仅在一台交换机上有效，它还要通过某种方法延伸到别的以太网交换机上，在别的设备上照样有效，vlan透传可以通过802.1Q技术实现。&lt;br&gt;终结的意思相对，某个vlan的有效域不能再延伸到别的设备，或者不能通过某条链路延伸到别的设备。vlan的终结可以使用PVLAN技术。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Vlan里面有两个常见的概念：透传与终结。所谓vlan透传就是某个vlan不仅在一台交换机上有效，它还要通过某种方法延伸到别的以太网交换机上，在别的设备上照样有效，vlan透传可以通过802.1Q技术实现。<br>终结的意思相对，某个vlan的有效域不能再延伸到别的设备，或者不能通过某条链路延伸到别的设备。vlan的终结可以使用PVLAN技术。</p><span id="more"></span><p>本文主要浅析下PVLAN的概念以及实验验证下。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>把vlan终结掉，也就是确定vlan的边界在哪里终止，pvlan技术可以很好的实现这个功能，同时达到节省vlan的目的。cisco的PVLAN意思是private vlan，华为的意思是primary vlan. 不同叫法，基本相同的实现。</p><p>PVLAN中的vlan分成两类：primary vlan和secondary vlan(子vlan)。实现了接入用户二层报文的隔离，同时上层交换机下发的报文可以被每一个用户接收到，简化了配置，节省了vlan资源。</p><p>本文用以下拓扑来实验说明：<br><img src="https://rancho333.github.io/pictures/pvlan_topology.png"></p><p>pvlan中总是会有一个primary vlan，primary vlan中有promiscuous port。所有的端口都能和promiscuous port通信。在primary vlan中可以存在一个或多个secondary vlan，secondary vlan有两种类型：</p><ul><li>community vlan: community vlan中的成员端口可以相互通信，并且可以和promiscuous port通信</li><li>isolated vlan：成员端口之间不能通信，但是可以和promiscuous port通信。</li></ul><p>secondary vlan始终可以和promiscuous port通信，但是不同的secondary vlan之间是相互隔离的。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>实验拓扑如上所示。做一些简单说明：</p><ul><li>primary vlan的数值是100</li><li>secondary community vlan的数值是101</li><li>secondary isolated vlan的数值是102</li><li>vpc3和vpc4在community vlan中可以相互通信，并且可以和连接到promiscuous port的vpc2通信</li><li>vpc5和vpc6在isolated vlan中只能和vpc2通信</li><li>vpc2可以和所有其它vpc通信</li></ul><p>接下来就是配置了。</p><p>首先创建primary vlan和secondary vlan。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S(config)#vtp mode off                  &#x2F;&#x2F; 首先关闭vtp，只有vtpv3支持pvlan，干脆关掉免得复杂</span><br><span class="line">Setting device to VTP Off mode for VLANS.</span><br><span class="line"></span><br><span class="line">S(config)#vlan 100              </span><br><span class="line">S(config-vlan)#private-vlan primary             &#x2F;&#x2F; 创建primary vlan</span><br><span class="line">S(config-vlan)#private-vlan association add 101     &#x2F;&#x2F; 与secondary vlan关联</span><br><span class="line">S(config-vlan)#private-vlan association add 102</span><br><span class="line"></span><br><span class="line">S(config)#vlan 101</span><br><span class="line">S(config-vlan)#private-vlan community           &#x2F;&#x2F; 创建secondary community vlan</span><br><span class="line"></span><br><span class="line">S(config)#vlan 102</span><br><span class="line">S(config-vlan)#private-vlan isolated            &#x2F;&#x2F; 创建secondary isolated vlan</span><br></pre></td></tr></table></figure><p>接下来配置接口所属的vlan.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S(config)#interface range ethernet 0&#x2F;1-2        &#x2F;&#x2F; community vlan所属的两个端口, 属于CV 101</span><br><span class="line">S(config-if-range)#switchport mode private-vlan host    &#x2F;&#x2F; 指明这些端口是主机端口，类似于access port</span><br><span class="line">S(config-if-range)#switchport private-vlan host-association 100 101     &#x2F;&#x2F; 指明端口所属的primary vlan是100，secondary vlan是101</span><br><span class="line"></span><br><span class="line">S(config)#interface ethernet 0&#x2F;0</span><br><span class="line">S(config-if)#switchport mode private-vlan promiscuous           &#x2F;&#x2F; 指明该端口是promiscuous port</span><br><span class="line">S(config-if)#switchport private-vlan mapping 100 101            &#x2F;&#x2F; 将primary vlan与secondary vlan映射</span><br><span class="line"></span><br><span class="line">S(config)#interface ethernet 0&#x2F;3 </span><br><span class="line">S(config)#interface ethernet 1&#x2F;0       </span><br><span class="line">S(config-if)#switchport mode private-vlan host      &#x2F;&#x2F; 配置端口属于secondary isolated vlan</span><br><span class="line">S(config-if)#switchport private-vlan host-association 100 102</span><br></pre></td></tr></table></figure><p>查看下配置的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对于promiscuous port</span><br><span class="line">S#show interfaces ethernet 0&#x2F;0 switchport | include mapping     </span><br><span class="line">Administrative private-vlan mapping: 100 (VLAN0100) 101 (VLAN0101) 102 (VLAN0102)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于host端口</span><br><span class="line">S#show interfaces ethernet 0&#x2F;1 switchport | include host-association</span><br><span class="line">Administrative private-vlan host-association: 100 (VLAN0100) 101 (VLAN0101) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于isolated端口</span><br><span class="line">S#show interfaces ethernet 0&#x2F;3 switchport | include host-association</span><br><span class="line">Administrative private-vlan host-association: 100 (VLAN0100) 102 (VLAN0102)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看primary vlan和secondary vlan，以及secondary的类型</span><br><span class="line">S#show vlan private-vlan </span><br><span class="line"></span><br><span class="line">Primary Secondary Type              Ports</span><br><span class="line">------- --------- ----------------- ------------------------------------------</span><br><span class="line">100     101       community         Et0&#x2F;0, Et0&#x2F;1, Et0&#x2F;2</span><br><span class="line">100     102       isolated          Et0&#x2F;3, Et1&#x2F;0</span><br></pre></td></tr></table></figure><p>接下来ping测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对于community vlan的成员</span><br><span class="line">vpc3&gt; ping  192.168.1.2 -c 1            &#x2F;&#x2F; 可以ping通promiscuous port</span><br><span class="line"></span><br><span class="line">84 bytes from 192.168.1.2 icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.775 ms</span><br><span class="line"></span><br><span class="line">vpc3&gt; ping  192.168.1.4 -c 1            &#x2F;&#x2F; 可以ping通同secondary community的成员</span><br><span class="line"></span><br><span class="line">84 bytes from 192.168.1.4 icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.159 ms</span><br><span class="line"></span><br><span class="line">vpc3&gt; ping  192.168.1.5 -c 1        &#x2F;&#x2F; 不能ping通其它secondary vlan的成员</span><br><span class="line"></span><br><span class="line">host (192.168.1.5) not reachable</span><br></pre></td></tr></table></figure><p>vpc2同样可以ping通vpc3和vpc4，这里就不贴出来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对于isolated vlan的成员</span><br><span class="line">vpc5&gt; ping 192.168.1.6 -c 1         &#x2F;&#x2F; 不能ping通同vlan的其它成员</span><br><span class="line"></span><br><span class="line">host (192.168.1.6) not reachable</span><br><span class="line"></span><br><span class="line">vpc5&gt; ping 192.168.1.2 -c 1     &#x2F;&#x2F; 可以ping通promiscuous port</span><br><span class="line"></span><br><span class="line">84 bytes from 192.168.1.2 icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.815 ms</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; promiscuous port则可以ping通isolated vlan内的所有成员</span><br><span class="line">vpc2&gt; ping 192.168.1.5 -c 1</span><br><span class="line"></span><br><span class="line">84 bytes from 192.168.1.5 icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.050 ms</span><br><span class="line"></span><br><span class="line">vpc2&gt; ping 192.168.1.6 -c 1</span><br><span class="line"></span><br><span class="line">84 bytes from 192.168.1.6 icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.475 ms</span><br></pre></td></tr></table></figure><p>总结一下：<br>pvlan的实现：</p><ol><li>一定存在一个primary vlan, 里面有一个端口promiscuous port则可以ping通isolated</li><li>可以存在多个secondary vlan，secondary vlan之间不能通信，但都可与promiscuous port通信</li><li>secondary vlan分为community vlan和isolated vlan与secondary<ul><li>community vlan成员之间可以相互通信</li><li>isolated vlan成员之间不能相互通信</li><li>所有secondary vlan成员都能与promiscuous port通信</li></ul></li><li>pvlan作用域可以延伸到其它交换机，但是要保证交换机之间的链路是trunk，并允许primary vlan和secondary vlan通过 </li><li>上行设备只关心primary vlan而不会感知secondary vlan，从而节省vlan资源</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.h3c.com/cn/d_201505/868804_30003_0.htm">PVLAN技术白皮书</a></p>]]></content:encoded>
      
      
      
      
      <comments>https://rancho333.github.io/2022/10/12/PVLAN%E6%B5%85%E6%9E%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VTP协议简述</title>
      <link>https://rancho333.github.io/2022/10/11/VTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/10/11/VTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Tue, 11 Oct 2022 07:05:08 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文简要介绍写cisco的私有vlan中继协议VTP(vlan trunking protocol)，然后使用eveng环境做一些简单实验。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文简要介绍写cisco的私有vlan中继协议VTP(vlan trunking protocol)，然后使用eveng环境做一些简单实验。</p><span id="more"></span><p>当二层环境中有多台交换机，并且需要配置多个vlan的时候，这是一个繁琐且无聊的配置行为。VTP协议可以让我们只用在一台交换机上创建vlan，其它交换机则会同步创建的vlan。</p><h1 id="了解VTP"><a href="#了解VTP" class="headerlink" title="了解VTP"></a>了解VTP</h1><p>VTP设备有三种角色：</p><ol><li>VTP server：可以修改vlan配置，生成VTP通告</li><li>VTP  client：不可以通过CLI修改vlan配置，只能通过同步VTP通告修改vlan配置</li><li>VTP transparent：透传VTP通告但是不同步，可以修改本地vlan，修改也只在本地生效</li></ol><p>VTP三种模式的能力概要如下：</p><table><thead><tr><th align="left"></th><th align="left">VTP server</th><th align="left">VTP Client</th><th align="left">VTP transparent</th></tr></thead><tbody><tr><td align="left">创建/修改/删除 vlans</td><td align="left">yes</td><td align="left">no</td><td align="left">only local</td></tr><tr><td align="left">同步</td><td align="left">yes</td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left">透传</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr></tbody></table><p>通过下面几条说明来简单了解下VTP：</p><ol><li>VTP可以自动添加，修改，删除vlans</li><li>对于每一次改动，<code>revision</code>编号会增加</li><li>最近一次的通告会被发送给所有的VTP clients</li><li>VTP clients会同步接收到的通告</li></ol><p>VTP虽然可以减少vlan配置的工作量，但是会存在一些风险。根本原因是：<br>  VTP server同时也是VTP client, 而VTP client会同步接收到的revision号比自己大的通告。</p><p>如果我们在现有的网络环境中添加一台VTP server，而这台VTP server上的revision号比现有环境中设备的都大，那么新设备上的vlan配置会覆盖所有设备。本质就是环境中可能会有非预期设备的revision最大，覆盖环境的vlan配置。</p><p>此外还需要了解VTP的另一个知识点：VTP pruning.<br><img src="https://rancho333.github.io/pictures/vtp_pruning.png"></p><p>如图，交换机之间通过trunk互联。当左侧vlan10中的PC发送一个广播报文后，所有交换机都会收到泛洪的消息，而中间交换机的下联口中并没有vlan10，上联交换机泛洪流量就是在浪费带宽了。<br>在非VTP环境下，泛洪流量会发送给所有的trunk端口(trunk允许该vlan通过)，因为交换机并不知道trunk对端是否有在该vlan的成员。<br>在VTP环境下，交换机知道trunk对端配置了那些vlan，所以不在这些vlan范围的内泛洪流量就可以不发送给对端。这就是VTP pruning.</p><h1 id="VTP的配置"><a href="#VTP的配置" class="headerlink" title="VTP的配置"></a>VTP的配置</h1><p>使用如下的拓扑来进行VTP的配置实验：<br><img src="https://rancho333.github.io/pictures/vtp_topology.png"></p><p>将交换机之间的互联接口全部配置成trunk。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">S3#show vtp status </span><br><span class="line">VTP Version capable             : 1 to 3</span><br><span class="line">VTP version running             : 1</span><br><span class="line">VTP Domain Name                 : </span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP Traps Generation            : Disabled</span><br><span class="line">Device ID                       : aabb.cc80.3000</span><br><span class="line">Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00</span><br><span class="line">Local updater ID is 0.0.0.0 (no valid interface found)</span><br><span class="line"></span><br><span class="line">Feature VLAN:</span><br><span class="line">--------------</span><br><span class="line">VTP Operating Mode                : Server</span><br><span class="line">Maximum VLANs supported locally   : 1005</span><br><span class="line">Number of existing VLANs          : 5</span><br><span class="line">Configuration Revision            : 0</span><br><span class="line">MD5 digest                        : 0x57 0xCD 0x40 0x65 0x63 0x59 0x47 0xBD </span><br><span class="line">                                    0x56 0x9D 0x4A 0x3E 0xA5 0x69 0x35 0xBC </span><br></pre></td></tr></table></figure><p>S4、S5的VTP信息和S3基本一致，对显示的信息做一个简单的说明：</p><ul><li><code>Configuration Revision 0</code>: 每一次修改vlan该数值都会加1. 0是初始值，没有任何vlan操作</li><li><code>VTP Operating Mode</code> : 默认的模式是server模式</li><li><code>VTP Pruning Mode</code> : 防止不必要的流量通过trunk链路</li><li> <code>VTP version running</code> : 当前运行的vtp版本，默认是v1. v2与v1的差别不大，v2上主要引入对令牌环vlan的支持。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S3(config)#vlan 10</span><br><span class="line">S3(config-vlan)#name first_vlan</span><br><span class="line"></span><br><span class="line">S3#show vlan brief </span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0&#x2F;0, Et0&#x2F;1, Et0&#x2F;2, Et0&#x2F;3</span><br><span class="line">10   first_vlan                       active    </span><br><span class="line"></span><br><span class="line">S3#show vtp status | include Revision</span><br><span class="line">Configuration Revision            : 1</span><br></pre></td></tr></table></figure><p>在S3上创建名为first_vlan的vlan10, 可以看到revision号增加了1. 但是在S4、S5上并没有任何同步动作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S4#show vtp status | begin existing</span><br><span class="line">Number of existing VLANs          : 5</span><br><span class="line">Configuration Revision            : 0</span><br><span class="line"></span><br><span class="line">S5#show vtp status | begin existing   </span><br><span class="line">Number of existing VLANs          : 5</span><br><span class="line">Configuration Revision            : 0</span><br></pre></td></tr></table></figure><p>这是因为必须要配置VTP domain才能正常同步。</p><p>在S4、S5上开启VTP debug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S4#debug sw-vlan vtp events </span><br><span class="line">vtp events debugging is on</span><br><span class="line"></span><br><span class="line">S5#debug sw-vlan vtp events </span><br><span class="line">vtp events debugging is on</span><br></pre></td></tr></table></figure><p>在S3上配置vtp domain:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S3(config)#vtp domain rancho                   &#x2F;&#x2F; 配置vtp domain</span><br><span class="line">Changing VTP domain name from NULL to rancho</span><br><span class="line">S3(config)#</span><br><span class="line">*Oct 11 08:02:34.648: %SW_VLAN-6-VTP_DOMAIN_NAME_CHG: VTP domain name changed to rancho.</span><br></pre></td></tr></table></figure><p>可以在S4、S5看到vtp domain会自动同步过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S5#</span><br><span class="line">*Oct 11 08:14:23.822: VTP LOG RUNTIME: Summary packet received in NULL domain state</span><br><span class="line">*Oct 11 08:14:23.822: VTP LOG RUNTIME: Summary packet received, domain &#x3D; rancho, rev &#x3D; 1, followers &#x3D; 0, length 77, trunk Et0&#x2F;1</span><br><span class="line">*Oct 11 08:14:23.822: VTP LOG RUNTIME: Transitioning from NULL to rancho domain</span><br><span class="line">*Oct 11 08:14:23.822: VTP LOG RUNTIME: Summary packet rev 1 greater than domain rancho rev 0</span><br></pre></td></tr></table></figure><p>我们可以看到两件有意思的事：</p><ul><li>S5收到来自domain为<code>rancho</code>的VTP报文，并且决定将自己的domain从<code>NULL</code>改成<code>rancho</code>。这只会存在于设备没有配置domain的时候</li><li>S5发现VTP报文中revision(1)比自己当前(0)的高，同步报文中的vlan信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">S5#no debug all                        &#x2F;&#x2F; 关闭debug功能</span><br><span class="line"></span><br><span class="line">S5#show vtp status | begin existing</span><br><span class="line">Number of existing VLANs          : 6</span><br><span class="line">Configuration Revision            : 1       &#x2F;&#x2F; revision数值增减了，同步了S3的vlan配置</span><br><span class="line"></span><br><span class="line">S5#show vlan brief                         &#x2F;&#x2F; 确认配置信息同步，vlan10有了</span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0&#x2F;2, Et0&#x2F;3</span><br><span class="line">10   first_vlan                       active    </span><br><span class="line"></span><br><span class="line">S4#show vlan brief </span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0&#x2F;2, Et0&#x2F;3</span><br><span class="line">10   first_vlan                       active    </span><br></pre></td></tr></table></figure><p>分别在S4、S5上各创建一个vlan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S4(config)#vlan 40</span><br><span class="line">S4(config-vlan)#name second_vlan</span><br><span class="line"></span><br><span class="line">S5(config)#vlan 50</span><br><span class="line">S5(config-vlan)#name third_vlan</span><br></pre></td></tr></table></figure><p>在S3上可以正常同步到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S3#show vlan brief </span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0&#x2F;2, Et0&#x2F;3</span><br><span class="line">10   first_vlan                       active    </span><br><span class="line">40   second_vlan                      active    </span><br><span class="line">50   third_vlan                       active    </span><br><span class="line"></span><br><span class="line">S3#show vtp status | include Revision</span><br><span class="line">Configuration Revision            : 3            &#x2F;&#x2F; 同步两次，revision从1增加到3</span><br></pre></td></tr></table></figure><p>修改S3的模式为client：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S3(config)#vtp mode client </span><br><span class="line">S3#show vtp status | include Mode</span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP Operating Mode                : Client</span><br><span class="line"></span><br><span class="line">S3(config)#vlan  100</span><br><span class="line">VTP VLAN configuration not allowed when device is in CLIENT mode.</span><br><span class="line">&#x2F;&#x2F; client模式就不能配置valn了</span><br></pre></td></tr></table></figure><p>修改S3的模式为透传模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">S3(config)#vtp mode transparent </span><br><span class="line">Setting device to VTP Transparent mode for VLANS.</span><br><span class="line">&#x2F;&#x2F; 可以本地修改vlan信息，但是不会影响其它的vtp设备</span><br><span class="line"></span><br><span class="line">S4(config)#vlan 70</span><br><span class="line">S5#show spanning-tree | include Altn</span><br><span class="line">Et0&#x2F;0               Altn BLK 100       128.1    P2p    &#x2F;&#x2F; S4,5之间的直连链路被block了</span><br><span class="line">S5#show vlan brief </span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0&#x2F;2, Et0&#x2F;3</span><br><span class="line">10   first_vlan                       active    </span><br><span class="line">40   second_vlan                      active    </span><br><span class="line">50   third_vlan                       active    </span><br><span class="line">70   VLAN0070                         active           &#x2F;&#x2F;但是S5依然能学到S4的vlan, 走的是S3的透传</span><br><span class="line"></span><br><span class="line">S3#show vlan brief                  &#x2F;&#x2F; 透传模式的S3并没有学到vlan70</span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0&#x2F;2, Et0&#x2F;3</span><br><span class="line">10   first_vlan                       active    </span><br><span class="line">40   second_vlan                      active    </span><br><span class="line">50   third_vlan                       active    </span><br><span class="line">60   VLAN0060                         active    </span><br></pre></td></tr></table></figure><p>最后一个小的知识点就是关于vlan的配置文件。只要开启vtp功能，vlan的配置信息是独立存放在vlan.data文件中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S3#dir unix: | include vlan</span><br><span class="line">917755  -rw-         796  Oct 11 2022 08:34:46 +00:00  vlan.dat-00048</span><br><span class="line">&#x2F;&#x2F; 不同的设备存放的路径可能不一样</span><br></pre></td></tr></table></figure><p>并且vlan的配置信息在show run中是查看不到的，当关闭vtp时，vlan的配置信息就可以在show run中看到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">S3(config)#vtp mode off </span><br><span class="line"></span><br><span class="line">S3#show running-config | include vlan</span><br><span class="line">vlan 10</span><br><span class="line"> name first_vlan</span><br><span class="line">vlan 40</span><br><span class="line"> name second_vlan</span><br><span class="line">vlan 50</span><br><span class="line"> name third_vlan</span><br><span class="line">vlan 60 </span><br></pre></td></tr></table></figure><p>最最后关于VTPv3, V3和V2兼容，和v1兼容。有比较大的差异，主要在：</p><ul><li>VTP primary Server</li><li>Extended vlanss</li><li>private vlanss</li><li>rspan vlanss</li><li>mst support</li><li>authentication improvements<br>这里不做深入研究了，了解点VTPv2的皮毛先, 凑合用下吧。</li></ul><p>为了严谨点，附上一个VTP报文截图吧, 创建vlan80时抓的，看来vtp会携带所有的vlan信息。<br><img src="https://rancho333.github.io/pictures/vtp_packet.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cisco.com/c/zh_cn/support/docs/lan-switching/vtp/10558-21.html">了解 VLAN 中继协议 (VTP)</a></p>]]></content:encoded>
      
      
      
      
      <comments>https://rancho333.github.io/2022/10/11/VTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>snake traffic原理简述</title>
      <link>https://rancho333.github.io/2022/09/10/snake-traffic%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/09/10/snake-traffic%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Sat, 10 Sep 2022 01:00:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面写了一篇&lt;a href=&quot;https://rancho333.github.io/2022/09/02/%E4%BD%BF%E7%94%A8ixia%E5%AF%B9sonic%E8%BF%9B%E8%A1%8CL2-3%E6%89%93%E6%B5%81%E6%B5%8B%E8%AF%95/&quot;&gt;使用ixia对sonic进行L2,3打流测试&lt;/a&gt;, 这种场景下仪表的一个端口发包，dut的一个端口与之相连收包，通过在vlan内转发到DUT另一个端口，该端口与仪表的收包端口相连。仪表的一个端口发包，一个收包验证，从而验证二层转发(配置ip，路由即可验证三层)。&lt;br&gt;这种场景只能验证两个端口之间的数据转发，如果要一次验证所有端口的数据转发，那么需要用到snake traffic，将所有端口串起来，数据依次流经所有端口&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面写了一篇<a href="https://rancho333.github.io/2022/09/02/%E4%BD%BF%E7%94%A8ixia%E5%AF%B9sonic%E8%BF%9B%E8%A1%8CL2-3%E6%89%93%E6%B5%81%E6%B5%8B%E8%AF%95/">使用ixia对sonic进行L2,3打流测试</a>, 这种场景下仪表的一个端口发包，dut的一个端口与之相连收包，通过在vlan内转发到DUT另一个端口，该端口与仪表的收包端口相连。仪表的一个端口发包，一个收包验证，从而验证二层转发(配置ip，路由即可验证三层)。<br>这种场景只能验证两个端口之间的数据转发，如果要一次验证所有端口的数据转发，那么需要用到snake traffic，将所有端口串起来，数据依次流经所有端口</p><span id="more"></span><h1 id="snake-traffica"><a href="#snake-traffica" class="headerlink" title="snake traffica"></a>snake traffica</h1><p>先说明基本转发原理，然后根据不同的测试方案做进一步的说明。</p><h2 id="入-转-出理论基础"><a href="#入-转-出理论基础" class="headerlink" title="入-转-出理论基础"></a>入-转-出理论基础</h2><p>二层snake traffic依赖vlan对数据流进行方向控制，打流过程中有三个数据流的基础操作点。</p><ul><li>入。所有端口都设置成untag, 所以Rx是untag报文，根据端口的pvid打上对应的vlan tag</li><li>转。根据打上的vlan tag, 将报文转发到同vlan的其它端口，让其转发出去。<code>实际就是将报文从该端口的Tx发出去</code></li><li>出。出端口收到tag报文，剥离tag，从Tx发出出去。<br><img src="https://rancho333.github.io/pictures/snake_traffic_basic.png"></li></ul><h2 id="全loopback-snake-traffic"><a href="#全loopback-snake-traffic" class="headerlink" title="全loopback snake traffic"></a>全loopback snake traffic</h2><p>这种场景下，交换机前面板口全部通过loopback环回，当然也可以phy/mac环回。拓扑图如下：<br><img src="https://rancho333.github.io/pictures/snake_traffic_loopback.png"></p><p>左侧的拓扑图是配置原理，右侧的拓扑是数据流的走向。broadcome芯片sdk配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vlan clear              &#x2F;&#x2F; 清除所有vlan</span><br><span class="line">vlan remove 1 pbm&#x3D;ce       &#x2F;&#x2F; 将所有端口从默认vlan中移除</span><br><span class="line">&#x2F;&#x2F;pbm是port bitmap，ubm是untag bitmap</span><br><span class="line">vlan create 100 pbm&#x3D;ce1,ce2 ubm&#x3D;ce1,ce2; pvlan set ce1 100          &#x2F;&#x2F; 创建vlan100，vlan100的端口成员是ce1和ce2，不带tag；设置ce1的native vlan为100</span><br><span class="line">vlan create 101 pbm&#x3D;ce2,ce3 ubm&#x3D;ce2,ce3; pvlan set ce2 101</span><br><span class="line">vlan create 102 pbm&#x3D;ce3,ce4 ubm&#x3D;ce3,ce4; pvlan set ce3 102</span><br><span class="line">vlan create 103 pbm&#x3D;ce4,ce1 ubm&#x3D;ce4,ce1; pvlan set ce4 103</span><br><span class="line">ps ce            &#x2F;&#x2F; 确认所有端口up</span><br><span class="line">clear c                  &#x2F;&#x2F; 清除端口统计数据</span><br><span class="line">tx 800 pbm&#x3D;ce0 vlan&#x3D;100        &#x2F;&#x2F; 生成数据流</span><br><span class="line">port ce0 en&#x3D;off            &#x2F;&#x2F; 结束打流</span><br><span class="line">port ce0 en&#x3D;on            &#x2F;&#x2F; 恢复端口</span><br><span class="line">show c CDMIB_RPOK.ce      &#x2F;&#x2F; 查看计数</span><br></pre></td></tr></table></figure><p>每个端口属于两个vlan，<code>通过native vlan来控制数据流发往那个vlan，另一个vlan则用来接收数据, 这样就形成了一个固定方向的数据流</code>。</p><p>以下图来详细说明数据流的走向：<br><img src="https://rancho333.github.io/pictures/snake_traffic_loopback_internal.png"></p><ol><li>初始状态下。cpu通过tx命令生成报文发送到ce1，ce1从tx将报文转发出去。实际上ASIC通过cpu0接口(asic上一个不可见的端口)与CPU连接，cpu将报文发送到cpu0，cpu0将报文转发给ce1. 所以看起来就是：cpu生成报文，ce1从tx将报文转发出去</li><li>ce1的端口是loopback，tx的报文会转到rx，rx收到报文打上100的vlan tag，转给vlan 100的成员端口ce2</li><li>ce2将报文untag之后从tx发送出去，因为是loopback，所以又会从rx回来，rx收到报文打上101的vlan tag, 转给vlan 101的成员端口</li><li>同理ce3将报文转给ce4，ce4将报文转回给ce1</li><li>ce1将ce4转来的报文从Tx转发出去，重复步骤1的流程。这样就形成了loop的数据流，很快就会达到线速。</li></ol><p>一点说明：这种场景下，因为有loopback的存在，所以端口的tx，rx都会参与到流量的转发。这就可以理解为双向打流。</p><h2 id="端口通过DAC-cable互联"><a href="#端口通过DAC-cable互联" class="headerlink" title="端口通过DAC cable互联"></a>端口通过DAC cable互联</h2><p>这种场景下，交换机相邻的两个端口用cable先互联起来，相邻的两个没有用cable先互联的端口则配置在相同vlan中进行数据转发。可以这么理解，同一个vlan内的两个端口组成一个交换机，然后用cable线将这些交换机依次连接，组成一个环。拓扑如下：<br><img src="https://rancho333.github.io/pictures/snake_traffic_dac.png"></p><p>端口2,3组成一台交换机，端口3,4组成一个交换机，互联成环。同样的道理，如果进行三层打流，并将所有的端口串在一起，可以用vrf，每两个端口在一个vrf中组成一个router，vrf之间通过cable互联，通过配置ip和路由就可实现snake traffic。</p><p>dac cable连接的snake traffic配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只贴出vlan配置，其它参考上面</span><br><span class="line">vlan create 100 pbm&#x3D;ce2,ce3 ubm&#x3D;ce2,ce3; pvlan set ce2,ce3 100</span><br><span class="line">vlan create 101 pbm&#x3D;ce4,ce1 ubm&#x3D;ce4,ce1; pvlan set ce4,ce1 101</span><br></pre></td></tr></table></figure><p>这种场景下，一个端口只属于一个vlan(类似于上层的access端口)，端口所属的vlan就是native vlan, 不是很确定pvlan还需不需要配置。此时不需要native vlan来控制数据流的方向，所以两个端口pvlan都一样。</p><p>以下图来详细说明数据流的走向：<br><img src="https://rancho333.github.io/pictures/snake_traffic_dac_internal.png"></p><ol><li>初始状态下。cpu生成报文让ce1从tx发送出去。报文通过cable先发送到ce2</li><li>ce2 rx到报文后，打上vlan tag 100，发送给vlan 100成员端口ce3</li><li>ce3收到报文之后将tag剥离从tx发出， 通过cable线到达ce4</li><li>ce4通过vlan将报文转给ce1，ce1从tx发出，重复步骤1的流程，形成loop数据流，很快就会达到线速</li></ol><h2 id="dac和loopback混合测试"><a href="#dac和loopback混合测试" class="headerlink" title="dac和loopback混合测试"></a>dac和loopback混合测试</h2><p>实验拓扑如图：<br><img src="https://rancho333.github.io/pictures/snake_traffic_dac_loopback.png"></p><p>其中，12,34是dac方式，5,6,7,8是loopback方式。<br>需要注意下两种方式之间的流量衔接问题接口。<br>对于dac向loopback过度的节点，即4,5: 将4,5配置在同一个vlan中，并将4的native vlan设置成该值，这样dac方向的流量就可以从4转发到5，然后进入loopback方向。</p><p>对于loopback向dac过度的节点，将8，1配置在同一个vlan中，两者的native vlan都设置成该vlan，这样8 rx的流量就会转给1，进入dac方向。</p><p>如果不使用CPU发包，而是将一个端口与测试连接，拓扑如下：<br><img src="https://rancho333.github.io/pictures/snake_traffic_ixia.png"></p><p>配置不需要做任何改变。理解报文的转发流程，拓扑怎么变都可以搞定。<br>ixia发出的报文对8来说是rx，8的native vlan是8,1共同所属的vlan，所以流量转发到1。<br>7转发给8的流量，8从tx发出到ixia，所以ixia从一个端口发出的报文，又从该端口收回来，查看ixia端口的丢包状态即可了解dut的丢包状态。</p>]]></content:encoded>
      
      
      
      
      <comments>https://rancho333.github.io/2022/09/10/snake-traffic%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>eveng虚拟网络环境简述</title>
      <link>https://rancho333.github.io/2022/09/06/eveng%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/09/06/eveng%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Tue, 06 Sep 2022 08:13:55 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文主要分析下vmware三种网络模式的实现，然后说明eveng如何借助vmware虚拟网卡实现内部设备与外网的联通，最后分析下eveng lab中虚拟网络设备之间的连通性。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文主要分析下vmware三种网络模式的实现，然后说明eveng如何借助vmware虚拟网卡实现内部设备与外网的联通，最后分析下eveng lab中虚拟网络设备之间的连通性。</p><span id="more"></span><h1 id="VMware的三种网络模式"><a href="#VMware的三种网络模式" class="headerlink" title="VMware的三种网络模式"></a>VMware的三种网络模式</h1><p>vmware有桥接、NAT、host-only三种网络模式。其中NAT和host-only会默认在host上各创建一张虚拟网卡。其中VMnet1是host-only，VMnet8是NAT。我们在虚拟的配置hardware时，可以添加网络设备。<br><img src="https://rancho333.github.io/pictures/eveng_vmware_network.png"><br>如果选择NAT、host-only、桥接则使用默认网卡。选择custome时，可以指定我们自己创建的其它网卡。注意，只能存在一个bridge和NAT的网络，即我们可以额外添加的虚拟网络类型只能是host-only。下面对三种网络模式做一个简单说明。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>三种模式下只有桥接模式没有创建虚拟网卡，这种模式下虚拟机和主机相当于连接在同一个网桥上，网桥的出口是主机的物理出口网卡，虚拟机的ip和主机的ip由上游DHCP同一分配，两者在同一网段，虚拟机可以自由的访问同子网的主机(当然包括主机)，这种情况下虚拟没有和外部网络隔离，会消耗主机网络环境的ip。可以同时满足主机与虚拟机之间的网络连通，以及虚拟机与外部网络之间的网络连通。<br><img src="https://rancho333.github.io/pictures/eveng_vmware_bridge.png"></p><p>简言之，桥接模式就是虚拟机和主机连接在同一个网桥上，网桥上连是出口，下连是虚拟机和主机。桥接模式和主机物理网卡是强相关的，在创建bridge虚拟网络时，选择auto选项，vmware会自动从主机多网卡中选择合适的进行桥接。</p><h2 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h2><p>NAT模式默认创建VMnet8虚拟网卡。虚拟机网卡与vmnet8相连，vmnet8在主机上是一块物理网卡，是直连网段，所以主机与虚拟机之间可以直接通过Vmnet8通信。vmnet8上开启dhcp服务，负责给虚拟机分配ip，在vmware设置中可以设置所需的网段。当虚拟机需要和主机外部通信时，vmnet8通过NAT服务将虚拟机ip映射主机某个物理网卡ip，从而实现和外网的连通性。模型如下图所示：<br><img src="https://rancho333.github.io/pictures/eveng_vmware_nat.png"></p><p>这种场景下，虚拟机与主机通过vmnet8同网段通信，复用主机ip通过NAT与外网通信。在NAT模式的配置下并没有看到NAT转换的具体配置，关键是没看到转换后的ip, 这其实与主机的实际出口网卡相关，这难道和桥接模式一样，也是自动选择的？</p><h2 id="host-only模式"><a href="#host-only模式" class="headerlink" title="host-only模式"></a>host-only模式</h2><p>host-only模式默认创建VMnet1虚拟网卡。虚拟机网卡与vmnet1相连。该模式本质就是NAT模式阉割掉NAT功能，使得虚拟机只能与主机网络可达，而不能访问外部网络。这样可以有效的实现虚拟机与外部网络环境的隔离。</p><h2 id="一些小结思考"><a href="#一些小结思考" class="headerlink" title="一些小结思考"></a>一些小结思考</h2><p>真实的拓扑模型可能和上述的不一样，上述只是自己实验加理解的结果。在上面理解中，VMnet我其实是理解成三层交换机而不是网卡，因为它可以被多个虚拟机连接，但是网卡的一个端口在系统上会映射成一个网络设备，多个接口会映射成多个网络设备，所以在windows的视角中，vmnet就是一个单接口的网卡。<br>有些博客中提到：vmware会创建虚拟交换机和虚拟网卡，虚拟交换机互联虚拟机网卡，主机虚拟网卡。<br><img src="https://rancho333.github.io/pictures/eveng_vmware_blog.png"><br>这种拓扑是比较合理的，windows的视角下有一块网卡VMnet8，而虚拟机连接的是同名为VMnet8的网桥，所以多个虚拟机可以连接到VMnet8，这三者组成vmware虚拟网络环境，虚拟机和主机通过vmnet8同网段进行通信，vmnet8与物理NIC之间通过NAT与外网通信。给虚拟机设置网卡的配置界面如下：<br><img src="https://rancho333.github.io/pictures/eveng_vmware_adapter.png"></p><p>在虚拟机的视角下，每添加一个network adapter就是在虚拟机上创建一个物理网卡，network connection选项则是虚拟机网卡连接vmware虚拟网络环境的模式，通过连接到指定的虚拟网桥来实现的，而不同的虚拟网桥连接着不同的windows虚拟网卡(bridge没有虚拟网卡)。</p><h1 id="eveng中镜像的连接实现"><a href="#eveng中镜像的连接实现" class="headerlink" title="eveng中镜像的连接实现"></a>eveng中镜像的连接实现</h1><p>一个简单的eveng镜像连接如下所示：<br><img src="https://rancho333.github.io/pictures/eveng_image_connection.png"></p><p>这里有三个对象，switch、vpc以及他们的连接线，switch和vpc由各自的镜像提供运算仿真逻辑，当我们需要仿真某种设备时，只需要将其镜像导入eveng，而镜像的运行则依赖于eveng的三大虚拟仿真组件：iol、qemu、dynamips。那么镜像之间的连接线是如何实现的呢？通过bridge来实现。在上图拓扑基础上我们进入eveng的CLI界面：<br>将lab中的image启动后查看bridge状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@eve-ng5:~# brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">pnet08000.000c297a7ddenoeth0</span><br><span class="line">pnet18000.000c297a7de8noeth1</span><br><span class="line">...</span><br><span class="line">vnet0_18000.4e340b0134f2novunl0_1_0</span><br><span class="line">            vunl0_2_0</span><br></pre></td></tr></table></figure><p>vnet0_1仿真的就是S和vpc的连接线，bridge上有两个接口分别连接在S和vpc上。我们增加拓扑结构：<br><img src="https://rancho333.github.io/pictures/eveng_image_connection_more.png"></p><p>再次查看bridge状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@eve-ng5:~# brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">pnet08000.000c297a7ddenoeth0</span><br><span class="line">...</span><br><span class="line">vnet0_18000.7a42880945b1novunl0_1_0</span><br><span class="line">            vunl0_2_0</span><br><span class="line">vnet0_28000.0ef8341d6178novunl0_1_16</span><br><span class="line">            vunl0_3_0</span><br><span class="line">vnet0_38000.6a2c8be29ff6novunl0_1_32</span><br><span class="line">            vunl0_4_0</span><br></pre></td></tr></table></figure><p>图中有3条连接线，所以这里有三个vnet_name命名模式的网桥，一个网桥模拟一个连接线，每个网桥上都有vun0_1_name命名模式的接口，可见这是S的接口，所以他们这件的真实的连接拓扑如图：<br><img src="https://rancho333.github.io/pictures/eveng_image_connection_bridge.png"></p><p>当删除网元设备或关闭lab的时候，模拟他们连接线的网桥并不会自动删除，自由彻底关闭eveng虚拟机才会清除，但这对我们的使用并不会有什么影响。</p><h1 id="eveng虚拟机的网卡"><a href="#eveng虚拟机的网卡" class="headerlink" title="eveng虚拟机的网卡"></a>eveng虚拟机的网卡</h1><p>eveng本身就是一台运行在linux中的虚拟机，在创建虚拟机的时候会指定网卡以及连接方式。在<code>一些小结思考</code>图示中我们给eveng添加了两块网卡。每块网卡以名为ethnum的模式命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@eve-ng5:~# ifconfig </span><br><span class="line">eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 00:0c:29:7a:7d:de  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 390  bytes 73174 (73.1 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 552  bytes 75404 (75.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth1: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 00:0c:29:7a:7d:e8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 21  bytes 3432 (3.4 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 14  bytes 1136 (1.1 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>eth0对应的是Network Adapter，eth1对应的是Network Adapter2,其中eth0作为管理网卡，也就是我们通过web访问eveng的ip。注意eveng会为每块网卡创建一个bridge, 然后将网卡attach到brige上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@eve-ng5:~# brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">pnet08000.000c297a7ddenoeth0</span><br><span class="line">pnet18000.000c297a7de8noeth1</span><br><span class="line">pnet28000.000000000000no</span><br><span class="line">pnet38000.000000000000no</span><br><span class="line">pnet48000.000000000000no</span><br><span class="line">pnet58000.000000000000no</span><br><span class="line">pnet68000.000000000000no</span><br><span class="line">pnet78000.000000000000no</span><br><span class="line">pnet88000.000000000000no</span><br><span class="line">pnet98000.000000000000no</span><br></pre></td></tr></table></figure><p>网卡ethnum与网桥pnetnum一一对应，eveng最大支持10块网卡。eth0作为管理网口，一般选择host-only, 这样可以配置dhcp地址池，使其每次启动获得固定ip，并且和外网隔离。如果使用bridge模式eveng的管理ip则会随主机网络环境变换而发生变化。管理网口ip就是网桥pnet0的ip:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@eve-ng5:~# ifconfig pnet0</span><br><span class="line">pnet0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.183.134  netmask 255.255.255.0  broadcast 192.168.183.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe7a:7dde  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:7a:7d:de  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1064  bytes 196089 (196.0 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1576  bytes 217466 (217.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>为什么要将网卡attach到bridge上呢？这是为了让lab中的镜像可以访问到主机网络和外部网络。bridge在lab的表现形式是cloudNum。<br><img src="https://rancho333.github.io/pictures/eveng_network_cloud.png"></p><p>pnet0对应的是cloud0, pnet1对应的是cloud1，依次类推。lab中网元访问外部网络如图示：<br><img src="https://rancho333.github.io/pictures/eveng_network_cloud0.png"></p><p>vpc可以向VMnet1请求dhcp, 获得和管理网口同网段的ip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VPCS&gt; ip dhcp</span><br><span class="line">DDORA IP 192.168.183.143&#x2F;24</span><br></pre></td></tr></table></figure><p>其完整的网络连接拓扑如下图：<br><img src="https://rancho333.github.io/pictures/eveng_network_lab_connection.png"></p><p>当vpc请求dhcp时，我们在windows上对VMnet1抓包可以看到dhcp交互报文。</p><p>lab中的网元连接到不同的cloud，就可以根据cloud所属网桥的网卡的连接方式(bridge, nat, host-only)获得对应的网络能力，实现lab与主机和外部网络的连通性。</p><p>总结一下，配置eveng时的network adapter对应eveng中的eth网卡，eth网卡attch到pnet网桥上，pnet网桥对应lab中的cloud，lab中的网元连接到对应cloud即可获得相应网络能力。</p><h2 id="完整的eveng与vmware虚拟网络连接示意图"><a href="#完整的eveng与vmware虚拟网络连接示意图" class="headerlink" title="完整的eveng与vmware虚拟网络连接示意图"></a>完整的eveng与vmware虚拟网络连接示意图</h2><p>vmware是可以创建多张虚拟网卡的，默认有三种网络类型，bridge没有虚拟网卡，VMnet1对应host-only,VMnet8对应NAT。虽然允许创建额外的VMnet，<code>但是类型只能是host-only</code>，所以看起好像没什么创建的必要，默认的就已经够用了。我们需要做的也就是配置一下dhcp地址池(使用默认的也行)。<br>对于eveng的虚拟网络，由外网、windows、vmware、eveng、lab这些对象组成，完整的网络拓扑如下：<br><img src="https://rancho333.github.io/pictures/eveng_network_topology.png"></p><p>下图是在vmware下创建虚拟网卡的界面，可以看到vmnet0虽然没有在windows上创建网卡，但是在vmware中还是有设备的，此时vmnet0就是一个网桥。<br><img src="https://rancho333.github.io/pictures/eveng_vmware_vnic.png"></p><p>所以在vmware中创建一张网卡后：</p><ol><li>在windows网络中添加了一张网卡</li><li>在vmware环境中添加了一个同名网桥</li><li>当将这张网卡配置给虚拟机时，虚拟机中创建一张网卡，然后连接到vmware的网桥，获得对应网络能力</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/eveng/">eveng</category>
      
      
      <comments>https://rancho333.github.io/2022/09/06/eveng%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用ixia对sonic进行L2,3打流测试</title>
      <link>https://rancho333.github.io/2022/09/02/%E4%BD%BF%E7%94%A8ixia%E5%AF%B9sonic%E8%BF%9B%E8%A1%8CL2-3%E6%89%93%E6%B5%81%E6%B5%8B%E8%AF%95/</link>
      <guid>https://rancho333.github.io/2022/09/02/%E4%BD%BF%E7%94%A8ixia%E5%AF%B9sonic%E8%BF%9B%E8%A1%8CL2-3%E6%89%93%E6%B5%81%E6%B5%8B%E8%AF%95/</guid>
      <pubDate>Fri, 02 Sep 2022 07:22:01 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;环境说明&quot;&gt;&lt;a href=&quot;#环境说明&quot; class=&quot;headerlink&quot; title=&quot;环境说明&quot;&gt;&lt;/a&gt;环境说明&lt;/h1&gt;&lt;p&gt;实验拓扑如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://rancho333.github.io/pictures/ixia_sonic_topology.png&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><p>实验拓扑如图：</p><p><img src="https://rancho333.github.io/pictures/ixia_sonic_topology.png"></p><span id="more"></span><p>线连接好后，ixia上做些配置使端口up。sonic上link training和auto negotiation默认关闭，FEC开启。在ixia上对应接口做设置与之匹配。</p><p><img src="https://rancho333.github.io/pictures/ixia_port_up.png"></p><p>确认端口up:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:&#x2F;home&#x2F;admin# show interfaces status Ethernet49</span><br><span class="line">  Interface        Lanes    Speed    MTU    FEC    Alias    Vlan    Oper    Admin             Type    Asym PFC</span><br><span class="line">-----------  -----------  -------  -----  -----  -------  ------  ------  -------  ---------------  ----------</span><br><span class="line"> Ethernet49  41,42,43,44     100G   9216     rs    etp49  routed      up       up  QSFP28 or later         N&#x2F;A</span><br><span class="line">root@localhost:&#x2F;home&#x2F;admin# show interfaces status Ethernet50</span><br><span class="line">  Interface        Lanes    Speed    MTU    FEC    Alias    Vlan    Oper    Admin             Type    Asym PFC</span><br><span class="line">-----------  -----------  -------  -----  -----  -------  ------  ------  -------  ---------------  ----------</span><br><span class="line"> Ethernet50  45,46,47,48     100G   9216     rs    etp50  routed      up       up  QSFP28 or later         N&#x2F;A&#x3D;</span><br></pre></td></tr></table></figure><h1 id="二层打流"><a href="#二层打流" class="headerlink" title="二层打流"></a>二层打流</h1><p>ixia eth7端口发出二层报文，sonic两个端口在同一vlan，ixia eth8端口接收报文进行数据统计，检查是否丢包。同理eth8发包，eth7收包。这样就实现双向二层线速打流测试。详细步骤如下：</p><p>sonic配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">config vlan add 78</span><br><span class="line">config vlan member add -u 78 Ethernet49</span><br><span class="line">config vlan member add -u 78 Ethernet50</span><br><span class="line"></span><br><span class="line">确认vlan配置：</span><br><span class="line">root@localhost:&#x2F;home&#x2F;admin# show vlan brief </span><br><span class="line">+-----------+--------------+------------+----------------+-------------+-----------------------+</span><br><span class="line">|   VLAN ID | IP Address   | Ports      | Port Tagging   | Proxy ARP   | DHCP Helper Address   |</span><br><span class="line">+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+</span><br><span class="line">|        78 |              | Ethernet49 | untagged       | disabled    |                       |</span><br><span class="line">|           |              | Ethernet50 | untagged       |             |                       |</span><br></pre></td></tr></table></figure><p>ixia进行如下配置：<br>如图分别将eth7, eth8创建成L2接口：<br><img src="https://rancho333.github.io/pictures/ixia_l2_port.png"></p><p>之后创建二层流：<br><img src="https://rancho333.github.io/pictures/ixia_l2_traffic.png"></p><p>图示是eth7发送，eth8接收检查，同理创建反向流，实现双向打流测试。注意最好修改二层报文的源目mac地址。</p><p>最后打流测试：<br><img src="https://rancho333.github.io/pictures/ixia_l2_traffic_loss.png"></p><h1 id="三层打流"><a href="#三层打流" class="headerlink" title="三层打流"></a>三层打流</h1><p>ixia eth7,8设置为三层接口，网关指向sonic，创建两条流分别：src为eth7，dst为eth8； src为eth8,dst为eth7.这样就实现双向三层线速打流测试。详细步骤如下：</p><p>sonic配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config interface ip add Ethernet49 10.1.1.2&#x2F;24 </span><br><span class="line">config interface ip add Ethernet50 10.1.2.2&#x2F;24</span><br><span class="line"></span><br><span class="line">确认配置：</span><br><span class="line">root@localhost:&#x2F;home&#x2F;admin# show ip interfaces </span><br><span class="line">Interface    Master    IPv4 address&#x2F;mask    Admin&#x2F;Oper    BGP Neighbor    Neighbor IP</span><br><span class="line">-----------  --------  -------------------  ------------  --------------  -------------</span><br><span class="line">Ethernet49             10.1.1.2&#x2F;24          up&#x2F;up         N&#x2F;A             N&#x2F;A</span><br><span class="line">Ethernet50             10.1.2.2&#x2F;24          up&#x2F;up         N&#x2F;A             N&#x2F;A</span><br></pre></td></tr></table></figure><p>ixia进行如下配置：<br>如图所示分别将eth7,eth8创建成L3接口：<br><img src="https://rancho333.github.io/pictures/ixia_l3_port.png"></p><p>然后依次为两个接口配置ip地址和gateway:<br><img src="https://rancho333.github.io/pictures/ixia_l3_port_ip.png"></p><p>将拓扑使能之后，测试网络的连通性：<br><img src="https://rancho333.github.io/pictures/ixia_l3_port_ping.png"></p><p>之后创建L3流，图上所示是eth7到eth8的流，同理创建eth8到eth7的流：<br><img src="https://rancho333.github.io/pictures/ixia_l3_traffic.png"></p><p>注意和L2的数据流不同，L3不需要手动修改报文的src mac，dst mac等字段，会自动配置。</p><p>最后打流测试，查看丢包情况：<br><img src="https://rancho333.github.io/pictures/ixia_l3_traffic_loss.png"></p>]]></content:encoded>
      
      
      
      
      <comments>https://rancho333.github.io/2022/09/02/%E4%BD%BF%E7%94%A8ixia%E5%AF%B9sonic%E8%BF%9B%E8%A1%8CL2-3%E6%89%93%E6%B5%81%E6%B5%8B%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>半自动化批量保存网页</title>
      <link>https://rancho333.github.io/2022/08/24/%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%B9%E9%87%8F%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5/</link>
      <guid>https://rancho333.github.io/2022/08/24/%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%B9%E9%87%8F%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5/</guid>
      <pubDate>Wed, 24 Aug 2022 06:28:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;使用两个工具&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;web scraper 批量获取文章的链接，导出为csv文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SingleFile 批量下载链接网页  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>使用两个工具</p><ol><li><p>web scraper 批量获取文章的链接，导出为csv文件</p></li><li><p>SingleFile 批量下载链接网页  </p></li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rancho333.github.io/2022/08/24/%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%B9%E9%87%8F%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IPSec简述</title>
      <link>https://rancho333.github.io/2022/08/01/IPSec%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/08/01/IPSec%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Mon, 01 Aug 2022 06:26:57 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://rancho333.github.io/2022/07/29/GRE%E7%AE%80%E8%BF%B0/&quot;&gt;GRE简述&lt;/a&gt;中描述了一种vpn的实现，但是GRE没有认证，加密，数据完整性验证等特性，是一个不安全的封装协议，所以实际使用中都是结合IPSec一起。本文介绍VPN的第二种常见实现——IPSec.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在<a href="https://rancho333.github.io/2022/07/29/GRE%E7%AE%80%E8%BF%B0/">GRE简述</a>中描述了一种vpn的实现，但是GRE没有认证，加密，数据完整性验证等特性，是一个不安全的封装协议，所以实际使用中都是结合IPSec一起。本文介绍VPN的第二种常见实现——IPSec.</p><span id="more"></span><h1 id="IPSec简介"><a href="#IPSec简介" class="headerlink" title="IPSec简介"></a>IPSec简介</h1><p>IPSec通过认证头AH(authentication header, 协议号51)和封装安全载荷ESP(encapsulating security payload)这两个安全协议来实现。此外可以通过IKE(internet key exchange)完成密钥交换。一般场景使用IKE自动管理密钥交换，SA建立，使用ESP进行报文验证和加密。</p><p>IPSec有两种封装模式：</p><ul><li>传输模式：在传输模式下，AH或ESP被插入到IP头之后但在所有传输层协议之前，或所有其它IPSec协议之前。</li><li>隧道模式：在隧道模式下，AH或ESP插在原始IP头之前，另外生成一个新的IP头放在AH或ESP之前。</li></ul><p>传输模式用于两台主机之间的通讯，或者一台主机和一个安全网关之间的通讯。在传输模式下，对报文加密和解密的两台设备本身必须是报文的原始发送者和最终接收者。</p><p>通常，在两个安全网关之间的数据流量，绝大部分都不是安全网关本身的流量，因此安全网关之间一般不使用传输模式，而是使用隧道模式。在一个安全网关被加密的报文，只有另一个安全网关才能被解密。</p><p>IPSec的两大核心功能分别是<em>加密</em>和<em>认证</em>，ipsec使用对称加密算法，主要包括DES、3DES和AES。对于认证，在发送消息之前会先使用验证算法和验证密钥对消息进行处理，得到报文摘要；另一方收到消息后同样计算摘要，然后对比两端的摘要，如果相同则消息没有被篡改。常用的验证算法有MD5和SHA系列。</p><p>AH(IP协议号51)可提供数据源验证和数据完整性校验功能；<br>ESP(IP协议号50)除提供数据源验证和数据完整性校验功能外，还提供对IP报文的加密功能。ESP的工作原理是在每一个数据包的标准IP包头后面添加一个ESP报文头，并在数据包后面追加一个ESP尾。与AH协议不同的是，ESP将需要保护的报文进行加密后再封装到IP包中，以保证数据的机密性。</p><p>两者均可单独使用，也可一起配合使用。各自作用范围如下图所示：<br><img src="https://rancho333.github.io/pictures/ipsec_range.png"></p><p>可见，AH提供的认证服务要强于ESP，同时使用AH和ESP时，设备支持的AH和ESP联合使用方式为：先对报文进行ESP封装，再对报文进行AH封装，封装之后的报文从内到外一次是原始IP报文，ESP报文头，AH报文头和外部IP头。</p><p>IPSec除了能为其它隧道协议提供数据保护外，IPSec也可自己单独作为隧道协议来提供隧道的建立。如果IPSec自己单独作为隧道协议来使用，那么IPsec就不需要任何其它隧道协议就能独立实现VPN功能。这两种使用方式由管理员的配置来决定。需要注意的是，IPSec目前只支持ipv4单播。</p><p>IPSec通过定义一些方法来保护特定的IP数据报，这些流量如何被保护，还有流量发给谁。</p><h3 id="安全联盟"><a href="#安全联盟" class="headerlink" title="安全联盟"></a>安全联盟</h3><p>IPSec在两个端点之间提供安全通信，端点被称为IPSec对等体。<br>IPSec中通信双方建立的连接叫做安全联盟(security association)，顾名思义，通信双方结成盟友，使用相同的协议(AH、ESP还是两者结合)、封装模式(传输模式还是隧道模式)、加密算法(DES、3DES、AES)、加密密钥、验证算法、验证密钥、密钥周期。SA是IPSec的基础，也是IPSec的<em>本质</em>. SA并不是隧道，形象的说是一份合约，协商双方共同遵守的合约。</p><p>建立SA的方式有两种，手工配置和IKE自动协商。</p><p>安全联盟是单向的逻辑连接，在两个对等体之间的双向通信，最少需要两个SA来分别对两个方向的数据流进行安全保护。同时，如果两个对等体希望同时使用AH和ESP来进行安全通信，则每个对等体都会针对每一种协议来构建一个独立的SA。如下图所示：<br><img src="https://rancho333.github.io/pictures/ipsec_security.png"></p><p>SA由一个三元组来唯一标识，这个三元组包括SPI(security parameter index, 安全参数索引)、目的IP地址、安全协议号(AH或ESP)。</p><p>SPI是用于唯一标识SA的一个32比特数值，他在AH和ESP头中传输。在手工配置SA时，需要手工指定SPI的取值。使用IKE协商产生SA时，SPI将随机生成。</p><p>通过IKE协商建立的SA具有生存周期，手工方式建立的SA永不老化。IKE协商建立的SA的生存周期有两种定义方式：</p><ul><li>基于时间的生存周期，定义了一个SA从建立到失效的时间</li><li>基于流量的生存周期，定义了一个SA允许处理的最大流量</li></ul><p>生存周期到达指定的时间或指定的流量，SA就会失效。SA失效前，IKE将为IPSec协商建立新的SA，这样，在旧的SA失效前新的SA就已经准备好了。</p><p>建立安全联盟最直接的方式就是分别在两端认为设定好封装模式、加密算法、加密密钥、验证算法、验证密钥。</p><h3 id="IPSec虚拟隧道接口"><a href="#IPSec虚拟隧道接口" class="headerlink" title="IPSec虚拟隧道接口"></a>IPSec虚拟隧道接口</h3><p>IPSec虚拟隧道接口是一种支持路由的三层逻辑接口，它可以支持动态路由协议，所有路由到IPSec虚拟隧道接口的报文都将进行IPSec保护，同时还可以支持对组播流量的保护，和实现GRE的tunnel接口类似。使用虚拟隧道接口有以下优点：</p><ul><li>简化配置：通过路由来确定那些数据流进行IPSec保护。</li><li>减少开销：在保护远程接入用户流量的组网应用中，在IPSec虚拟隧道接口处进行报文封装，与IPSec over GRE或者IPSec over L2TP方式的隧道封装相比，无需额外为入隧道流量加封装GRE或者L2TP头，减少了报文封装层次，节省了带宽。</li><li>业务应用更加灵活：IPsec虚拟隧道接口在实施过程中明确地区分出“加密前”和“加密后”两个阶段，用户可以根据不同的组网需求灵活选择其它业务（例如NAT、QoS）实施的阶段。例如，如果用户希望对IPsec封装前的报文应用QoS，则可以在IPsec虚拟隧道接口上应用QoS策略；如果希望对IPsec封装后的报文应用QoS，则可以在物理接口上应用QoS策略。</li></ul><p>使用IPSec虚拟隧道口封装解封装报文如图所示：<br><img src="https://rancho333.github.io/pictures/ipsec_enca.png"></p><h3 id="IKE"><a href="#IKE" class="headerlink" title="IKE"></a>IKE</h3><p>在实施IPSec的过程中，可以使用IKE(internet key exchange)协议来建立SA<br>IKE是个混个协议，其中包含部分Oakley协议，内置在ISAKMP(internet security association and key management protocol)协议中的部分SKEME协议，所以IKE也可以写为ISAKMP/Oakley，它是针对密钥安全，用来保证密钥的安全传输、交换以及存储，主要是对密钥进行操作，并不对用户的实际数据进行操作。</p><p>IKE不是在网络上直接传输密钥，而是通过一系列数据的交换，最终计算出双方共享的密钥，并且即使第三者截获了双方用于计算密钥的所有交换数据，也不足以计算出真正的密钥。</p><p>IKE具有一套自保护机制，可以在不安全的网络上安全的认证身份、分发密钥、建立IPSec SA。</p><p>数据认证有如下两方面概念：</p><ul><li>身份认证：身份认证确认通信双方的身份。支持两种认证方法：预共享密钥(pre-shared-key)认证基于PKI的数字签名(rsa-signature)认证。</li><li>身份保护：身份数据在密钥产生之后加密传送，实现了对身份数据的保护。</li></ul><p>DH(Diffie-Hellman，交换及密钥分发)算法是一种公共密钥算法。通信双方在不传输密钥的情况下通过交换一些数据，计算出共享的密钥。即使第三者截获了双方用于计算密钥的所有交换数据，由于其复杂度很高，不足以计算出真正的密钥。所以，DH交换技术可以保证双方能够安全地获得公有信息。</p><p>PFS(perfect forward secrecy，完善的前向安全性)特性是一种安全特性，指一个密钥被破解，并不影响其它密钥的安全性，因为这些密钥之间没有派生关系。对于IPSec，是通过在IKE阶段2协商中增加一次密钥交换来实现的。PFS特性时DH算法保障的。</p><p>IKE的交换过程：<br>通过IKE方式建立的SA实际有两组，分别为IKE SA和IPSec SA, 两个SA分别定义了如何保护密钥及如何保护数据，其实这两个SA都是IKE建立起来的，所以IKE的整个运行过程拆分成两个phase。</p><ul><li><p>phase one：通信各方彼此间建立一个已通过身份认证和安全保护的通道，即建立一个ISAKMP SA。第一阶段有主模式(main mode)和野蛮模式(aggressive mode)两种IKE交换方式。协商的安全策略包括：</p><ul><li>认证方式(authentication)：pre-shard keys, public key infrastructure，RSA encrypted nonce，默认是PKI</li><li>加密算法：加密数据</li><li>Hash算法(HMAC)：生成摘要，完整性认证</li><li>密钥算法：计算密钥的方式</li><li>lifetime</li><li>NAT穿越(NAT traversal): 默认开启，无须手工配置</li></ul></li><li><p>phase two：用在第一阶段建立的安全隧道为IPSec协商安全服务，即为IPSec协商具体的SA，建立最终的IP数据安全传输的IPSec SA。同样需要协商出一套安全策略，包括：</p><ul><li>加密算法</li><li>hash算法(HMAC)</li><li>lifetime</li><li>IPSec mode：tunnel mode和transport mode，默认是tunnel mode和transport</li></ul></li></ul><p>从上可看出IPSec SA中没有协商认证方式和密钥算法，因为IKE SA中已经认证过了，所以后面不需要再认证，并且密钥是在IKE SA已经完成的。</p><p>IPSec与IKE的关系如下：<br><img src="https://rancho333.github.io/pictures/ipsec_ike.png"></p><ul><li>IKE是UDP之上的一个应用层协议，是IPSec的信令协议</li><li>IKE为IPSec协商建立SA，并把建立的参数及生成的密钥交给IPSec</li><li>IPSec使用IKE建立的SA对IP报文加密或认证处理</li></ul><h1 id="IPSec实验"><a href="#IPSec实验" class="headerlink" title="IPSec实验"></a>IPSec实验</h1><h2 id="IOS中关于IPSec的一些配置概念"><a href="#IOS中关于IPSec的一些配置概念" class="headerlink" title="IOS中关于IPSec的一些配置概念"></a>IOS中关于IPSec的一些配置概念</h2><ul><li><p>transform set<br>transform set是一组算法集合，通过它来定义使用怎样的算法来封装数据包，比如之前所说的ESP封装，AH封装都需要通过transform set来定义，还可以定义其它一些加密算法以及HMAC算法。通过transform set，就可以让用户来选择保护数据的强度，因此transform set就是定义数据包是受到怎样的保护。也就是ipsec的加密、完整性算法，以及ipsec的模式。</p></li><li><p>crypto isakmp<br>  定义IKE SA的协商参数</p></li><li><p>crypto map<br>Crypto map是思科的IOS中配置IPSec的组件，执行两个主要功能：</p><ul><li>选择需要加密处理的数据（通过ACL匹配）</li><li>定义数据加密的策略以及数据发往的对端<br>crypto map将之前定义好的transform set和isakmp绑定起来，形成完整的ipsec配置，应用到接口就完成配置了。</li></ul></li></ul><p>crypto map中的策略是分组存放的，以序号区分，如果一个crypto map有多个策略组，则最低号码的组有限。当配置完crypto map后，需要应用到接口上才能生效，并且一个接口只能应用一个crypto map.</p><p>crypto map还分为静态map和动态map，简单区分，就是数据发往的对端是否固定，如果是动态map，那么对端是不固定的，在存在隧道时，也就表示隧道的终点时不固定的，但源始终是自己。</p><h2 id="eveng仿真实验"><a href="#eveng仿真实验" class="headerlink" title="eveng仿真实验"></a>eveng仿真实验</h2><p>IPSec vpn配置时，有如下几个重要步骤：</p><ul><li>配置IKE(ISAKMP)策略</li><li>定义认证标识</li><li>配置IPSec transform</li><li>定义感兴趣流量</li><li>创建crypto map</li><li>将crypto map应用于接口</li></ul><p>实验拓扑如图所示(lan-to-lan vpn)：<br><img src="https://rancho333.github.io/pictures/ipsec_topology.png"></p><p>拓扑说明如下：<br>vpc4和vpc5分别属于两个私网，网关分别指向R1和R3, R2仿真internet, R2上不配置任何路由，只负责和R1、R3之间直连链路的通信。R1和R3上配置默认路由指向R2。因为R2上没有VPC4、VPC5网段的路由，所以两者之间不通。</p><p>基础网络环境配置如下(ip和默认路由)：</p><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">VPC4</a></li><li class="tab"><a href="#tab-2">R1</a></li><li class="tab"><a href="#tab-3">R2</a></li><li class="tab"><a href="#tab-4">R3</a></li><li class="tab"><a href="#tab-5">VPC5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VPC4&gt; show</span><br><span class="line"></span><br><span class="line">NAME   IP&#x2F;MASK              GATEWAY                             GATEWAY</span><br><span class="line">VPC4   14.1.1.4&#x2F;24          14.1.1.1</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 14.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 12.1.1.2       &#x2F;&#x2F; 默认路由指向internet</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-3"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 23.1.1.2 255.255.255.0</span><br><span class="line">!</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-4"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 23.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 35.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 23.1.1.2       &#x2F;&#x2F; 默认路由指向internet</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-5"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VPC5&gt; show</span><br><span class="line"></span><br><span class="line">NAME   IP&#x2F;MASK              GATEWAY                             GATEWAY</span><br><span class="line">VPC5   35.1.1.5&#x2F;24          35.1.1.3</span><br></pre></td></tr></table></figure></div></div></div><p>检测网络的连通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VPC5&gt; ping 35.1.1.3 -c 1</span><br><span class="line"></span><br><span class="line">84 bytes from 35.1.1.3 icmp_seq&#x3D;1 ttl&#x3D;255 time&#x3D;0.356 ms</span><br><span class="line"></span><br><span class="line">VPC5&gt; ping 23.1.1.2 -c 1</span><br><span class="line"></span><br><span class="line">23.1.1.2 icmp_seq&#x3D;1 timeout         &#x2F;&#x2F; R2上没有VPC5的回程路由，所以不通</span><br></pre></td></tr></table></figure><p>接下来配置IPSec vpn：</p><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">R1</a></li><li class="tab"><a href="#tab-2">R3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 配置IKE SA策略</span><br><span class="line">crypto isakmp policy 1            &#x2F;&#x2F; 策略优先级</span><br><span class="line"> encr 3des                         &#x2F;&#x2F; 加密方式</span><br><span class="line"> hash md5                           &#x2F;&#x2F; 报文摘要算法，报文完整性验证</span><br><span class="line"> authentication pre-share           &#x2F;&#x2F; 认证方式</span><br><span class="line"> group 2                            &#x2F;&#x2F; 密钥算法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义认证标识</span><br><span class="line">crypto isakmp key 0 rancho address 23.1.1.3       &#x2F;&#x2F; 因为认证方式为pre-share, 所以需要定义认证密码，此处密码为&#96;rancho&#96;， 对端地址为23.1.1.3，双方密码必须一致。0表示密码在show run中明文显示</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  定义 ipsec transform</span><br><span class="line">crypto ipsec transform-set rancho esp-3des esp-sha-hmac     &#x2F;&#x2F; transform组名字为&#96;rancho&#96;，只采用esp协议加密认证，加密方式为3des，校验方式为sha-hmac</span><br><span class="line"> mode tunnel            &#x2F;&#x2F; IPSec默认模式就是tunnel，不需要配置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义感兴趣的数据流</span><br><span class="line">access-list 100 permit ip 14.1.1.0 0.0.0.255 35.1.1.0 0.0.0.255     &#x2F;&#x2F; 两端的私网网段</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 定义crypto map</span><br><span class="line">crypto map rancho 1 ipsec-isakmp    &#x2F;&#x2F; map名字叫&#96;rancho&#96;，序号为1，可以有多个，越小越优</span><br><span class="line"> set peer 23.1.1.3                  &#x2F;&#x2F; 隧道对端为23.1.1.3</span><br><span class="line"> set transform-set rancho           &#x2F;&#x2F; 调用名为rancho的transform 组</span><br><span class="line"> match address 100                  &#x2F;&#x2F; 指定ACL 100为保护的流量</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 将crypto应用在接口上</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> crypto map rancho                  &#x2F;&#x2F; 在eth0&#x2F;0上应用名为rancho的crypto map</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">crypto isakmp policy 1</span><br><span class="line"> encr 3des</span><br><span class="line"> hash md5</span><br><span class="line"> authentication pre-share</span><br><span class="line"> group 2</span><br><span class="line">crypto isakmp key rancho address 12.1.1.1       </span><br><span class="line">!</span><br><span class="line">crypto ipsec transform-set rancho esp-3des esp-sha-hmac </span><br><span class="line"> mode tunnel</span><br><span class="line">!</span><br><span class="line">crypto map rancho 1 ipsec-isakmp </span><br><span class="line"> set peer 12.1.1.1</span><br><span class="line"> set transform-set rancho </span><br><span class="line"> match address 100</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> crypto map rancho</span><br><span class="line">!</span><br><span class="line">access-list 100 permit ip 35.1.1.0 0.0.0.255 14.1.1.0 0.0.0.255</span><br></pre></td></tr></table></figure></div></div></div><p>至此，IPSec隧道两端的配置就完成了。但是IKE SA并没有建立：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">R1#show crypto isakmp peers </span><br><span class="line">R1#show crypto isakmp sa    </span><br><span class="line">IPv4 Crypto ISAKMP SA</span><br><span class="line">dst             src             state          conn-id status</span><br><span class="line"></span><br><span class="line">IPv6 Crypto ISAKMP SA</span><br><span class="line"></span><br><span class="line">R1#</span><br></pre></td></tr></table></figure><p>需要业务流量来触发IKE SA的建立：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VPC4&gt; ping 35.1.1.5</span><br><span class="line">35.1.1.5 icmp_seq&#x3D;1 timeout</span><br><span class="line">84 bytes from 35.1.1.5 icmp_seq&#x3D;2 ttl&#x3D;62 time&#x3D;2.828 ms</span><br></pre></td></tr></table></figure><p>在R2的eth0上抓包：<br><img src="https://rancho333.github.io/pictures/ipsec_esp_packet.png"></p><p>可以看到先通过IKE建立SA，之后的ICMP报文封装在ESP报文中，在隧道两端传递。</p><p>最后查看一下配置和状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看isakmp policy策略</span><br><span class="line">R1#show crypto isakmp policy </span><br><span class="line"></span><br><span class="line">Global IKE policy</span><br><span class="line">Protection suite of priority 1</span><br><span class="line">encryption algorithm:Three key triple DES</span><br><span class="line">hash algorithm:Message Digest 5</span><br><span class="line">authentication method:Pre-Shared Key</span><br><span class="line">Diffie-Hellman group:#2 (1024 bit)</span><br><span class="line">lifetime:86400 seconds, no volume limit</span><br><span class="line"></span><br><span class="line">R1#show crypto isakmp key           &#x2F;&#x2F; 查看phase one认证密码</span><br><span class="line">R1#show crypto isakmp sa            &#x2F;&#x2F; 查看IKE SA</span><br><span class="line">R1#show crypto isakmp peers         &#x2F;&#x2F; 查看IKE peers</span><br><span class="line">R1#show crypto ipsec transform-set      &#x2F;&#x2F; 查看IPSec transform</span><br><span class="line">R1#show crypto ipsec sa                 &#x2F;&#x2F; 查看IPSec SA</span><br><span class="line">R1#show crypto map                  &#x2F;&#x2F; 查看crypto map</span><br></pre></td></tr></table></figure><h1 id="关于IPSec使用的一些思考"><a href="#关于IPSec使用的一些思考" class="headerlink" title="关于IPSec使用的一些思考"></a>关于IPSec使用的一些思考</h1><p>IPsec具有以下优点：</p><ul><li>支持IKE，可实现密钥的自动协商功能，减少密钥协商的开销。可以通过IKE建立和维护SA的服务，简化了IPsec的使用和管理</li><li>所有使用IP协议进行数据传输的应用系统和服务都可以使用IPsec，而不必对这些应用系统和服务本身做任何修改</li></ul><p>IPsec具有以下缺点：</p><ul><li>安全服务协议AH和ESP所提供的功能重叠率非常高，虽然IPsec最新版本规定AH为可选协议，但并没有解决IPsec组合复杂度的问题。从而导致IPsec的工程实现以及部署维护的成本依旧非常高。</li><li>安全服务协议的工作模式众多：传输模式、隧道模式，在加上两种协议的组合，导致IPsec的复杂度高。</li></ul><p>协议包含有太多的选项和太多的灵活性，做同样或类似的事有几种方式，从而引入的复杂度会导致工程实现的系统非常复杂，存在的安全漏洞也就非常多，安全评估也就非常困难，从某种意义上讲，复杂是安全最大的敌人。</p><p>  从工作模式的角度上看，IPsec的工作模式分为传输模式和隧道模式，而这两种工作模式结合AH与ESP以及AH和ESP的组合，又会衍生出更多的工作模式，导致IPsec在工程实现、维护上大大加重了其复杂度。</p><p>  对于IPsec的使用场景与传输模式：</p><ul><li>传输模式适用于主机间应用场景(如果在网关上使用，那么网关视作主机，此时用于网络管理)</li><li>隧道模式使用与带有网关的应用场景</li></ul><p>  传输模式是为高级协议(IP的payload)提供保护而设计的，隧道模式是为整个IP分组提供保护设计的。</p><p>  可以淘汰传输模式。</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/vpn/">vpn</category>
      
      
      <comments>https://rancho333.github.io/2022/08/01/IPSec%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GRE简述</title>
      <link>https://rancho333.github.io/2022/07/29/GRE%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/29/GRE%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Fri, 29 Jul 2022 02:12:43 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;承接上文&lt;a href=&quot;https://rancho333.github.io/2022/07/28/vpn%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/&quot;&gt;vpn技术简述&lt;/a&gt;，本文探讨下GRE(general routing encapsulation),通用路由封装技术， GRE是VPN的一种简单实现。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>承接上文<a href="https://rancho333.github.io/2022/07/28/vpn%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/">vpn技术简述</a>，本文探讨下GRE(general routing encapsulation),通用路由封装技术， GRE是VPN的一种简单实现。</p><span id="more"></span><h1 id="GRE介绍"><a href="#GRE介绍" class="headerlink" title="GRE介绍"></a>GRE介绍</h1><p>在探讨一种网络技术之前，必然需要了解该技术的应用背景，解决什么问题。internet虽然统一了今天的网络世界，但是私有网络，异构网络依然存在，他们有着通过internet互联的需求，这就是GRE需要解决的问题。</p><ul><li>私有网络无法通过internet互通</li><li>异构网络(IPX、AppleTalk)之间无法通过internet进行通信</li><li>私网之间部署的动态路由无法跨越internet<br>好比送快递，比如某快递公司只有北京上海的分部，没有两地之间互通的能力，这时把需要互通的包裹给顺丰，顺丰就是internet, 某快递就是私有网络或异构网络。</li></ul><p>GRE可以把某种网络的报文封装在以太网上进行传输，1994年GRE问世，RFC编号是RFC1701和RFC1702.</p><p>任何一种封装技术，其基本构成要素都可以分成三个部分：乘客协议、封装协议、传输协议。GRE中乘客协议可以是ip/ipx, 封装协议自然就是GRE自身，传输协议是ip。</p><p>gre的封装过程可以分成两步，第一步是在乘客协议之前加上gre报文头，第二步是在第一步的基础上添加新的ip报文头。</p><p>在产品实现的角度，上述的封装过程是通过一个逻辑接口来实现的，这个逻辑接口是tunnel接口，在下文的实验中会讲到。封装的基本过程如下图所示：<br><img src="https://rancho333.github.io/pictures/gre_encapsulation.png"></p><ul><li>私网流量到达路由器入接口，路由器查询路由表对此流量进行转发</li><li>路由器根据路由查找结果，将此流量引导到tunnel接口进行gre封装</li><li>封装后的gre报文再次查找路由表进行流量转发</li><li>路由器根据路由查找结果，找到出接口，将流量转发到internet</li></ul><p>对于解封装，需要注意的是，当gre报文到达隧道终点时，tunnel通过判断运输协议(IP报文)的protocol字段是否为47来判定报文是不是gre报文，如果是，解封装，然后转发或路由。</p><h2 id="GRE报文说明"><a href="#GRE报文说明" class="headerlink" title="GRE报文说明"></a>GRE报文说明</h2><p>gre报文如图所示。<br><img src="https://rancho333.github.io/pictures/gre_packet.png"></p><p>GRE的报文很简单，注意其中<code>recursion</code>字段，该字段表示GRE封装的层数，完成一次GRE封装加1,如果大于3则丢弃报文，这是为了防止对GRE报文的无限封装。</p><h1 id="GRE实验"><a href="#GRE实验" class="headerlink" title="GRE实验"></a>GRE实验</h1><p>实验拓扑如下：<br><img src="https://rancho333.github.io/pictures/gre_topology.png"></p><p>R1和R3上分别创建loopback接口，它们之间通过gre进行通信。隧道的逻辑端口分别是R1和R2上创建的<code>tunnel 0</code>, 对于需要通过GRE进行封装的报文，需要保证目的ip的下一跳是<code>tunnel 0</code>；隧道物理端口分别是R1和R2的eth0接口，需要保证两者之间路由可达。具体配置如下：</p><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">R1</a></li><li class="tab"><a href="#tab-2">R2</a></li><li class="tab"><a href="#tab-3">R3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0           &#x2F;&#x2F; 创建lp0接口</span><br><span class="line">!</span><br><span class="line">interface Tunnel0                              &#x2F;&#x2F; 创建tunnel逻辑端口</span><br><span class="line"> ip address 13.1.1.1 255.255.255.0              &#x2F;&#x2F; 配置tunnel ip地址</span><br><span class="line"> tunnel source Ethernet0&#x2F;0                      &#x2F;&#x2F; 配置tunnel源</span><br><span class="line"> tunnel destination 23.1.1.3                    &#x2F;&#x2F; 配置tunnel目的</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 3.3.3.3 255.255.255.255 Tunnel0        &#x2F;&#x2F; 静态路由，乘客报文与逻辑隧道之间路由可达</span><br><span class="line">ip route 23.1.1.0 255.255.255.0 12.1.1.2        &#x2F;&#x2F; 静态路由，隧道物理端口之间路由可达</span><br><span class="line">!</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 23.1.1.2 255.255.255.0</span><br><span class="line">!</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-3"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Loopback0                             &#x2F;&#x2F; 说明如R1</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 13.1.1.3 255.255.255.0</span><br><span class="line"> tunnel source Ethernet0&#x2F;0</span><br><span class="line"> tunnel destination 12.1.1.1</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 23.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 Tunnel0</span><br><span class="line">ip route 12.1.1.0 255.255.255.0 23.1.1.2</span><br></pre></td></tr></table></figure></div></div></div><p>配置的关键在于将需要进入隧道的流量引导到隧道逻辑端口<code>tunnel 0</code>(路由下一跳是tunnel), 然后保证隧道物理端口之间的路由可达。对于<code>tunnel 0</code>的路由，使用ospf来代替则是：</p><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">R1</a></li><li class="tab"><a href="#tab-2">R3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router ospf 110</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0         &#x2F;&#x2F; 将需要gre封装的流量加入ospf计算</span><br><span class="line"> network 13.1.1.0 0.0.0.255 area 0      &#x2F;&#x2F; 将tunnel 0将入ospf计算</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router ospf 110</span><br><span class="line"> network 3.3.3.3 0.0.0.0 area 0</span><br><span class="line"> network 13.1.1.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure></div></div></div><p>注意此时tunnel两端需要配置成一个网段。查看一下ospf的邻居状态及路由表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R3#show ip ospf neighbor </span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">1.1.1.1           0   FULL&#x2F;  -        00:00:35    13.1.1.1        Tunnel0</span><br><span class="line"></span><br><span class="line">R3#show ip route ospf | begin 1.1.1.1</span><br><span class="line">O        1.1.1.1 [110&#x2F;1001] via 13.1.1.1, 00:03:32, Tunnel0</span><br></pre></td></tr></table></figure><p>对于ospf报文的gre封装：<br><img src="https://rancho333.github.io/pictures/gre_ospf.png"></p><p>可以看到传输协议的源目地址就是隧道物理端口的地址，ospf hello报文的源地址是隧道逻辑端口tunnel的地址。</p><p>测试两个loopback接口之间的连通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R3#ping 1.1.1.1 source 3.3.3.3</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 1.1.1.1, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 3.3.3.3 </span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;1 ms</span><br></pre></td></tr></table></figure><p>对于icmp报文的gre封装：<br><img src="https://rancho333.github.io/pictures/gre_ping.png"></p><h2 id="gre实验的几个问题"><a href="#gre实验的几个问题" class="headerlink" title="gre实验的几个问题"></a>gre实验的几个问题</h2><p>cisco的tunnel默认封装类型就是gre，不用特殊指定。华为tunnel的封装类型需要指定。</p><p>tunnel接口的IP地址是否必须要配置？隧道两端的tunnel接口ip地址是否有所关联？tunnel接口使用的公网ip还是私网ip?</p><p>tunnel接口是一个三层接口，需要路由，所以必须配置ip地址，否则不能up. 从上面的抓包来看，只有使用ospf协议时，tunnel的ip才会体现到乘客协议中，走静态路由时则没有任何存在感，考虑到将tunnel看成一个虚拟的直连链接，建议tunnel两端配置成同一网段(否则ospf时邻居无法建立)；tunnel的ip不会出现在传输协议中，所以设置成私网ip即可。</p><p>tunnel是一个无状态的隧道，怎么感知对方的状态呢？否则会造成数据黑洞的问题。可以在tunnel接口下开启<code>keepalive</code>功能，tunnel会发送一个保活报文给对端，解封装后再路由回来，这样就可以检测链路以及对端设备是否正常。保活报文抓包如下：<br><img src="https://rancho333.github.io/pictures/gre_keepalive.png"></p><p>可以看到传输协议与乘客协议的报文源目地址刚好是相反的，即R3的eth0发出的keepalive，R1的eth0收到之后解封装再路由，又会重新发送给R3的eth0。假设R1上的tunnel down(或者ip没配)，那么就无法完成解封装。</p><p>最后一个问题是安全性的问题。我们在抓包过程中可以直接看到乘客协议的报文内容，比如我们知道乘客协议是icmp还是ospf等，这是不安全。GRE over IPSec可以解决这个问题。后面会接续研究。</p><p>参考资料：<br><a href="https://forum.huawei.com/enterprise/zh/thread-256801.html">强叔侃墙 VPN篇 GRE</a></p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/vpn/">vpn</category>
      
      
      <comments>https://rancho333.github.io/2022/07/29/GRE%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vpn技术简述</title>
      <link>https://rancho333.github.io/2022/07/28/vpn%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2022/07/28/vpn%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 28 Jul 2022 08:11:52 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;无论是访问外网资源(google，youtube等)，还是居家办公访问公司内网，我们都需要使用到vpn这个东东。VPN(virtual private network)是指在公用网络上建立一个私有的、专用的虚拟通信网络。本质就是建立隧道传递原有的业务流量，在隧道两端进行业务流量的封装与解封装，隧道两端则是需要互通的两个子网。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>无论是访问外网资源(google，youtube等)，还是居家办公访问公司内网，我们都需要使用到vpn这个东东。VPN(virtual private network)是指在公用网络上建立一个私有的、专用的虚拟通信网络。本质就是建立隧道传递原有的业务流量，在隧道两端进行业务流量的封装与解封装，隧道两端则是需要互通的两个子网。</p><span id="more"></span><h1 id="vpn技术的一些分类"><a href="#vpn技术的一些分类" class="headerlink" title="vpn技术的一些分类"></a>vpn技术的一些分类</h1><p>有几种角度的分类方式，其一是根据建设单位(运营商还是企业自身)来分类：</p><ul><li>租用运营商VPN专线搭建企业VPN网络：主要是MPLS VPN, 相较于传统的专线(E1、SDH专线)更便宜</li><li>用户企业自建VPN网络：基于internet建立企业vpn网络，具体技术包括GRE、L2TP、IPSec、SSLVPN等。</li></ul><p>根据组网方式的不同：<br>本质就是隧道端点位置的不同。记住两个点：加密点/隧道点 和 通信点</p><ul><li>远程访问VPn（access VPN）：适合居家办公场景，一般在PC上安装客户端即可，隧道端点位于PC上，也叫做remote access VPN。加密点/隧道点和通信点都在PC或手机等设备上。</li><li>局域网到局域网的vpn(也称网关到网关的vpn)：适用于异地机构的互联，隧道端点位于网络设备上，也叫做site-to-site VPN，这里有两种分类。加密点/隧道点和通信点在网关、防火墙等专门网络设备上。<ul><li>一种叫intranet-based site-to-site, 即两端的局域网都属于一家公司，把几个私网连接在一起</li><li>一种叫extranet-based site-to-site, 即两端的局域网不属于一家公司，只分享一些固定的资源，而其它资源保持私有</li></ul></li></ul><p>按照vpn技术实现的网络层次进行分类：</p><ul><li>基于数据链路层的VPN：L2TP、L2F、PPTP。其中L2F和PPTP已经基本上被L2TP替代了</li><li>基于网络层的VPN：IPSec、GRE</li><li>基于应用层的VPN：SSL VPN</li></ul><p>基于internet的VPN技术有一个共同的特点就是必须解决网络安全的问题。</p><h1 id="VPN关键技术点"><a href="#VPN关键技术点" class="headerlink" title="VPN关键技术点"></a>VPN关键技术点</h1><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><p>隧道技术是VPN的基本技术，类似于点到点的连接技术。它的基本过程就是在数据进入源VPN网关后，将数据封装后通过internet传输到目的vpn网关后再对数据进行解封装。可初略认为vpn网关之间是直连的，是一条隧道，封装的报文不关心具体传输路径。封装后的报文src ip是源vpn网关，dest ip是目的vpn网关。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>移动办公等场景下，需要对用户的身份进行验证。</p><ul><li>GRE不支持认证</li><li>L2TP依赖于PPP提供的认证技术。</li><li>IPSec：通过IKEv2拨号时，支持进行EAP认证。接入用户的用户名和密码可以本地认证，也可以通过RADIUS服务器认证。认证通过后再给用户分配内部的IP地址，通过此IP地址对用户进行授权和管理。另外IPSec还支持数据源认证</li><li>SSL VPN: 支持本地认证，证书认证和服务器认证。主要是对服务器进行身份认证，确认web网页的合法性。</li></ul><h2 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h2><p>internet上传输的报文如果不做加密处理，都是处于裸奔状态，比如我们通过wireshark抓包就可以直接读取到报文内容。加密对象有数据报文和协议报文之分，能够实现协议报文和数据报文都加密的协议安全系数更高。</p><ul><li>GRE和L2TP本身不提供加密技术，所以通常结合IPSec协议一起使用，而IPSec只支持单播封装，很好互补</li><li>IPSec：支持数据报文和协议报文加密。IPSec一般采用对称密钥算法加密数据。</li><li>SSL VPN: 支持数据报文和协议报文加密。SSL VPN采用非对称密钥算法加密数据(公钥加密，私钥解密)。</li></ul><h2 id="数据验证技术"><a href="#数据验证技术" class="headerlink" title="数据验证技术"></a>数据验证技术</h2><p>数据验证就是对收到的报文进行验货。比如常用MD5验证文件的完整性。在收发两端都对报文进行验证，只有摘要一致的报文才被认可。</p><ul><li>GRE：本身只提供简单的校验和验证及关键字验证。</li><li>L2TP：不提供数据验证技术</li><li>IPSec: 支持对数据进行完整性验证和数据源验证。在IPSec中验证和加密通常一起使用，对加密后的报文HMAC(keyed-hash message authentication code)生成摘要</li><li>SSL VPN：支持对数据进行完整性验证和数据源验证。SSL VPN采用公钥体质，利用Hash算法生成摘要，再用私钥加密摘要生成数字签名，利用公钥进行解密。利用公钥和私钥的一一关系可以对数据源进行认证。</li></ul><p>总结一下这几种vpn技术的应用场景：</p><p>| GRE | L2TP | IPSec | SSL VPN |<br>| :— | :— | :— | :— | :— |<br>| 作用范围 | IP层及以上数据 | IP层及以上数据 | IP层及以上数据 | 应用层特定数据 |<br>| 适用场景 | internet VPN | access vpn | internet vpn; accese | access vpn |<br>| 身份认证 | 不支持 | 支持，基于PPP的chap、pap、eap认证| 支持，采用IP或ID+口令或证书进行数据源认证；IKEv2拨号方式采用EAP认证进行用户身份认证 | 支持，用户名+口令+证书对服务器进行认证，也可进行双向认证 |<br>| 加密技术 | 不支持 | 不支持 | 支持 | 支持 |<br>| 数据验证 | 支持，校验和验证、关键字验证 | 不支持 | 支持 | 支持 |<br>| 如何使用 | GRE over IPSec | L2TP over IPSec | 单独使用 | SSL VPN |</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/vpn/">vpn</category>
      
      
      <comments>https://rancho333.github.io/2022/07/28/vpn%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
