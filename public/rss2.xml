<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rancho Blog</title>
    <link>https://rancho333.github.io/</link>
    
    <atom:link href="https://rancho333.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>No pain, no gain!</description>
    <pubDate>Tue, 21 Dec 2021 07:42:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>vrf简述及仿真实验</title>
      <link>https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</link>
      <guid>https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</guid>
      <pubDate>Wed, 20 Oct 2021 05:14:53 GMT</pubDate>
      
      <description>&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFvrf&quot;&gt;什么是VRF&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E7%9A%84%E4%BD%9C%E7%94%A8&quot;&gt;vrf的作用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C&quot;&gt;VRF仿真实验&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E8%A7%A3%E5%86%B3%E5%9C%B0%E5%9D%80%E9%87%8D%E5%8F%A0--ip%E9%9A%94%E7%A6%BB&quot;&gt;VRF解决地址重叠 &amp;amp;&amp;amp; IP隔离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E8%B7%AF%E7%94%B1%E9%9A%94%E7%A6%BB%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2&quot;&gt;VRF路由隔离以及路由泄露&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vrf%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2%E5%AE%9E%E9%AA%8C%E5%A4%B1%E8%B4%A5&quot;&gt;vrf路由泄露实验失败&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;</description>
      
      
      
      <content:encoded><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFvrf">什么是VRF</a><ul><li><a href="#vrf%E7%9A%84%E4%BD%9C%E7%94%A8">vrf的作用</a></li></ul></li><li><a href="#vrf%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C">VRF仿真实验</a><ul><li><a href="#vrf%E8%A7%A3%E5%86%B3%E5%9C%B0%E5%9D%80%E9%87%8D%E5%8F%A0--ip%E9%9A%94%E7%A6%BB">VRF解决地址重叠 &amp;&amp; IP隔离</a></li><li><a href="#vrf%E8%B7%AF%E7%94%B1%E9%9A%94%E7%A6%BB%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2">VRF路由隔离以及路由泄露</a><ul><li><a href="#vrf%E8%B7%AF%E7%94%B1%E6%B3%84%E9%9C%B2%E5%AE%9E%E9%AA%8C%E5%A4%B1%E8%B4%A5">vrf路由泄露实验失败</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="什么是VRF"><a href="#什么是VRF" class="headerlink" title="什么是VRF"></a>什么是VRF</h1><p>VRF(virtual routing and forwarding)是一种允许在单台路由器上有多个路由表的技术。VRFs的典型使用是与MPLS VPNs结合。没有使用MPLS的VRFs称为VRF lite.</p><p>在Linux上，VRF设备通过与ip规则结合在Linux网络栈中提供创建虚拟路由和转发的能力。一个典型的应用场景就是多租户各自需要独立的路由表，少数场景下需要不同的默认路由。</p><p>程序通过socket与不同的VRF设备绑定感知VRF。数据包通过socket使用与VRF设备相关的路由表。VRF设备实现的一个重要特征就是它只影响L3而对L2工具（比如LLDP）没有影响(它们是全局的而不必运行在每一个VRF域中).这种设计允许使用更高优先级的ip rules(policy based routing, PBR)优先于VRF设备规则，根据需要引导特定流量。此外，VRF设备允许VRFs嵌套在namespace中。namespace提供物理层的接口隔离，vlan提供L2的隔离，vrf提供L3的隔离。VRF设备是使用关联的路由表创建的。</p><p>简而言之，VRF在逻辑上将一个路由器模拟成多台路由器，是一种网络虚拟化技术,VRF是路由器的虚拟化，VLAN是交换机的虚拟化，trunk是对网络连接的虚拟化。VDOM(virtual domain)是防火墙的虚拟化, VM是服务器的虚拟化。</p><p>注意：一个L3接口同一时间只能属于一个VRF域</p><h2 id="vrf的作用"><a href="#vrf的作用" class="headerlink" title="vrf的作用"></a>vrf的作用</h2><p>两点：<br>    1. 流量隔离：隔离不同的vpn用户,解决地址重叠问题<br>    2. 网络虚拟化</p><h1 id="VRF仿真实验"><a href="#VRF仿真实验" class="headerlink" title="VRF仿真实验"></a>VRF仿真实验</h1><p>针对vrf的路由隔离和解决地址重叠这两个特性，在GNS3上面做两个简单的仿真实验。</p><h2 id="VRF解决地址重叠-amp-amp-IP隔离"><a href="#VRF解决地址重叠-amp-amp-IP隔离" class="headerlink" title="VRF解决地址重叠 &amp;&amp; IP隔离"></a>VRF解决地址重叠 &amp;&amp; IP隔离</h2><p>实验拓扑如下：<br><img src="https://rancho333.github.io/pictures/vrf_overlap_topo.png"><br>其中，R1、R2、R4、R5模拟主机，R3上面创建两个<code>vrf</code>域, R1、R2属于<code>vrf-2</code>, R4、R5属于<code>vrf-1</code>。实验预期是R1可以ping通R2，R4可以ping通R5。<br>5台设备的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">R1&#x2F;R3:</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> no shutdown</span><br><span class="line"> ip address 192.168.1.2 255.255.255.0</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.1.1                # 模拟主机，配置网关</span><br><span class="line"></span><br><span class="line">R2&#x2F;R4:</span><br><span class="line">interface Ethernet0&#x2F;3</span><br><span class="line"> no shutdown</span><br><span class="line"> ip address 202.100.10.2 255.255.255.0</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 202.100.10.1</span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">ip vrf vrf-1                                        # 创建vrf-1</span><br><span class="line">!   </span><br><span class="line">ip vrf vrf-2                                        # 创建vrf-2</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-1                            # 接口加入vrf-1</span><br><span class="line"> ip address 192.168.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-2                            # 接口加入vrf-2</span><br><span class="line"> ip address 192.168.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;2</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-1                            # 接口加入vrf-1</span><br><span class="line"> ip address 202.100.10.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0&#x2F;3</span><br><span class="line"> no shutdown</span><br><span class="line"> ip vrf forwarding vrf-2                            # 接口加入vrf-2</span><br><span class="line"> ip address 202.100.10.1 255.255.255.0</span><br></pre></td></tr></table></figure><p>查看R3的路由表：<br><img src="https://rancho333.github.io/pictures/vrf_overlap_route.png"><br>路由表结果与预期相符，默认路由表中没有内容，vrf-1和vrf-2中分别是各自接口的直连路由。</p><p>同时在R2和R5上抓包，在R1和R3上ping 202.100.10.2，发现只有在相同的vrf域中才能收到icmp(即R1可以ping通R2，R4可以ping通R5)，实验结果符合预期。</p><h2 id="VRF路由隔离以及路由泄露"><a href="#VRF路由隔离以及路由泄露" class="headerlink" title="VRF路由隔离以及路由泄露"></a>VRF路由隔离以及路由泄露</h2><p>VRF可以隔离不同VPN用户之间的路由，即可以实现L3层级的隔离，同时通过vrf-leak可以实现不同vrf之间的互通。路由隔离与泄露使用相同的拓扑：<br><img src="https://rancho333.github.io/pictures/vrf_separation_topo.png"><br>配置参照<code>VRF解决地址重叠</code>的实验，根据拓扑修改对应端口，以及模拟主机的4台路由器上修改默认网关即可。</p><p>查看R3上的路由表，默认路由表依然为空，这里就不看了：<br><img src="https://rancho333.github.io/pictures/vrf_separation_route.png"><br>VRF分别包含各自网段的路由。</p><p>在R2上分别ping R1和R4，结果如下：<br><img src="https://rancho333.github.io/pictures/r2_ping_separation.png"><br>R2可以ping通同一路由域中的R1，不能ping通其它路由域中的R4，实验结果符合预期。</p><h3 id="vrf路由泄露实验失败-后面有机会再搞吧-大概率是配置错了"><a href="#vrf路由泄露实验失败-后面有机会再搞吧-大概率是配置错了" class="headerlink" title="vrf路由泄露实验失败, 后面有机会再搞吧(大概率是配置错了)"></a>vrf路由泄露实验失败, 后面有机会再搞吧(大概率是配置错了)</h3><p>vrf的路由泄露有三种方向，分别为：</p><ul><li>默认vrf——&gt;vrf</li><li>vrf——&gt;vrf</li><li>vrf——&gt;默认vrf<br>默认vrf即为全局路由表。</li></ul><p>vrf-leak可以通过static和dynamic两种方式实现，在此进行static实验。修改配置进行vrf-leak实验，在R3上添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># SONiC test case of VRF</span><br><span class="line"></span><br><span class="line">基本问题描述：test case场景下，单个VRF中存在12.8K(6.4K的IPv4和6.4K的IPv6)路由条目，删除VRF时，一定时间内需要删除大量路由。里面有两个问题：</span><br><span class="line">  1. zebra的fpm client不能将所有数据同步给fpm server</span><br><span class="line">  2. 删除VRF中默认路由时出错</span><br><span class="line"></span><br><span class="line">## 创建VRF时需要关注的几个对象</span><br><span class="line">![](https:&#x2F;&#x2F;rancho333.github.io&#x2F;pictures&#x2F;vrf_about_obiects.png)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">  1. 一个VRF中包含一个或多个L3 接口，创建接口会增加该VRF的reference count</span><br><span class="line">  2. 一个L3 接口上包含一个或多个IP，创建IP会增加该接口的reference count</span><br><span class="line">  3. 一个IP对应一个邻居，增加neighbour会增加该IP的reference count</span><br><span class="line">  4. 有了neighbour之后，路由协议会创建路由条目(route entry)，增加route entry会增加对VRF的reference count</span><br><span class="line">  5. route entry中的一个重要参数是next hop(可能会有多个next hop)，增加next hop会增加对route entry的reference count</span><br><span class="line"></span><br><span class="line">当一个对象的reference count不为0时，是不能将其删除的，必须彻底的解决其依赖关系。</span><br><span class="line"></span><br><span class="line">## SONiC数据同步机制的缺陷，以删除VRF为例</span><br><span class="line">![](https:&#x2F;&#x2F;rancho333.github.io&#x2F;pictures&#x2F;vrf_del_vrf.png)</span><br><span class="line">vrfmgrd会陷入loop等待vrforch删除数据库中stateobjectvrf条目，如果vrforch执行失败，vrfmgrd会陷入死循环。</span><br><span class="line"></span><br><span class="line">## zebra到fpmsyncd(bgp)同步路由的过程以及之前版本的缺陷(以删除ip为例)</span><br><span class="line">![](https:&#x2F;&#x2F;rancho333.github.io&#x2F;pictures&#x2F;vrf_del_ip.png)</span><br><span class="line"></span><br><span class="line">基本流程：</span><br><span class="line">1. SONiC通过Linux shell删除L3的IP</span><br><span class="line">2. zebra通过netlink同步信息并通知给个路由进程</span><br><span class="line">3. 路由进程决策路由信息通知给zebra</span><br><span class="line">4. zebra决策路由信息，通过netlink同步给kernel，通过fpm同步给sonic端的fpmsyncd</span><br><span class="line">5. zebra端fpm client写机制有缺陷(write buffer较小，有写次数的限制)，导致数据丢失</span><br><span class="line">6. 修改方式，在步骤1中删除IP后添加时延，减少zebra单位时间内处理的路由信息，给frr添加如下patch，解决fpm client写缺陷</span><br></pre></td></tr></table></figure><p> zebra/zebra_fpm.c |    4 ++–<br> 1 file changed, 2 insertions(+), 2 deletions(-)</p><p>diff –git a/zebra/zebra_fpm.c b/zebra/zebra_fpm.c<br>index 7b0611bf9..4efa8c896 100644<br>— a/zebra/zebra_fpm.c<br>+++ b/zebra/zebra_fpm.c<br>@@ -62,7 +62,7 @@ DEFINE_MTYPE_STATIC(ZEBRA, FPM_MAC_INFO, “FPM_MAC_INFO”);</p><ul><li>The maximum number of times the FPM socket write callback can call</li><li>‘write’ before it yields.</li><li>/</li></ul><p>-#define ZFPM_MAX_WRITES_PER_RUN 10<br>+#define ZFPM_MAX_WRITES_PER_RUN 100</p><p> /*</p><ul><li>Interval over which we collect statistics.<br>@@ -929,7 +929,7 @@ enum {<br>FPM_GOTO_NEXT_Q = 1<br>};</li></ul><p>-#define FPM_QUEUE_PROCESS_LIMIT 10000<br>+#define FPM_QUEUE_PROCESS_LIMIT 50000</p><p>```<br>注意SONiC中frr的编译机制，sonic-frr目录下的Makefile会checkout到指定分支，所以直接修改的代码内容会被覆盖。</p><h2 id="关于删除VRF中默认路由出错"><a href="#关于删除VRF中默认路由出错" class="headerlink" title="关于删除VRF中默认路由出错"></a>关于删除VRF中默认路由出错</h2><p>alpm模式下，broadcom TH4芯片在创建VRF时会创建一条默认路由(只存在于ASIC中，上层协议不可见)<br>当VRF只存在默认路由时，删除VRF会自动删除默认路由，如果此时显示删除默认路由，可以成功；<br>当VRF中存在默认路由以及其它路由时，不能显示删除默路由</p><p>原有，SONiC上层逻辑SWSS中，当删除default VRF中的默认路由时，将其设置为blackhole路由，当删除VRF中的默认路由时，下发删除指令，由于VRF中还有其它路由信息，SDK报错</p><p>修改为：当SONiC下发删除VRF中默认路由指令时，在SAI中将其实际行为修改为：将该默认路由配置成黑洞路由<br>      如果修改SONiC中的删除指令为配置成黑洞路由，那么在该VRF中，依然存在一个route entry，那么该VRF就存在reference count，那么该VRF就无法删除</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://datatracker.ietf.org/doc/html/rfc2685">rfc2685</a><br><a href="https://datatracker.ietf.org/doc/html/rfc4364">rfc4364</a><br><a href="https://github.com/Azure/SONiC/blob/master/doc/vrf/sonic-vrf-hld.md">SONiC VRF support design spec draft</a><br><a href="https://www.cisco.com/c/en/us/td/docs/net_mgmt/prime/network/3-8/reference/guide/vrf.html">VPN and VRF of cisco</a><br><a href="https://www.cisco.com/c/en/us/td/docs/switches/lan/catalyst4500/12-2/15-02SG/configuration/guide/config/vrf.html#85589">Config vrf of cisco</a><br><a href="https://www.kernel.org/doc/html/latest/networking/vrf.html">Vrf of linux kernel</a></p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/vrf/">vrf</category>
      
      
      <comments>https://rancho333.github.io/2021/10/20/vrf%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC自动化编译简述</title>
      <link>https://rancho333.github.io/2021/10/08/SONiC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2021/10/08/SONiC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Fri, 08 Oct 2021 02:58:42 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;关于SONiC自动化编译&quot;&gt;&lt;a href=&quot;#关于SONiC自动化编译&quot; class=&quot;headerlink&quot; title=&quot;关于SONiC自动化编译&quot;&gt;&lt;/a&gt;关于SONiC自动化编译&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当gitlab仓库有push动作时触发自动编译，仓库地址为：&lt;a href=&quot;http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git&quot;&gt;http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="关于SONiC自动化编译"><a href="#关于SONiC自动化编译" class="headerlink" title="关于SONiC自动化编译"></a>关于SONiC自动化编译</h1><ul><li><p>当gitlab仓库有push动作时触发自动编译，仓库地址为：<a href="http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git">http://cshgitlab.cn-csh.celestica.com/sonic-sdk/brixia_sonic.git</a></p><span id="more"></span></li><li><p>编译环境部署在泰国服务器，设备ip为：10.196.48.47</p></li><li><p>考虑网络问题以及SONiC编译偶尔会抽疯，编译失败后再次执行，5次失败后退出编译</p></li><li><p>镜像版本号为“SONiC.202012-brixia-时间-版本”，如“SONiC.202012-brixia-20210930-r4”，其中时间为当天编译时间，r后面的数字依次递增，r5,r6……</p></li><li><p>编译好的版本，命名规则为”sonic-broadcom-时间-版本.bin”，会自动推送到文件服务器：<a href="http://10.204.112.155:8081/sonic/brixia/">http://10.204.112.155:8081/sonic/brixia/</a></p></li><li><p>jenkins环境部署在：10.204.112.155:8080, 后续稳定后考虑迁移到testbed的环境，当前上面只有一个账号(rancho/123456)，有兴趣的同学请自行参观使用</p></li><li><p>针对不需要gitlab+jenkins的场景，提供shell脚本实现自动化编译，在自己家目录下执行 bash ~/auto_build.sh即可</p></li></ul><h1 id="自动化编译一些小问题"><a href="#自动化编译一些小问题" class="headerlink" title="自动化编译一些小问题"></a>自动化编译一些小问题</h1><ul><li><p>自动化编译每次均为全量编译，时间较长，加上从泰国服务器拷贝image，时间较长，如果是特性或编译临时版本，并不建议使用，推荐增量编译或模块化编译。</p></li><li><p>自动化编译只会编译基础SONiC镜像，debug版本或加特性(如syncd-rpc)不会在自动化编译中(主要考虑编译时间、传输时间、存储空间以及使用率)</p></li><li><p>自动化编译单次只会编译一个target，对于无依赖关系target不能并行处理，并行处理大概率会报错，需要手动纠错</p></li><li><p>jenkins在远程主机上执行shell命令使用的是SSH，该shell是非交互式非登录式shell，需要注意shell配置文件的加载以及环境变量的配置</p></li><li><p>在host上清除已经编译过的环境需要root权限(fsroot文件夹)，使用脚本中的b.out可以完成该操作<br>  修改Makefile, 在target中加入sonic-slave-run, 使用 <code>make sonic-slave-run SONIC_RUN_CMDS=&quot;rm -rf fsroot&quot;</code>删除不能删除的部分</p></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      <category domain="https://rancho333.github.io/tags/jenkins/">jenkins</category>
      
      
      <comments>https://rancho333.github.io/2021/10/08/SONiC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NAT简述及仿真实验</title>
      <link>https://rancho333.github.io/2021/09/29/NAT%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</link>
      <guid>https://rancho333.github.io/2021/09/29/NAT%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</guid>
      <pubDate>Wed, 29 Sep 2021 05:52:24 GMT</pubDate>
      
      <description>&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E4%BA%8Enat%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98&quot;&gt;关于NAT的一些基本问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFnat&quot;&gt;什么是NAT?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#nat%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F&quot;&gt;NAT的工作方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#nat%E7%9A%84%E5%BC%8A%E7%AB%AF%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&quot;&gt;NAT的弊端及处理方式&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#alg&quot;&gt;ALG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#icmp%E6%8A%A5%E6%96%87%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86&quot;&gt;ICMP报文的特殊处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ip%E5%88%86%E7%89%87%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86&quot;&gt;IP分片的特殊处理&lt;/a&gt;</description>
      
      
      
      <content:encoded><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E5%85%B3%E4%BA%8Enat%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">关于NAT的一些基本问题</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFnat">什么是NAT?</a></li><li><a href="#nat%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">NAT的工作方式</a></li><li><a href="#nat%E7%9A%84%E5%BC%8A%E7%AB%AF%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">NAT的弊端及处理方式</a><ul><li><a href="#alg">ALG</a></li><li><a href="#icmp%E6%8A%A5%E6%96%87%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86">ICMP报文的特殊处理</a></li><li><a href="#ip%E5%88%86%E7%89%87%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86">IP分片的特殊处理</a><span id="more"></span></li></ul></li></ul></li><li><a href="#nat%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B">NAT的基本工作模型</a><ul><li><a href="#%E4%BC%A0%E7%BB%9Fnat">传统NAT</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2basic-nat">基本地址转换(Basic NAT)</a></li><li><a href="#naptnetwork-address-port-translation">NAPT(network address port translation)</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81nat%E5%92%8C%E5%8A%A8%E6%80%81nat">关于静态NAT和动态NAT</a></li></ul></li><li><a href="#bi-directional-nat-or-two-way-nat">Bi-directional NAT or Two-Way NAT</a></li><li><a href="#twice-nat">Twice NAT</a></li></ul></li><li><a href="#nat%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8%E6%96%B9%E6%A1%88">NAT的一些应用方案</a><ul><li><a href="#nat%E7%9A%84%E5%8F%8C%E7%83%AD%E6%9C%BA%E5%A4%87%E4%BB%BDnat%E5%A4%9A%E5%87%BA%E5%8F%A3%E7%AD%96%E7%95%A5">NAT的双热机备份/NAT多出口策略</a></li><li><a href="#nat%E7%A9%BF%E8%B6%8A%E6%8A%80%E6%9C%AF">NAT穿越技术</a></li><li><a href="#nat%E4%B8%8Evpn">NAT与VPN</a></li><li><a href="#nat%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82">NAT与路由的关系及一些处理细节</a></li><li><a href="#sonic%E4%B8%ADnat%E7%9A%84%E5%AE%9E%E7%8E%B0">SONiC中NAT的实现</a></li><li><a href="#nat-ptv4v6%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">NAT-PT(V4/V6地址转换)</a></li></ul></li><li><a href="#gns3%E4%B8%8Anat%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E9%AA%8C">GNS3上NAT的基本实验</a><ul><li><a href="#%E9%9D%99%E6%80%81nat%E5%AE%9E%E9%AA%8C">静态NAT实验</a></li><li><a href="#%E5%8A%A8%E6%80%81nat%E5%AE%9E%E9%AA%8C">动态NAT实验</a></li><li><a href="#pat%E5%AE%9E%E9%AA%8C">PAT实验</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1 id="关于NAT的一些基本问题"><a href="#关于NAT的一些基本问题" class="headerlink" title="关于NAT的一些基本问题"></a>关于NAT的一些基本问题</h1><p>本文旨在对NAT有一个全局的了解，包括NAT技术的起因，技术的实现方式以及应用场景，技术存在的缺点以及解决方式，最后以几个基本的实验进行验证收尾，对于某些复杂的应用场景或技术细节，会简述而不深究，这些等到真实的应用中去打磨。</p><h2 id="什么是NAT"><a href="#什么是NAT" class="headerlink" title="什么是NAT?"></a>什么是NAT?</h2><p>NAT的名字很准确，Network Address Translator(网络地址转换)，就是替换私网IP报文头部的地址信息，从而提供公网可达性和上层协议的连接能力。按照rfc2663的说法，NAT是从一个IP地址范围映射到另一个范围的方法，很显然，这种说法更加概括<br>NAT的使用场景：</p><ul><li>私网到公网的翻译</li><li>重叠地址之间的翻译</li><li>保护内网IP设备</li></ul><p>关于私网，RFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。</p><h2 id="NAT的工作方式"><a href="#NAT的工作方式" class="headerlink" title="NAT的工作方式"></a>NAT的工作方式</h2><p>NAT功能在网络出口路由器上使能，在报文离开私网进入公网时，将源IP替换为公网IP，报文从公网进入私网时，做相反的替换。NAT处理报文的几个关键特点：</p><ul><li>网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都经过NAT网关</li><li>NAT网关在两个访问方向上完成两次地址转换，出方向上做源信息替换，入方向上做目的地址替换</li><li><em>NAT网关的存在对通信双方是透明的</em>(这是NAT致力于达到的，但做的不好，因为有些上层协议会在内部携带IP地址信息)</li><li>NAT网关为了实现双向翻译，需要维护一张关联表，把会话信息记录下来</li></ul><h2 id="NAT的弊端及处理方式"><a href="#NAT的弊端及处理方式" class="headerlink" title="NAT的弊端及处理方式"></a>NAT的弊端及处理方式</h2><p>NAT缓解公网IP不够用的同时带来了一些不好的影响，需要通过另一些技术去解决。</p><ul><li>NAT无法做到透明传输，ALG技术来解决</li><li>NAT破环了IP协议架构端到端的通信模型，破坏了节点在通讯中的对等地位。NAT穿透技术进行解决</li><li>NAT使IP会话的时效变短，因为IP和端口资源有限，而通信的需求无限，NAT网关会对关联表进行老化操作(特别是UDP通信)，这可能会导致用户可感知的连接中断，通过上层协议设置连接保活机制来解决</li><li>使依赖IP进行主机跟踪的机制失效，如：基于用户行为的日志分析，基于IP的用户授权，服务器连接设置同一时间只接收同一IP的有限访问，总之NAT屏蔽了通信的一端，把简单的事情复杂化了</li><li>ICMP复用和解复用需要特殊处理，如果ICMP payload无法提供足够信息，解复用会失败</li><li>IP分片，因为只有第一个分片有传输层信息，NAT很难识别后续分片与关联表的对应关系，需要特殊处理</li></ul><h3 id="ALG"><a href="#ALG" class="headerlink" title="ALG"></a>ALG</h3><p>NAT工作在L3和L4，ALG(application level gateways)是用以解决NAT对应用层无感知的常用方式。NAT网关基于传输层端口信息来识别连接是否为已知的应用类型，在识别为已知应用时，会对其报文内容进行检查，当发现任何形式表达的IP地址和端口时，会把这些信息同步转换。</p><p>但是，应用层协议很多而且在不断变化，而设备中的ALG都是针对特定协议特定版本开发的，尽管Linux允许动态加载ALG特性，其管理维护成本依然很高。因此，ALG只能解决常用的用户需求，而且，有些报文从源端发出就已经加密，ALG也无能为力。</p><h3 id="ICMP报文的特殊处理"><a href="#ICMP报文的特殊处理" class="headerlink" title="ICMP报文的特殊处理"></a>ICMP报文的特殊处理</h3><p>NAT网关通常采用五元组进行NAT映射，即源地址、源端口、IP协议类型、目的地址、目的端口。ICMP报文直接承载在IP报文之上，没有L4信息。以ping为例，对于ICMP请求报文，TYPE+CODE字段作为源端口，identifier作为目的端口记录，反之亦然。windows上发出的ICMP报文identifier字段全部是0x0400，处理上有些差别。<br>这段话来自华三的《NAT专题》，在思科的c3600上实验时，发现其只使用identifier标识一个ICMP会话，即ICMP的src port和dst port都是identifier的值。这里表示理解，只要NAT设备能够区别出不同内部主机发的报文即可，具体实现厂家可能有所差异。</p><h3 id="IP分片的特殊处理"><a href="#IP分片的特殊处理" class="headerlink" title="IP分片的特殊处理"></a>IP分片的特殊处理</h3><p>当进行IP分片时，这些信息只有首片报文会携带(只有首片中有端口号，只有首片中有icmp的identifier)，后续分片报文依靠报文ID、分片标志位、分片偏移量依次关联到前一个分片。在PAT转换类型中，除了对IP地址进行处理，还会处理L4的端口号，ICMP报文头中的identifier字段信息。因此，除首片外的报文无法进行转换，需要特殊处理，有两种方式：</p><ul><li>先缓存，等所有报文到达后，进行虚拟重组，再进行NAT转换，将转换后的报文再顺序发出</li><li>在首片到达并转换后，保存转换首片使用的IP以及identifier信息，在后续分片到达后使用同样表项进行转换。</li></ul><h1 id="NAT的基本工作模型"><a href="#NAT的基本工作模型" class="headerlink" title="NAT的基本工作模型"></a>NAT的基本工作模型</h1><p>NAT是网络地址转换的总称，基于不同的应用场景它有不同的配置。大的分类上可以分为传统NAT和two-way NAT以及twice NAT。</p><h2 id="传统NAT"><a href="#传统NAT" class="headerlink" title="传统NAT"></a>传统NAT</h2><p>传统NAT只能由内网主机发起通信，是单向的。传统NAT有两种实现。</p><h3 id="基本地址转换-Basic-NAT"><a href="#基本地址转换-Basic-NAT" class="headerlink" title="基本地址转换(Basic NAT)"></a>基本地址转换(Basic NAT)</h3><p>NAT设备拥有多个公网ip，数量远少于内网主机的数量，当有内网主机访问外网时分配公网ip，访问结束时释放。NAT设备拥有公网IP地址的数目，应该根据网络高峰可能访问外网的内网主机数目的统计值来确定。</p><p>上面这段话是对rfc2663 4.1.1章节的一个翻译，结合实际的应用，Basic NAT就是只进行IP地址转换的NAT模式。</p><h3 id="NAPT-network-address-port-translation"><a href="#NAPT-network-address-port-translation" class="headerlink" title="NAPT(network address port translation)"></a>NAPT(network address port translation)</h3><p>一个外网地址可以同时分配给多个内网地址公用。该模式下，NAPT会转换源IP，源端口以及相关的ip，tcp/udp和icmp的header checksums.转换的id可以是 tcp/udp的端口号或者icmp的query ID。其转换的基本原理可形容为：<br>(iAddr;iPort) &lt;——&gt; (eAddr; ePort)<br>与此相关可称之为PAT(port address translation)模式，NAT使用最多的模式就是PAT模式。相反的不使用port进行地址转换称为NO-PAT(not port address translation)，而NAPT根据是否关心对端的信息可以分为下面两种：</p><ol><li><p>endpoint-independent mapping(不关心对端地址和端口的转换模式)<br>NAT设备通过建立三元组(源地址、源端口号、协议类型)表项来进行地址分配和报文过滤。即，只要来自相同源地址和源端口号的报文，不论其目的地址是否相同，通过NAPT映射后，其源地址和源端口号都被转换成同一个外部地址和端口号，并且NAT设备允许外部网络的主机通过该转换后的地址和端口来访问这些内部网络的主机。这种模式可以很好的支持位于不同NAT设备之后的主机进行互访。</p></li><li><p>address and port-dependent mapping(关心对端地址和端口转换模式)<br>NAT设备通过建立五元组(源地址、源端口号、协议类型、目的地址、目的端口号)进行地址分配和报文过滤。即，对于来自相同源地址和源端口号的报文，若其目的地址和目的端口号不同，通过NAPT映射后，会被转换成不同的外部地址和端口号，并且NAT设备只允许这些目的地址对应的外部网络的主机才可以访问对应的内部主机。这种模式安全性好，但是不便于位于不同NAT设备之后的主机间的互访。</p></li></ol><p>而通过对外部主机地址+端口的限制，又可以分为：</p><ul><li>全锥形：对于inbound,只要NAT表项中存在，不关心src ip</li><li>限制锥形：对于inbound, 关心src ip</li><li>端口限制锥形: 对于inbound, 关心src ip + src port</li><li>对称形: 对于outbound和inbound, 只有src ip, src port, dst ip, dst port完全一致才认为是一个会话，否则创建新的表项<br>这些都是本质是NAT的应用，更加细粒度的进行控制过滤，是NAT的一种工作方式, 可以称之为<em>policy NAT</em>。</li></ul><h3 id="关于静态NAT和动态NAT"><a href="#关于静态NAT和动态NAT" class="headerlink" title="关于静态NAT和动态NAT"></a>关于静态NAT和动态NAT</h3><p>这是另一种分类方式，静态NAT即内外网地址信息静态绑定，是一一映射，这种很少使用，可用来隐藏私网ip和重叠地址网络的通信。动态NAT则是使用外网地址池，有资源回收机制，这种用法也少，地主家也不能买这么多公网IP地址。</p><h2 id="Bi-directional-NAT-or-Two-Way-NAT"><a href="#Bi-directional-NAT-or-Two-Way-NAT" class="headerlink" title="Bi-directional NAT or Two-Way NAT"></a>Bi-directional NAT or Two-Way NAT</h2><p>外部网络能够有主动访问内网主机的机会，如给外网提供一台Web服务器，或是一台FTP服务器。实现双向NAT的关键在于DNS-ALG的引入，借助DNS-ALG,实现处于不同网络中的主机直接通过域名来相互访问。<br>静态NAT一般就是双向NAT.</p><h2 id="Twice-NAT"><a href="#Twice-NAT" class="headerlink" title="Twice NAT"></a>Twice NAT</h2><p>相对于traditional NAT和bi-directional NAT中NAT设备只会对报文的源或者目的进行修改，twice NAT则对报文的src/dst同时进行修改。例如当外网主机使用的外网的ip已经分配给别的组织地址，这时需要将dst也改掉。这种方式常用于支持内网用户主动访问与之地址重叠(overlap)的外网资源。</p><p>当内网主机A向外网主机B发起通信时，但是内网中有主机D使用的是和B一样的IP地址（如之前ISP分配的，现在收回了；如同一公司的异地组网），如果A直接和B进行通信，那么报文会转发给D。A 通过发送DNS请求B的ip，DNS-ALG接收到之后给其分配一个可路由的内网地址C，现在A向C通信，NAT设备收到之后，对于src ip,按传统NAT转换，对于dest ip，将地址C改为B的地址，发给外网，收到之后，反之亦然。<br>Twice NAT would not be allowed to advertise local networks to the external network or vice versa.</p><p>NAT可分为SNAT、DNAT和twice NAT, 对于inside——&gt;outside的流量，做SNAT，对于outside——&gt;inside的流量，做DNAT。</p><h1 id="NAT的一些应用方案"><a href="#NAT的一些应用方案" class="headerlink" title="NAT的一些应用方案"></a>NAT的一些应用方案</h1><h2 id="NAT的双热机备份-NAT多出口策略"><a href="#NAT的双热机备份-NAT多出口策略" class="headerlink" title="NAT的双热机备份/NAT多出口策略"></a>NAT的双热机备份/NAT多出口策略</h2><p>与出口网关一样，NAT存在单点故障的问题。进行双热机备份当然是很好的方式。双热机备份分为对称式和非对称式，对称式即进出流量只能走相同的设备，非对称式则没有这个要求，可以进行负载均衡。这里简单列举一下对称式的实现方式：</p><ul><li>利用VRRP实现流量切换</li><li>利用动态路由实现流量切换</li></ul><h2 id="NAT穿越技术"><a href="#NAT穿越技术" class="headerlink" title="NAT穿越技术"></a>NAT穿越技术</h2><p>这里只是插个眼，不做深入研究，NAT穿越技术有：</p><ul><li>ALG</li><li>探针技术STUN与TURN</li><li>中间件技术</li><li>中继代理技术</li><li>特定协议的自穿越技术</li></ul><h2 id="NAT与VPN"><a href="#NAT与VPN" class="headerlink" title="NAT与VPN"></a>NAT与VPN</h2><p>常见的VPN有：GRE、L2TP、IPsec、SSL VPN等。NAT在工作过程中会修改L3和L4的信息，在分析VPN与NAT共存时，首先需要分析该VPN隧道的封装方式，看有没有传输层端口，其次要分析VPN隧道的协商过程中是否使用报文的IP地址。具体分析在这里不展开了，说个结论：SSL VPN与L2TP VPN与NAT可以天然共存，IPsec VPN在部分模式下可与NAT共存，而GRE无法穿越NAT.</p><h2 id="NAT与路由的关系及一些处理细节"><a href="#NAT与路由的关系及一些处理细节" class="headerlink" title="NAT与路由的关系及一些处理细节"></a>NAT与路由的关系及一些处理细节</h2><p>对cisco的实现，参见下图：<br><img src="https://rancho333.github.io/pictures/cisco_nat_seq.png"><br>对于inside-&gt;outside的流量，NAT转化发生在routing之后；对于outside-&gt;inside的流量，NAT转换发生在路由之前.所以自cisco的实现中，NAT与路由的关系只取决于流量的方向，通过inside/outside修饰接口分割出两个区域，通过source/dest表明流量的方向。</p><p>Cisco会在特定的时间将“一条NAT映射策略”安装到系统的inside NAT表或者outside NAT表中，对于从网口进入的数据包，会根据网口是inside还是outside去匹配inside NAT表或者outside NAT表中的NAT规则，仅此而已。不管是inside NAT表还是outside NAT表，都各有两张，一张是SNAT表，另一张是DNAT表。对于每一个数据包，都要用源IP地址去查询SNAT表，用目标IP地址去查询DNAT表。这在下面的静态NAT实验中将有很好的体现。</p><p>对Linux的实现，参见下图：<br><img src="https://rancho333.github.io/pictures/linux_nat_seq.jpg"><br>Linux中并没有将NAT应用于接口的说法，NAT的配置是全局的。此时接口就是一个match，写match/target去匹配执行就好。SNAT位于post-routing域，DNAT位于pre-routing域。SNAT指的是内网发往外网的流量修改src ip, DNAT指的是外网发往内网的流量修改dest ip。Linux中的NAT是基于五元组的，也就是NAT结果和一个流(conntrack)关联在一起。</p><p>Linux的nat中，待转换的IP地址是一个match，因此不管是一对一的转换还是一对多的转换，原理都是一样的。Linux并不区分静态转换和动态转换。在内核中，永远都不会出现所谓的NAT映射表，iptables添加的NAT规则不会生成映射，数据包进入匹配nat成功，也不会生成映射，nat结果仅仅存在于conntrack中作为tuple的一部分体现。</p><p>Linux的nat查询对于第一个包是逐条匹配iptables nat表规则，对于后续的包，则转化为针对五元组的conntrack哈希查询。</p><p>借用一下SONiC中对NAT的配置：<br><img src="https://rancho333.github.io/pictures/sonic_nat_config.png"><br>命令行里面默认的NAT类型是dnat，这里不理解，等待后续使用去验证。这个NAT条目只有外网发到内网的流量才会触发呀？这不符合NAT使用最多的场景呀！</p><p>思科强调使用者得使用域，Linux强调技术本身的合理性.</p><h2 id="SONiC中NAT的实现"><a href="#SONiC中NAT的实现" class="headerlink" title="SONiC中NAT的实现"></a>SONiC中NAT的实现</h2><p><a href="https://github.com/Azure/SONiC/blob/master/doc/nat/nat_design_spec.md">SONiC中NAT</a>是SONiC对NAT的设计文档。鉴于TH4不支持NAT，SONiC的上NAT的实验后续再进行。</p><h2 id="NAT-PT-V4-V6地址转换"><a href="#NAT-PT-V4-V6地址转换" class="headerlink" title="NAT-PT(V4/V6地址转换)"></a>NAT-PT(V4/V6地址转换)</h2><p>IPv4与IPv6的过渡技术有双栈、隧道和翻译。其中翻译就是使用的NAT-PT技术。这里插个眼，后续有需要在深入。</p><h1 id="GNS3上NAT的基本实验"><a href="#GNS3上NAT的基本实验" class="headerlink" title="GNS3上NAT的基本实验"></a>GNS3上NAT的基本实验</h1><p>以上都是看的一些文档资料，实验看看效果才好，实验环境为GNS3+c3600，做三个基本场景的实验：</p><ul><li>静态NAT实验</li><li>动态NAT实验</li><li>PAT实验</li></ul><h2 id="静态NAT实验"><a href="#静态NAT实验" class="headerlink" title="静态NAT实验"></a>静态NAT实验</h2><p>基本命令为<code>ip nat inside static a b</code>, 系统会将a——&gt;b的源地址转换加入到inside的SNAT表中，同时将b——&gt;a的目的地址转换加入到outside的DNAT表中。针对后面所有的数据包，不管是内部发起的，还是外部发起的，都会根据接口使能的inside nat还是outside nat来查表匹配。<br>拓扑图如下：<br><img src="https://rancho333.github.io/pictures/topo_nat.png"><br>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">R1:</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 192.168.1.2 255.255.255.0</span><br><span class="line">router ospf 1</span><br><span class="line"> network 192.168.1.0 0.0.0.255 area 0</span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 192.168.1.1 255.255.255.0</span><br><span class="line"> ip nat inside</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 202.100.10.1 255.255.255.0</span><br><span class="line"> ip nat outside</span><br><span class="line">router ospf 1</span><br><span class="line"> network 192.168.1.0 0.0.0.255 area 0</span><br><span class="line"> network 202.100.10.0 0.0.0.255 area 0</span><br><span class="line">ip nat inside source static 192.168.1.2 202.100.10.3</span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 202.100.10.2 255.255.255.0</span><br><span class="line">router ospf 1</span><br><span class="line"> network 202.100.10.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure><p>在R1上ping R3，分别在R2的左右两侧进行抓包，左侧为NAT之前的报文：<br><img src="https://rancho333.github.io/pictures/before_nat.png"><br>右侧为NAT之后的报文，发现src ip已经发生改变：<br><img src="https://rancho333.github.io/pictures/after_nat.png"></p><p>注意我们只配置了<code>ip nat inside source</code>, 即我们只在inside接口上使能了SNAT，但是对于R4返回的数据包，是在outside接口上做DNAT，我们并没有做这个配置，这是因为cisco自动进行了这种关联，在命令行中我们也会发现cisco在outside上只有<code>ip nat outside source</code>。从NAT转换表中我们也可以看出这种自动关联的动作。<br><img src="https://rancho333.github.io/pictures/inside_source.png"><br>在ping动作之前，表中其实只有第二行，第一行的icmp是ping之后流量触发时建立，发现多了outside global和outside local字段。</p><p><code>ip nat outside source</code>表示从outside发往inside的报文做SNAT。进一步的总结下，cisco NAT的四种类型：</p><ol><li>从inside到outside时做SNAT</li><li>从inside到outside时做DNAT</li><li>从outside到inside时做SNAT</li><li>从outside到inside时做DNAT<br>其中1,4是成对的，2,3是成对的。即配1了4会自动部署，配3了2会自动部署，验证一下2,3的成对关系：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip nat outside source static 202.100.10.2 192.168.1.3</span><br></pre></td></tr></table></figure>然后使用R3 ping R1，抓包结果为：<br><img src="https://rancho333.github.io/pictures/outside_ping.png"><br>可以看到R1给192.168.1.3回了icmp reply报文，但是R3并没有收到地址转换后的报文。</li></ol><p>NAT表项转换为：<br><img src="https://rancho333.github.io/pictures/outside_dest.png"><br>同样第一行为我们配置的，第二行为流量触发的，可以发现增加了<code>inside local</code>和<code>inside local</code></p><p>这里需要结合cisco中NAT与路由的关系来回答这个问题：<br>显然这里是步骤<code>2</code>出了问题，inside-&gt;outside流量是在路由之后完成的，即R1给R3的icmp reply报文是针对192.168.1.3做的路由，R3自然收不到报文<br>所以需要在R2上配置一条静态路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route 192.168.1.3 255.255.255.255 202.100.10.2</span><br></pre></td></tr></table></figure><p>或者在outside上面配置source时添加add-route选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip nat outside source static 202.100.10.2 192.168.1.3 add-route # add-route会给prefix 192.168.1.3添加next-hop为202.100.10.2</span><br></pre></td></tr></table></figure><p><em>说明一下：这里的SNAT单纯表示替换source ip，DNAT单纯表示替换dest ip，SNAT和DNAT在Linux中与路由的关系在这里不适用</em></p><h2 id="动态NAT实验"><a href="#动态NAT实验" class="headerlink" title="动态NAT实验"></a>动态NAT实验</h2><p>对于动态NAT，配置完命令后系统不会添加任何NAT规则只有当某一个包匹配到了ACL，要引发NAT时，系统会动态的从pool中选取一个要转换的IP地址，加入到inside的SNAT表项中，同时针对反方向的目的地址转换规则将其加入到outside的DNAT表项中。<br>因此，cisco的动态NAT是单向的，因为反向的数据包进入时不会匹配到ACL，不会引发NAT规则，也就不会生成任何NAT表项。在此例中，如果R3先ping R1是不通的，必须先让R1 ping R3生成NAT表项后，双方才能互通。</p><p>实验拓扑图如下：<br><img src="https://rancho333.github.io/pictures/topo_d_nat.png"></p><p>本次实验通过配置一个NAT地址池，让R1、R4与R3通信时发生NAT转换。设备配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">R1：</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 192.168.1.2 255.255.255.0</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.1.1            #R1模拟私网主机，配置网关</span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line">interface Ethernet0&#x2F;0</span><br><span class="line"> ip address 192.168.1.1 255.255.255.0</span><br><span class="line"> ip nat inside                  # 配置NAT inside域</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 202.100.10.1 255.255.255.0</span><br><span class="line"> ip nat outside                 # 配置NAT outside域</span><br><span class="line">interface Ethernet0&#x2F;2</span><br><span class="line"> ip address 192.168.2.1 255.255.255.0</span><br><span class="line"> ip nat inside                  # 配置NAT inside域</span><br><span class="line">ip nat pool rancho-test 202.100.10.3 202.100.10.10 prefix-length 24   # 设置NAT地址池</span><br><span class="line">ip nat inside source list 1 pool rancho-test                          # 设置地址池与ACL的映射  </span><br><span class="line">access-list 1 permit 192.168.2.2                                      # 设置ACL规则，标准acl只匹配source</span><br><span class="line">access-list 1 permit 192.168.1.2                                    </span><br><span class="line">access-list 1 deny any</span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">interface Ethernet0&#x2F;1</span><br><span class="line"> ip address 202.100.10.2 255.255.255.0</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 202.100.10.1</span><br><span class="line"></span><br><span class="line">R4:</span><br><span class="line">interface Ethernet0&#x2F;2</span><br><span class="line"> ip address 192.168.2.2 255.255.255.0</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.2.1</span><br></pre></td></tr></table></figure><p>在R2左右两侧抓包，对应为NAT转换前后的包，对于R1 ping R3的抓包：<br><img src="https://rancho333.github.io/pictures/r1_d_nat.png"><br>配置的NAT地址池从202.100.10.3开始，第一个命中NAT规则的分配start ip。</p><p>对于R4 ping R3的抓包：<br><img src="https://rancho333.github.io/pictures/r4_d_nat.png"><br>后续命中NAT规则的依次分配，对于192.168.2.2分配外网IP：202.100.10.4</p><p>在R2上查看生成的NAT转换表项(在ping之前为空，只有当命中ACL规则，触发NAT转换才会生成，这是和静态NAT表项的区别)：<br><img src="https://rancho333.github.io/pictures/nat_tran.png"><br>转换表项和抓包的对比是吻合的。</p><p>查看下R2上关于NAT的统计数据以及使能的NAT的配置：<br><img src="https://rancho333.github.io/pictures/nat_stat.png"></p><h2 id="PAT实验"><a href="#PAT实验" class="headerlink" title="PAT实验"></a>PAT实验</h2><p>复用<code>动态NAt实验</code>的拓扑和基本配置，只需要将<code>R2</code>上的NAT配置做一些修改，使R1、R4访问R3时使用R2上右侧端口的IP。R2上的配置修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- ip nat pool rancho-test 202.100.10.3 202.100.10.10 prefix-length 24   # 设置NAT地址池</span><br><span class="line">- ip nat inside source list 1 pool rancho-test                          # 设置地址池与ACL的映射</span><br><span class="line">+ ip nat inside source list 1 interface Ethernet0&#x2F;1 overload            # ACL 1的流量复用 0&#x2F;1端口的IP地址</span><br></pre></td></tr></table></figure><p>同样在R2左右两侧抓包，对应PAT转换前后的包，对于R1 telnet R3，发出去的包为：<br><img src="https://rancho333.github.io/pictures/r1_pat_to.png"><br>R3对R1的返回包为：<br><img src="https://rancho333.github.io/pictures/r1_pat_from.png"></p><p>对于R4 telnet R3, 发出去的包为:<br><img src="https://rancho333.github.io/pictures/r4_pat_to.png"><br>R3对R4的返回包为：<br><img src="https://rancho333.github.io/pictures/r4_pat_from.png"></p><p>查看R2上的NAT转换表，与抓包内容符合：<br><img src="https://rancho333.github.io/pictures/pat_tran.png"></p><p>这里可以发现PAT转换前后src port并没有发生改变(直接使用的就是源TCP包中的port)，在命令里面也没有看到配置port范围的命令，不知道这是不是思科的特殊实现, 如果NAT设备发现相同的端口再处理？<em>此处存疑，思科肯定会有处理的方式</em></p><p>对于ICMP报文的特殊处理，以R1 ping R3为例，ICMP request报文为：<br><img src="https://rancho333.github.io/pictures/r1_pat_ping_to.png"><br>ICMP reply报文为：<br><img src="https://rancho333.github.io/pictures/r1_pat_ping_from.png"><br>R2上的NAT转换表为：<br><img src="https://rancho333.github.io/pictures/pat_tran_ping.png"><br>这里这看到在PAT模式中，NAT设备通过ICMP报文中的identifier字段来标识一个ICMP的NAT转换。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://datatracker.ietf.org/doc/html/rfc2663">rfc2663</a><br><a href="https://datatracker.ietf.org/doc/html/rfc3022">rfc3022</a><br><a href="https://datatracker.ietf.org/doc/html/rfc4787">rfc4787</a><br><a href="https://blog.csdn.net/armlinuxww/article/details/113541634">彻底理解Cisco NAT内部的一些事</a><br><a href="http://www.h3c.com/cn/d_201904/1175248_30005_0.htm#_Toc7355633">H3C NAT配置</a><br><a href="https://www.firewall.cx/cisco-technical-knowledgebase/cisco-routers/260-cisco-router-nat-overload.html">CONFIGURING NAT OVERLOAD ON A CISCO ROUTER</a><br><a href="https://github.com/Azure/SONiC/blob/master/doc/nat/nat_design_spec.md#221-snat-and-dnat">SONiC NAT design</a></p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/NAT/">NAT</category>
      
      
      <comments>https://rancho333.github.io/2021/09/29/NAT%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC中syncd调用SAI简析</title>
      <link>https://rancho333.github.io/2021/09/06/SONiC%E4%B8%ADsyncd%E8%B0%83%E7%94%A8SAI%E7%AE%80%E6%9E%90/</link>
      <guid>https://rancho333.github.io/2021/09/06/SONiC%E4%B8%ADsyncd%E8%B0%83%E7%94%A8SAI%E7%AE%80%E6%9E%90/</guid>
      <pubDate>Mon, 06 Sep 2021 05:45:19 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文以SONiC&lt;code&gt;202012&lt;/code&gt;版本进行&lt;code&gt;syncd&lt;/code&gt;模块初始化分析。sycnd与orchagent强相关，主要有5个动作，分别是&lt;code&gt;create&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;get&lt;/code&gt;以及&lt;code&gt;notify&lt;/code&gt;。对于前三个动作，orchagent调用sairedis api写往ASIC_DB即返回成功，&lt;code&gt;get&lt;/code&gt;动作会阻塞等待syncd的答复，当syncd接收到&lt;code&gt;notify&lt;/code&gt;事件后会通过ASIC_DB通知到orchagent。本文暂分析syncd的初始化动作。 &lt;/p&gt;
&lt;p&gt;本文可以总结成一句话：SONiC上层根据objecttype获取对应的info结构，从而调用里面的具体方法，完成sai的调用。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文以SONiC<code>202012</code>版本进行<code>syncd</code>模块初始化分析。sycnd与orchagent强相关，主要有5个动作，分别是<code>create</code>、<code>remove</code>、<code>set</code>、<code>get</code>以及<code>notify</code>。对于前三个动作，orchagent调用sairedis api写往ASIC_DB即返回成功，<code>get</code>动作会阻塞等待syncd的答复，当syncd接收到<code>notify</code>事件后会通过ASIC_DB通知到orchagent。本文暂分析syncd的初始化动作。 </p><p>本文可以总结成一句话：SONiC上层根据objecttype获取对应的info结构，从而调用里面的具体方法，完成sai的调用。</p><span id="more"></span><h1 id="syncd-main-cpp中初始化ASIC"><a href="#syncd-main-cpp中初始化ASIC" class="headerlink" title="syncd_main.cpp中初始化ASIC"></a>syncd_main.cpp中初始化ASIC</h1><p><code>syncd_main.cpp</code>是syncd进程的入口函数，里面主要做3件事情：</p><ol><li>初始或日志服务</li><li>获取warmreboot状态</li><li>实例化类<code>VendorSai</code>、<code>Syncd</code>以及运行<code>syncd-&gt;run</code>函数进入syncd主循环模块</li></ol><p>在<code>Syncd_main.cpp</code>中主要是三行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto vendorSai &#x3D; std::make_shared&lt;VendorSai&gt;();             &#x2F;&#x2F;实例化VendorSai，作为参数传给syncd</span><br><span class="line">auto syncd &#x3D; std::make_shared&lt;Syncd&gt;(vendorSai, commandLineOptions, isWarmStart);   &#x2F;&#x2F;实例化Syncd</span><br><span class="line">syncd-&gt;run();                                               &#x2F;&#x2F; 执行run方法</span><br></pre></td></tr></table></figure><p>对于<code>VendorSai</code>实例化，它的构造函数并没有做什么特别的事。</p><p>对于<code>Syncd</code>实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Syncd.cpp</span><br><span class="line">&#x2F;&#x2F; 注册notify事件的回调函数，onFdbEvent，onPortStateChange，onSwitchShutdownRequest，onSwitchStateChange等</span><br><span class="line">m_sn.onFdbEvent &#x3D; std::bind(&amp;NotificationHandler::onFdbEvent, m_handler.get(), _1, _2);</span><br><span class="line">m_sn.onPortStateChange &#x3D; std::bind(&amp;NotificationHandler::onPortStateChange, m_handler.get(), _1, _2);</span><br><span class="line"></span><br><span class="line">vendorSai-&gt;initialize               &#x2F;&#x2F;初始化sai api，并将之放到 m_apis中</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化关心的DB、channel, 在syncd::run中通过其获取各种事件然后进行处理</span><br><span class="line">m_selectableChannel &#x3D; std::make_shared&lt;RedisSelectableChannel&gt;(</span><br><span class="line">                m_dbAsic,</span><br><span class="line">                ASIC_STATE_TABLE,</span><br><span class="line">                REDIS_TABLE_GETRESPONSE,</span><br><span class="line">                TEMP_PREFIX,</span><br><span class="line">                modifyRedis);</span><br><span class="line">m_restartQuery &#x3D; std::make_shared&lt;swss::NotificationConsumer&gt;(m_dbAsic.get(), SYNCD_NOTIFICATION_CHANNEL_RESTARTQUERY);</span><br><span class="line">m_flexCounter &#x3D; std::make_shared&lt;swss::ConsumerTable&gt;(m_dbFlexCounter.get(), FLEX_COUNTER_TABLE);</span><br><span class="line">    m_flexCounterGroup &#x3D; std::make_shared&lt;swss::ConsumerTable&gt;(m_dbFlexCounter.get(), FLEX_COUNTER_GROUP_TABLE);</span><br></pre></td></tr></table></figure><p>对于方法<code>initialize</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto status &#x3D; sai_api_initialize(flags, service_method_table);      &#x2F;&#x2F;初始化sai api</span><br><span class="line">int failed &#x3D; sai_metadata_apis_query(sai_api_query, &amp;m_apis);       &#x2F;&#x2F;将api放入数据结构 m_api中</span><br></pre></td></tr></table></figure><p><code>Syncd</code>的主逻辑在<code>run</code>方法中，循环处理各种到来的事件，首先是初始化switch，在<code>onSyncdStart</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HardReiniter hr(m_client, m_translator, m_vendorSai, m_handler); &#x2F;&#x2F; 构造函数只是完成参数初始化</span><br><span class="line">m_switches &#x3D; hr.hardReinit();</span><br></pre></td></tr></table></figure><p>然后调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;HardReiniter.cpp</span><br><span class="line">   std::vector&lt;std::shared_ptr&lt;SingleReiniter&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; perform hard reinit on all switches</span><br><span class="line"></span><br><span class="line">    for (auto&amp; kvp: m_switchMap)</span><br><span class="line">    &#123;</span><br><span class="line">        auto sr &#x3D; std::make_shared&lt;SingleReiniter&gt;(</span><br><span class="line">                m_client,</span><br><span class="line">                m_translator,</span><br><span class="line">                m_vendorSai,</span><br><span class="line">                m_handler,</span><br><span class="line">                m_switchVidToRid.at(kvp.first),</span><br><span class="line">                m_switchRidToVid.at(kvp.first),</span><br><span class="line">                kvp.second);</span><br><span class="line"></span><br><span class="line">        sr-&gt;hardReinit();</span><br><span class="line">&#x2F;&#x2F; 这里面有做多ASIC的考虑，我们当前只会用到单ASIC</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">processSwitches();</span><br><span class="line">status &#x3D; m_vendorSai-&gt;create(SAI_OBJECT_TYPE_SWITCH, &amp;m_switch_rid, 0, attr_count, attr_list);</span><br></pre></td></tr></table></figure><p>在VendorSai.cpp中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto info &#x3D; sai_metadata_get_object_type_info(objectType);          &#x2F;&#x2F; 根据SAI_OBJECT_TYPE_SWITCH获取type_info</span><br><span class="line">auto status &#x3D; info-&gt;create(&amp;mk, switchId, attr_count, attr_list);   &#x2F;&#x2F; 根据type_info中的方法（sai提供）初始化ASIC</span><br></pre></td></tr></table></figure><p><code>sai_metadata_get_object_type_info</code>实际上就是一个数组，根据<code>objectType</code>获取相应的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;saimetadatautils.c</span><br><span class="line">const sai_object_type_info_t* sai_metadata_get_object_type_info(</span><br><span class="line">        _In_ sai_object_type_t object_type)</span><br><span class="line">&#123;                                                                                                                                                                                              </span><br><span class="line">    if (sai_metadata_is_object_type_valid(object_type))</span><br><span class="line">    &#123;   </span><br><span class="line">        return sai_metadata_all_object_type_infos[object_type];</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组<code>type_info</code>的定义在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;saimetadata.c</span><br><span class="line">const sai_object_type_info_t* const sai_metadata_all_object_type_infos[] &#x3D; &#123;</span><br><span class="line">    NULL,  </span><br><span class="line">    &amp;sai_metadata_object_type_info_SAI_OBJECT_TYPE_PORT,                                                                                                                                       </span><br><span class="line">    &amp;sai_metadata_object_type_info_SAI_OBJECT_TYPE_LAG,</span><br><span class="line">    &amp;sai_metadata_object_type_info_SAI_OBJECT_TYPE_VIRTUAL_ROUTER,</span><br><span class="line">    &amp;sai_metadata_object_type_info_SAI_OBJECT_TYPE_NEXT_HOP,</span><br><span class="line">    ……</span><br><span class="line">    &amp;sai_metadata_object_type_info_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    ……</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>以<code>type_switch</code>为例，它的具体数据为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const sai_object_type_info_t sai_metadata_object_type_info_SAI_OBJECT_TYPE_SWITCH &#x3D; &#123;</span><br><span class="line">    .objecttype           &#x3D; SAI_OBJECT_TYPE_SWITCH,                    </span><br><span class="line">    .objecttypename       &#x3D; &quot;SAI_OBJECT_TYPE_SWITCH&quot;,                  </span><br><span class="line">    .attridstart          &#x3D; SAI_SWITCH_ATTR_START,                     </span><br><span class="line">    .attridend            &#x3D; SAI_SWITCH_ATTR_END,                       </span><br><span class="line">    .enummetadata         &#x3D; &amp;sai_metadata_enum_sai_switch_attr_t,</span><br><span class="line">    .attrmetadata         &#x3D; sai_metadata_object_type_sai_switch_attr_t,</span><br><span class="line">    .attrmetadatalength   &#x3D; 195,                                       </span><br><span class="line">    .isnonobjectid        &#x3D; false,                                     </span><br><span class="line">    .isobjectid           &#x3D; !false,                                    </span><br><span class="line">    .structmembers        &#x3D; NULL,                                      </span><br><span class="line">    .structmemberscount   &#x3D; 0,                                         </span><br><span class="line">    .revgraphmembers      &#x3D; sai_metadata_SAI_OBJECT_TYPE_SWITCH_rev_graph_members,</span><br><span class="line">    .revgraphmemberscount &#x3D; 8,                                         </span><br><span class="line">    .create               &#x3D; sai_metadata_generic_create_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    .remove               &#x3D; sai_metadata_generic_remove_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    .set                  &#x3D; sai_metadata_generic_set_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    .get                  &#x3D; sai_metadata_generic_get_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    .getstats             &#x3D; sai_metadata_generic_get_stats_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    .getstatsext          &#x3D; sai_metadata_generic_get_stats_ext_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    .clearstats           &#x3D; sai_metadata_generic_clear_stats_SAI_OBJECT_TYPE_SWITCH,</span><br><span class="line">    .isexperimental       &#x3D; false,                                     </span><br><span class="line">    .statenum             &#x3D; &amp;sai_metadata_enum_sai_switch_stat_t,                                                                                                                           </span><br><span class="line">&#125;;                                                   </span><br></pre></td></tr></table></figure><p>由于在<code>VendorSai::create</code>中调用的是其<code>create</code>方法，我们看下其实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;saimetadata.c</span><br><span class="line">sai_status_t sai_metadata_generic_create_SAI_OBJECT_TYPE_SWITCH(</span><br><span class="line">    _Inout_ sai_object_meta_key_t *meta_key,</span><br><span class="line">    _In_ sai_object_id_t switch_id,</span><br><span class="line">    _In_ uint32_t attr_count,</span><br><span class="line">    _In_ const sai_attribute_t *attr_list)</span><br><span class="line">&#123;             </span><br><span class="line">    return sai_metadata_sai_switch_api-&gt;create_switch(&amp;meta_key-&gt;objectkey.key.object_id, attr_count, attr_list);</span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;sai_metadata_sai_switch_api的数据类型是sai_switch_api_t</span><br><span class="line">sai_switch_api_t *sai_metadata_sai_switch_api &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给sai_metadata_sai_switch_api赋值，获取的实际就是sai_switch_api_t的实现</span><br><span class="line">status &#x3D; api_query(SAI_API_SWITCH, (void**)&amp;sai_metadata_sai_switch_api);</span><br><span class="line">&#x2F;&#x2F; sai_metadata_generic_create_SAI_OBJECT_TYPE_SWITCH是将switch_api中的create方法单独拎出来，以前的SAI冒似都是获取apis，然后调用switch_api，最后调用create_switch</span><br><span class="line">apis-&gt;switch_api &#x3D; sai_metadata_sai_switch_api;</span><br></pre></td></tr></table></figure><p><code>sai_switch_api_t</code>结构体的定义在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;saiswitch.c</span><br><span class="line">typedef struct _sai_switch_api_t</span><br><span class="line">&#123;                                                                                                                                                                                              </span><br><span class="line">    sai_create_switch_fn                   create_switch;</span><br><span class="line">    sai_remove_switch_fn                   remove_switch;</span><br><span class="line">    sai_set_switch_attribute_fn            set_switch_attribute;</span><br><span class="line">    sai_get_switch_attribute_fn            get_switch_attribute;</span><br><span class="line">    sai_get_switch_stats_fn                get_switch_stats;</span><br><span class="line">    sai_get_switch_stats_ext_fn            get_switch_stats_ext;</span><br><span class="line">    sai_clear_switch_stats_fn              clear_switch_stats;</span><br><span class="line">    sai_switch_mdio_read_fn                switch_mdio_read;</span><br><span class="line">    sai_switch_mdio_write_fn               switch_mdio_write;</span><br><span class="line">    sai_create_switch_tunnel_fn            create_switch_tunnel;</span><br><span class="line">    sai_remove_switch_tunnel_fn            remove_switch_tunnel;</span><br><span class="line">    sai_set_switch_tunnel_attribute_fn     set_switch_tunnel_attribute;</span><br><span class="line">    sai_get_switch_tunnel_attribute_fn     get_switch_tunnel_attribute;</span><br><span class="line"> </span><br><span class="line">&#125; sai_switch_api_t;</span><br></pre></td></tr></table></figure><p>该结构的成员函数的实现则是由各ASIC厂家实现，以<code>create_switch</code>为例，在broadcom sai中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;brcm_sai_switch.c</span><br><span class="line">const sai_switch_api_t switch_apis &#x3D; &#123;</span><br><span class="line">    brcm_sai_create_switch,</span><br><span class="line">    brcm_sai_remove_switch,</span><br><span class="line">    brcm_sai_set_switch_attribute,</span><br><span class="line">    brcm_sai_get_switch_attribute,</span><br><span class="line">&#125;;     </span><br><span class="line">&#x2F;&#x2F; brcm_sai_create_switch具体的实现则不过分纠结了，SDK干的活   </span><br></pre></td></tr></table></figure><p>这样下来，从<code>SAI_OBJECT_TYPE_SWITCH</code>获取<code>tyep_info</code>结构，再到create方法在<code>sai</code>层的定义，以及最后的厂商实现就都连起来了。</p><p>总结下来，<code>VendorSai::create</code>方法中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto info &#x3D; sai_metadata_get_object_type_info(objectType);      &#x2F;&#x2F;根据objecttype获取info结构，包含了该type的所有方法及属性</span><br><span class="line">auto status &#x3D; info-&gt;create(&amp;mk, switchId, attr_count, attr_list);  &#x2F;&#x2F; 调用type的create方法完成sai的调用</span><br></pre></td></tr></table></figure><p><code>onSyncdStart</code>之后，创建线程处理notifiy事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m_processor-&gt;startNotificationsProcessingThread();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将care的db放到select监控中，接下来的main loop中就是循环处理这四个select事件</span><br><span class="line">s-&gt;addSelectable(m_selectableChannel.get());</span><br><span class="line">s-&gt;addSelectable(m_restartQuery.get());</span><br><span class="line">s-&gt;addSelectable(m_flexCounter.get());</span><br><span class="line">s-&gt;addSelectable(m_flexCounterGroup.get());</span><br></pre></td></tr></table></figure><h1 id="对于某一具体功能的下发"><a href="#对于某一具体功能的下发" class="headerlink" title="对于某一具体功能的下发"></a>对于某一具体功能的下发</h1><p>此处以IP Tunnel的创建为例。在swss docker中执行<code>swssconfig ipinip.json</code>，在<code>orchagent</code>这边大致流程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;orchdaemon.cpp 中会调用每一功能模块中的doTask任务</span><br><span class="line">TunnelDecapOrch *tunnel_decap_orch &#x3D; new TunnelDecapOrch(m_applDb, APP_TUNNEL_DECAP_TABLE_NAME);</span><br><span class="line"> m_orchList &#x3D; &#123; …… gIntfsOrch, gNeighOrch, gRouteOrch, copp_orch, tunnel_decap_orch, qos_orch, ……&#125;;</span><br><span class="line">for (Orch *o : m_orchList)</span><br><span class="line">             o-&gt;doTask();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;tunneldecaporch.cpp</span><br><span class="line">if (addDecapTunnel(key, tunnel_type, ip_addresses, p_src_ip, dscp_mode, ecn_mode, encap_ecn_mode, ttl_mode))</span><br><span class="line">&#123;</span><br><span class="line">    SWSS_LOG_NOTICE(&quot;Tunnel(s) added to ASIC_DB.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">status &#x3D; sai_tunnel_api-&gt;create_tunnel(&amp;tunnel_id, gSwitchId, (uint32_t)tunnel_attrs.size(), tunnel_attrs.data());</span><br><span class="line">&#x2F;&#x2F; 给每一ip创建一个decap tunnel entry</span><br><span class="line">if (!addDecapTunnelTermEntries(key, dst_ip, tunnel_id))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将tunnel_term写入到ASIC DB中</span><br><span class="line">sai_status_t status &#x3D; sai_tunnel_api-&gt;create_tunnel_term_table_entry(&amp;tunnel_term_table_entry_id, gSwitchId, (uint32_t)tunnel_table_entry_attrs.size(), tunnel_table_entry_attr    s.data());  </span><br><span class="line">SWSS_LOG_NOTICE(&quot;Created tunnel entry for ip: %s&quot;, ip.c_str());</span><br></pre></td></tr></table></figure><p><code>syncd</code>的mainloop中接收到通知，进行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;syncd.cpp</span><br><span class="line">processEvent(*m_selectableChannel.get());</span><br><span class="line"></span><br><span class="line">processSingleEvent(kco);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create，remove，set，get都是使用这一个API，大概这就是quard的意思吧</span><br><span class="line">return processQuadEvent(SAI_COMMON_API_CREATE, kco);</span><br></pre></td></tr></table></figure><p>我们创建的是IP tunnel的解封装规则，对应的sai objtype是<code>SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;syncd.cpp</span><br><span class="line">&#x2F;&#x2F; 获取参数列表</span><br><span class="line">auto&amp; values &#x3D; kfvFieldsValues(kco);</span><br><span class="line">sai_attribute_t *attr_list &#x3D; list.get_attr_list();</span><br><span class="line">uint32_t attr_count &#x3D; list.get_attr_count();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取type对应的info数据，isnonobjectid是false</span><br><span class="line">auto info &#x3D; sai_metadata_get_object_type_info(metaKey.objecttype);</span><br><span class="line"></span><br><span class="line">status &#x3D; processOid(metaKey.objecttype, strObjectId, api, attr_count, attr_list);</span><br><span class="line"> </span><br><span class="line">return processOidCreate(objectType, strObjectId, attr_count, attr_list);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用vendorSai中的create方法</span><br><span class="line">sai_status_t status &#x3D; m_vendorSai-&gt;create(objectType, &amp;objectRid, switchRid, attr_count, attr_list);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在VendorSai.cpp中是create方法的实现</span><br><span class="line">&#x2F;&#x2F; 根据objecttype获取info结构</span><br><span class="line">auto info &#x3D; sai_metadata_get_object_type_info(objectType);</span><br><span class="line">&#x2F;&#x2F; 调用infor中的create方法</span><br><span class="line">auto status &#x3D; info-&gt;create(&amp;mk, switchId, attr_count, attr_list);</span><br><span class="line">&#x2F;&#x2F;tunnel term的create方法在saimetadata.c中</span><br><span class="line">sai_metadata_generic_create_SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后是发送通知信息给swss</span><br><span class="line">sendApiResponse(api, status);</span><br></pre></td></tr></table></figure><h1 id="关于Tunnelmgrd"><a href="#关于Tunnelmgrd" class="headerlink" title="关于Tunnelmgrd"></a>关于Tunnelmgrd</h1><p><code>swss</code>中有一类进程以<code>*mgrd</code>结尾，它们干的活是将APP_DB中的数据同步到linux kernel，sonic中的一些配置是通过写APP_DB来完成的，<code>orchagent</code>完成<code>ASIC</code>的下发，<code>*mgrd</code>完成kernel的同步。</p><p>当然也有与之相反的配置流程，如路由的下发，<code>zebra</code>将路由信息下发到kernel，同时发送一份信息到<code>Fpmsyncd</code>，<code>Fpmsyncd</code>将其写到<code>APP_DB</code>,最后<code>orchagent</code>将其下发到<code>ASIC</code>.</p><p>上面两种方式的本质就是<code>kernel</code>和<code>ASIC</code>之间配置的同步。</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      <category domain="https://rancho333.github.io/tags/syncd/">syncd</category>
      
      
      <comments>https://rancho333.github.io/2021/09/06/SONiC%E4%B8%ADsyncd%E8%B0%83%E7%94%A8SAI%E7%AE%80%E6%9E%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC中coredump调试</title>
      <link>https://rancho333.github.io/2021/08/23/SONiC%E4%B8%ADcoredump%E8%B0%83%E8%AF%95/</link>
      <guid>https://rancho333.github.io/2021/08/23/SONiC%E4%B8%ADcoredump%E8%B0%83%E8%AF%95/</guid>
      <pubDate>Mon, 23 Aug 2021 02:01:28 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在进行&lt;code&gt;sonic-testbed&lt;/code&gt;中的&lt;code&gt;process monitor&lt;/code&gt;用例调试的时候，发现&lt;code&gt;swss&lt;/code&gt;容器中的&lt;code&gt;orchagent&lt;/code&gt;进程产生coredump导致测试失败。本文将简单介绍coredump以及如何编译debug版本SONiC进行coredump调试。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在进行<code>sonic-testbed</code>中的<code>process monitor</code>用例调试的时候，发现<code>swss</code>容器中的<code>orchagent</code>进程产生coredump导致测试失败。本文将简单介绍coredump以及如何编译debug版本SONiC进行coredump调试。</p><span id="more"></span><h1 id="SONiC中coredump的一些配置"><a href="#SONiC中coredump的一些配置" class="headerlink" title="SONiC中coredump的一些配置"></a>SONiC中coredump的一些配置</h1><p>由于SONiC中的服务基本上都是运行在docker中，所以需要使能docker产生coredump。需要做两件事：</p><ol><li>在host上配置<code>/proc/sys/kernel/core_pattern</code>, 配置core文件路径以及名称</li><li>在docker中配置core文件大小限制<code>ulimit -c unlimited</code></li></ol><p>下面是SONiC对core文件路径及名称的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@cel-brixia2-01:&#x2F;home&#x2F;admin# cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern </span><br><span class="line">|&#x2F;usr&#x2F;local&#x2F;bin&#x2F;coredump-compress %e %t %p %P</span><br><span class="line">root@cel-brixia2-01:&#x2F;home&#x2F;admin# </span><br><span class="line">root@cel-brixia2-01:&#x2F;home&#x2F;admin# cat &#x2F;usr&#x2F;local&#x2F;bin&#x2F;coredump-compress</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># Collect all parameters in order and build a file name prefix</span><br><span class="line">PREFIX&#x3D;&quot;&quot;</span><br><span class="line">while [[ $# &gt; 1 ]]; do</span><br><span class="line">    PREFIX&#x3D;$&#123;PREFIX&#125;$1.</span><br><span class="line">    shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ $# &gt; 0 ]; then</span><br><span class="line">    ns&#x3D;&#96;xargs -0 -L1 -a &#x2F;proc&#x2F;$&#123;1&#125;&#x2F;environ | grep -e &quot;^NAMESPACE_ID&quot; | cut -f2 -d&#39;&#x3D;&#39;&#96;</span><br><span class="line">    if [ ! -z $&#123;ns&#125; ]; then</span><br><span class="line">        PREFIX&#x3D;$&#123;PREFIX&#125;$&#123;ns&#125;.</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;gzip -1 - &gt; &#x2F;var&#x2F;core&#x2F;$&#123;PREFIX&#125;core.gz</span><br></pre></td></tr></table></figure><p>即当产生core文件时，我们可以在<code>/var/core/</code>路径下找到.</p><h1 id="SONiC中core文件调试"><a href="#SONiC中core文件调试" class="headerlink" title="SONiC中core文件调试"></a>SONiC中core文件调试</h1><p>普通的SONiC版本中是不带<code>gdb</code>工具的，<code>elf</code>文件也都是<code>stripped</code>。在编译debug版本的时候，需要做两件事：</p><ol><li>在docker中安装gdb工具</li><li>对<code>elf</code> not stripped或者主动添加<code>symbols</code>信息</li></ol><p>SONiC的编译系统提供了很方便的方法供用户编译debug版本，以<code>swss</code>为例做步骤说明。</p><ol><li><p>修改<code>rules/config</code>中的字段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-# INSTALL_DEBUG_TOOLS &#x3D; y</span><br><span class="line">+INSTALL_DEBUG_TOOLS &#x3D; y</span><br><span class="line"></span><br><span class="line">-#SONIC_DEBUGGING_ON &#x3D; y</span><br><span class="line">-#SONIC_PROFILING_ON &#x3D; y</span><br><span class="line">+SONIC_DEBUGGING_ON &#x3D; y</span><br><span class="line">+SONIC_PROFILING_ON &#x3D; y</span><br></pre></td></tr></table></figure></li><li><p>使用<code>make list</code>找到需要对应的target，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target&#x2F;docker-orchagent-dbg.gz</span><br></pre></td></tr></table></figure><p>之后<code>make target/docker-orchagent-dbg.gz</code>生成debug版本的容器，然后拷贝到设备上。</p></li><li><p>加载镜像，生成debug版的容器</p><ul><li>使用<code>docker load -i docker-orchagent-dbg.gz</code>载入编译好的debug版镜像</li><li>删除原来的容器<code>docker rm swss</code></li><li>修改<code>/usr/bin/swss.sh</code> 文件<code>--name=$DOCKERNAME docker-orchagent-dbg:latest</code>，指定使用debug版镜像生成容器</li><li><code>service swss stop</code> &amp;&amp; <code>service swss start</code> 生成新的容器</li></ul></li><li><p>对core文件进行调试<br>将<code>/var/core</code>下的core文件拷到docker中，可以参见<code>/usr/bin/swss.sh</code>中<code>create docker</code>时挂载的目录，一般host上的<code>/etc/sonic</code>会以只读的方式挂载到docker中。</p></li></ol><p>使用<code>gdb /usr/bin/orchagent core.file</code>进行调试的时候，我们会发现gdb是从<code>/usr/lib/debug/.build-id/</code>下面读取symbols信息的。SONiC采用模块化增量的方式进行编译，原有的<code>elf</code>文件依然是<code>stripped</code>状态，但是在debug版本中会将里面的symbols信息提取出来放到一个deb包中，如<code>swss-dbg_1.0.0_amd64.deb</code>。</p><ol start="5"><li>这是针对某一具体的debug容器替换说明，如果对整个SONiC编译debug版本,修改完<code>rules/config</code>后，直接<code>make target/sonic-broadcom.bin</code>即可。</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      <category domain="https://rancho333.github.io/tags/coredump/">coredump</category>
      
      
      <comments>https://rancho333.github.io/2021/08/23/SONiC%E4%B8%ADcoredump%E8%B0%83%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC上层应用之SWSS</title>
      <link>https://rancho333.github.io/2021/08/19/SONiC%E4%B8%8A%E5%B1%82%E5%BA%94%E7%94%A8%E4%B9%8BSWSS/</link>
      <guid>https://rancho333.github.io/2021/08/19/SONiC%E4%B8%8A%E5%B1%82%E5%BA%94%E7%94%A8%E4%B9%8BSWSS/</guid>
      <pubDate>Thu, 19 Aug 2021 02:42:23 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://rancho333.github.io/2021/08/19/SONiC%E4%B8%8A%E5%B1%82%E5%BA%94%E7%94%A8%E4%B9%8BSWSS/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC中交换芯片启动流程简述</title>
      <link>https://rancho333.github.io/2021/07/21/SONiC%E4%B8%AD%E4%BA%A4%E6%8D%A2%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2021/07/21/SONiC%E4%B8%AD%E4%BA%A4%E6%8D%A2%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Wed, 21 Jul 2021 09:15:56 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文基于SONiC 202012分支进行交换芯片启动流程的分析。源码部分主要涉及&lt;code&gt;sonic-swss&lt;/code&gt;和&lt;code&gt;sonic-sairedis&lt;/code&gt;以及&lt;code&gt;ocp-sai&lt;/code&gt;. 一句话说明所有流程：swss模块通知syncd模块进行ASIC初始化。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文基于SONiC 202012分支进行交换芯片启动流程的分析。源码部分主要涉及<code>sonic-swss</code>和<code>sonic-sairedis</code>以及<code>ocp-sai</code>. 一句话说明所有流程：swss模块通知syncd模块进行ASIC初始化。</p><span id="more"></span><h2 id="模块主要功能说明"><a href="#模块主要功能说明" class="headerlink" title="模块主要功能说明"></a>模块主要功能说明</h2><p>docker swss中的模块主要可以分为三类:</p><ol><li>收集信息写往APP_DB，如portsyncd, intfsyncd（*syncd）</li><li>订阅APP_DB将数据写往ASIC_DB，如orchagent（是APP_DB的consumer，同时也是ASIC_DB的producer）</li><li>收集数据写往kernel， IntfMgrd和VlanMgrd</li></ol><p>docker syncd中主要是syncd模块，该模块订阅ASIC_DB,之后调用sai api操作sdk, 完成数据的下发。</p><h1 id="从swss开始"><a href="#从swss开始" class="headerlink" title="从swss开始"></a>从swss开始</h1><p>搞清楚ASIC的启动流程，实际上上就是弄清楚orchagent和syncd这两个进程的初始化和通信的过程。</p><p>在docker syncd的启动脚本中，我们可以看到其依赖关系。<br><img src="https://rancho333.github.io/pictures/syncd_service.png"></p><p>docker swss中orchagent负责通知syncd进行ASIC初始化， 对于orchagent主要理解下面两行代码：<br><img src="https://rancho333.github.io/pictures/orchagent_init.png"></p><p>这里简要说明一下<code>OCP SAI</code>的工作方式，对应的源码在<code>src/sonic-sairedis/SAI</code>, 这里面定义了sai的data以及functions，还有一些metadata操作方式，而数据的初始化以及函数的实现由芯片厂商实现，通过动态库的方式提供。syncd编译时会链接到libsai，这样我们在syncd中就可以调用sai api完成对SDK的控制。</p><p>与此类似的，在<code>sonic-sairedis</code>中提供一个libsairedis的动态库(源码在<code>src/sonic-sairedis/lib</code>)，这里面同样对ocp sai进行实现，不过实现的对象是redis，这样在orchagent中就可以调用sai api完成对redis的操作。</p><p>对于<code>initSaiApi</code>：<br><img src="https://rancho333.github.io/pictures/saiapi_init.png"></p><p>对于<code>sai_api_query</code>, 在<code>src/sonic-sairedis/SAI/inc/sai.h</code>中是对其的定义，在<code>src/sonic-sairedis/lib/src/sai_redis_interfacequery.cpp</code>中是对其的实现。借用<code>API</code>宏完成对其初始化。<br><img src="https://rancho333.github.io/pictures/saiapi_query.png"></p><p>注意<code>sai_apis_t</code>结构体是<code>src/sonic-sairedis/SAI/meta/parse.pl</code>perl脚本自动生成的，生成的文件名为<code>saimetadata.h</code>,结构体成员为各功能模块的结构体指针。</p><p>以<code>sai_switch_api</code>为例：<br><img src="https://rancho333.github.io/pictures/sai_switch_api.png"><br>到这里就完成了对OCP SAI的封装调用，而最后对redis的操作，201911之后的版本，实际的redis操作函数都使用宏来生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REDIS_GENERIC_QUAD</span><br><span class="line">REDIS_CREATE</span><br></pre></td></tr></table></figure><p>这部分操作的就是将<code>create_switch</code>的信息写到<code>ASIC_DB</code>, <code>syncd</code>进程收到发布的消息之后进行真正的SDK初始化操作。<br><img src="https://rancho333.github.io/pictures/syslog.png"></p><h2 id="create-switch分析"><a href="#create-switch分析" class="headerlink" title="create_switch分析"></a>create_switch分析</h2><p><code>redis_create_switch</code>函数由宏定义展开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REDIS_GENERIC_QUAD(OT,ot)        sai_redis.h</span><br><span class="line">REDIS_CREATE(OT,ot)              sai_redis.h</span><br></pre></td></tr></table></figure><p><img src="https://rancho333.github.io/pictures/define_redis_create.png"></p><p><code>redis_sai</code>的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;SaiInterface&gt; redis_sai &#x3D; std::make_shared&lt;ClientServerSai&gt;();    sai_redis_interfacequery.cpp</span><br><span class="line"></span><br><span class="line">SaiInterface是父类， ClientServerSai是其子类</span><br><span class="line">                    RemoteSaiInterface同样是SaiInterface子类</span><br><span class="line">                        RedisRemoteSaiInterface又是RemoteSaiInterface的子类</span><br></pre></td></tr></table></figure><p><code>redis_sai</code>的指针类型是<code>SaiInterface</code>，根据C++的多态特性，<code>redis_sai-&gt;create</code>的最终实现在：<br><img src="https://rancho333.github.io/pictures/redis_sai_create.png"></p><h1 id="syncd初始化ASIC"><a href="#syncd初始化ASIC" class="headerlink" title="syncd初始化ASIC"></a>syncd初始化ASIC</h1><p>直接从初始化sai api开始(由于201911之后的版本syncd模块重构了，变得更加难看，下面的分析基于201911版本，基本流程都差不多)：<br><img src="https://rancho333.github.io/pictures/syncd_saiapi_init.png"></p><p>在mainloop里面进入<code>processEvent</code>流程，里面进入<code>initviewmode</code>:<br><img src="https://rancho333.github.io/pictures/initview_mode.png"></p><p>之后：<br><img src="https://rancho333.github.io/pictures/on_switch_create.png"></p><p>然后调用sai api完成交换芯片初始化指令的下发：<br><img src="https://rancho333.github.io/pictures/create_switch.png"></p><p>最后就是sai模块中厂商对应的实现：<br><img src="https://rancho333.github.io/pictures/brcm_sai.png"></p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      
      <comments>https://rancho333.github.io/2021/07/21/SONiC%E4%B8%AD%E4%BA%A4%E6%8D%A2%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC中Vxlan-decap测试用例简析</title>
      <link>https://rancho333.github.io/2021/04/28/SONiC%E4%B8%ADVxlan-decap%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%AE%80%E6%9E%90/</link>
      <guid>https://rancho333.github.io/2021/04/28/SONiC%E4%B8%ADVxlan-decap%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%AE%80%E6%9E%90/</guid>
      <pubDate>Wed, 28 Apr 2021 07:16:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本文简要分析SONiC testbed中Vxlan decap测试用例的实现，作为对&lt;a href=&quot;https://rancho333.gitee.io/2021/02/03/vxlan%E5%AD%A6%E4%B9%A0/&quot;&gt;vxlan学习&lt;/a&gt;的补充。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文简要分析SONiC testbed中Vxlan decap测试用例的实现，作为对<a href="https://rancho333.gitee.io/2021/02/03/vxlan%E5%AD%A6%E4%B9%A0/">vxlan学习</a>的补充。</p><span id="more"></span><h2 id="背景简述"><a href="#背景简述" class="headerlink" title="背景简述"></a>背景简述</h2><p>Vxlan技术的本质是通过overlay实现一个vm无感知的大二层网络，一般用于数据中心，好处是vm迁移时可以保持IP不变（再辅以一些技术手段可以保持业务不中断）,换种方式说，vm可以在任意物理主机上实现和网关的二层互通。</p><h2 id="测试用例简析"><a href="#测试用例简析" class="headerlink" title="测试用例简析"></a>测试用例简析</h2><p>在<code>sonic-mgmt/tests/vxlan</code>下共有5个测试文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_vnet_route_leak.py</span><br><span class="line">test_vnet_vxlan.py</span><br><span class="line">test_vxlan_decap.py</span><br><span class="line">vnet_constants.py</span><br><span class="line">vnet_utils.py</span><br></pre></td></tr></table></figure><p>本次只是简要分析下<code>test_vxlan_decap.py</code>测试内容。</p><h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><p>测试dut在数据面对vxlan报文的解封装。对每一vlan会运行三个case。</p><ol><li>Vxlan： 给portchannel接口发送封装的vxlan报文，应该在对应的vlan接口上看到payload报文。</li><li>RegularLAGtoVLAN: 发送常规报文给portchannel接口，应该在对应的vlan接口上看到该报文。</li><li>RegularVLANtoLAG: 发送常规报文给vlan成员接口，应该在portchannel接口上看到该报文。</li></ol><p><img src="https://rancho333.gitee.io/pictures/vxlan_tests.png"></p><h2 id="测试参数"><a href="#测试参数" class="headerlink" title="测试参数"></a>测试参数</h2><p>共有6个测试参数。</p><ol><li><code>config_file</code>是运行test所需要的所有必要信息。该文件由ansible构造生成。该参数不可缺省。</li><li><code>vxlan_enabled</code>是一个布尔参数。当设置为true时，vxlan测试失败整个测试失败。该参数默认为false。</li><li><code>count</code>是一个整数。表示发包数，默认为1.</li><li><code>dut_host</code>是dut的ip地址</li><li><code>sonic_admin_user</code>是dut的登录名</li><li><code>sonic_admin_password</code>是登录密码</li></ol><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>testbed设置好之后，运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run_tests.sh -d cel-seastone-01 -n cel_slx_t0 -c vxlan&#x2F;test_vxlan_decap.py -t t0,any</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试失败</p><p>log记录下来供后续参考。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E               &quot;delta&quot;: &quot;0:01:30.984956&quot;, E               &quot;end&quot;: &quot;2021-04-28 09:12:57.714679&quot;, E               &quot;failed&quot;: true, E               &quot;invocation&quot;: &#123;E                   &quot;module_args&quot;: &#123;E                       &quot;_raw_params&quot;: &quot;ptf --test-dir ptftests vxlan-decap.Vxlan --platform-dir ptftests --qlen&#x3D;10000 --platform remote -t &#39;vxlan_enabled&#x3D;False;count&#x3D;10;config_file&#x3D;&#39;\&quot;&#39;\&quot;&#39;&#x2F;tmp&#x2F;vxlan_decap.json&#39;\&quot;&#39;\&quot;&#39;;sonic_admin_user&#x3D;u&#39;\&quot;&#39;\&quot;&#39;admin&#39;\&quot;&#39;\&quot;&#39;;sonic_admin_password&#x3D;u&#39;\&quot;&#39;\&quot;&#39;password&#39;\&quot;&#39;\&quot;&#39;;dut_hostname&#x3D;u&#39;\&quot;&#39;\&quot;&#39;10.251.0.100&#39;\&quot;&#39;\&quot;&#39;;sonic_admin_alt_password&#x3D;u&#39;\&quot;&#39;\&quot;&#39;YourPaSsWoRd&#39;\&quot;&#39;\&quot;&#39;&#39; --relax --debug info --log-file &#x2F;tmp&#x2F;vxlan-decap.Vxlan.Removed.2021-04-28-09:11:26.log&quot;, E                       &quot;_uses_shell&quot;: true, E                       &quot;argv&quot;: null, E                       &quot;chdir&quot;: &quot;&#x2F;root&quot;, E                       &quot;creates&quot;: null, E                       &quot;executable&quot;: null, E                       &quot;removes&quot;: null, E                       &quot;stdin&quot;: null, E                       &quot;stdin_add_newline&quot;: true, E                       &quot;strip_empty_ends&quot;: true, E                       &quot;warn&quot;: trueE                   &#125;E               &#125;, E               &quot;msg&quot;: &quot;non-zero return code&quot;, E               &quot;rc&quot;: 1, E               &quot;start&quot;: &quot;2021-04-28 09:11:26.729723&quot;, E               &quot;stderr&quot;: &quot;WARNING: No route found for IPv6 destination :: (no default route?)\n&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;paramiko&#x2F;transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in a future release.\n  from cryptography.hazmat.backends import default_backend\nvxlan-decap.Vxlan ... FAIL\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nFAIL: vxlan-decap.Vxlan\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \&quot;ptftests&#x2F;vxlan-decap.py\&quot;, line 397, in runTest\n    self.warmup()\n  File \&quot;ptftests&#x2F;vxlan-decap.py\&quot;, line 334, in warmup\n    raise AssertionError(\&quot;Warmup failed\&quot;)\nAssertionError: Warmup failed\n\n----------------------------------------------------------------------\nRan 1 test in 89.524s\n\nFAILED (failures&#x3D;1)&quot;, E               &quot;stderr_lines&quot;: [E                   &quot;WARNING: No route found for IPv6 destination :: (no default route?)&quot;, E                   &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;paramiko&#x2F;transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in a future release.&quot;, E                   &quot;  from cryptography.hazmat.backends import default_backend&quot;, E                   &quot;vxlan-decap.Vxlan ... FAIL&quot;, E                   &quot;&quot;, E                   &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;, E                   &quot;FAIL: vxlan-decap.Vxlan&quot;, E                   &quot;----------------------------------------------------------------------&quot;, E                   &quot;Traceback (most recent call last):&quot;, E                   &quot;  File \&quot;ptftests&#x2F;vxlan-decap.py\&quot;, line 397, in runTest&quot;, E                   &quot;    self.warmup()&quot;, E                   &quot;  File \&quot;ptftests&#x2F;vxlan-decap.py\&quot;, line 334, in warmup&quot;, E                   &quot;    raise AssertionError(\&quot;Warmup failed\&quot;)&quot;, E                   &quot;AssertionError: Warmup failed&quot;, E                   &quot;&quot;, E                   &quot;----------------------------------------------------------------------&quot;, E                   &quot;Ran 1 test in 89.524s&quot;, E                   &quot;&quot;, E                   &quot;FAILED (failures&#x3D;1)&quot;E               ], E               &quot;stdout&quot;: &quot;&quot;, E               &quot;stdout_lines&quot;: []E           &#125;</span><br></pre></td></tr></table></figure><p>可以找到是在<code>warmup</code>中出错了，具体怎么修改后续再跟吧！</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      
      <comments>https://rancho333.github.io/2021/04/28/SONiC%E4%B8%ADVxlan-decap%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%AE%80%E6%9E%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC中ARP测试用例简析</title>
      <link>https://rancho333.github.io/2021/04/26/SONiC%E4%B8%ADARP%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%AE%80%E6%9E%90/</link>
      <guid>https://rancho333.github.io/2021/04/26/SONiC%E4%B8%ADARP%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%AE%80%E6%9E%90/</guid>
      <pubDate>Mon, 26 Apr 2021 08:08:45 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本文简要分析SONiC testbed中ARP测试用例的实现，作为对&lt;a href=&quot;https://rancho333.gitee.io/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/&quot;&gt;ARP协议简述及应用&lt;/a&gt;的补充。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文简要分析SONiC testbed中ARP测试用例的实现，作为对<a href="https://rancho333.gitee.io/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/">ARP协议简述及应用</a>的补充。</p><span id="more"></span><h2 id="背景知识简述"><a href="#背景知识简述" class="headerlink" title="背景知识简述"></a>背景知识简述</h2><p>ARP直接基于以太帧进行封装，<code>type</code>类型为<code>0x0806</code>，报文很简单，只有两类：ARP request报文和ARP reply报文。其中request报文可分为三类：<br>    1. 单播request，参考rfc1122，一种arp缓存刷新机制<br>    2. 广播request，这也是常见的arp请求报文<br>    3. 免费arp报文，sender ip和destination ip相同</p><h2 id="测试用例简析"><a href="#测试用例简析" class="headerlink" title="测试用例简析"></a>测试用例简析</h2><p>在<code>sonic-mgmt/tests/arp</code>下共有4个测试文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_arpall.py</span><br><span class="line">test_neighbor_mac_noptf.py</span><br><span class="line">test_neighbor_mac.py</span><br><span class="line">test_wr_arp.py</span><br></pre></td></tr></table></figure><p>本文会分析<code>test_arpall.py</code>文件，对于其它三个文件会简要说明一下，最后对测试失败的<code>test_wr_arp.py</code>做一个分析。</p><p><code>test_arpall.py</code>中设计了5种测试用例：</p><ol><li>发送单播arp request</li><li>发送广播arp request</li><li>发送不同网段的arp request(sender ip字段异常)</li><li>免费arp测试</li></ol><h3 id="单播arp-request测试"><a href="#单播arp-request测试" class="headerlink" title="单播arp request测试"></a>单播arp request测试</h3><p>测试代码在<code>sonic-mgmt/tests/arp/test_arpall.py</code>文件中，对该模块代码截取简析如下：</p><p><img src="https://rancho333.gitee.io/pictures/arp_unicast_reply.png"></p><p>报文构造代码在<code>sonic-mgmt/ansible/roles/test/files/ptftests/arptest.py</code>文件中，对应的ARP包构造函数内容如下：</p><p><img src="https://rancho333.gitee.io/pictures/verifyunicastarpreply.png"></p><p>基本流程就是构造单播arp request报文，之后获取dut的arp表，看发送arp request的端口arp条目是否存在。根据rfc1122，这是unicast poo(单播轮询)：定时向ARP缓存条目中的主机发送点到点的ARP请求报文，假如在N次连续超时时间过后，没有收到对应主机的ARP响应报文，则将此条目从ARP缓存中删除。</p><p>其实这样测试并不能测试出unicast poll的定义，和普通ARP 请求没啥区别。</p><h3 id="广播arp-request测试"><a href="#广播arp-request测试" class="headerlink" title="广播arp request测试"></a>广播arp request测试</h3><p>测试代码如下：</p><p><img src="https://rancho333.gitee.io/pictures/arp_expect_reply.png"></p><p>对应的ARP包构造函数内容如下：</p><p><img src="https://rancho333.gitee.io/pictures/expectreply.png"></p><p>如上面的分析，和单播arp请求没啥区别，虽然ser intf1的mac改了一下，但无关紧要。</p><h3 id="收到的arp报文请求的不是本接口mac"><a href="#收到的arp报文请求的不是本接口mac" class="headerlink" title="收到的arp报文请求的不是本接口mac"></a>收到的arp报文请求的不是本接口mac</h3><p>测试代码如下：</p><p><img src="https://rancho333.gitee.io/pictures/arp_no_reply_other_intf.png"><br>这里asset判断的ip错了，应该是不等于10.10.1.22才对。</p><p>对应的ARP包构造函数内容如下：</p><p><img src="https://rancho333.gitee.io/pictures/srcoutrangenoreply.png"></p><h3 id="收到的arp请求中的sender-ip与本接口不在同一网段"><a href="#收到的arp请求中的sender-ip与本接口不在同一网段" class="headerlink" title="收到的arp请求中的sender ip与本接口不在同一网段"></a>收到的arp请求中的sender ip与本接口不在同一网段</h3><p>和上面<code>收到的arp报文请求的不是本接口mac</code>的流程基本一致，只是将相同的arp request报文发给dut intf1。</p><h3 id="免费arp报文测试"><a href="#免费arp报文测试" class="headerlink" title="免费arp报文测试"></a>免费arp报文测试</h3><p>免费arp的测试分为两块，如果免费arp中的信息之前没有解析过，那么不应该响应免费arp报文，反之响应。</p><p>不响应的代码如下：</p><p><img src="https://rancho333.gitee.io/pictures/garp_no_update.png"></p><p>对应的ARP包构造函数内容如下：</p><p><img src="https://rancho333.gitee.io/pictures/garpnoupdate.png"></p><p>此时即使dut收到了免费arp报文，但是<code>10.10.1.7</code>的信息并不在dut的arp表中，所以不应该有响应动作。</p><p>响应的代码如下：</p><p><img src="https://rancho333.gitee.io/pictures/garp_update.png"><br>可以看到先调用<code>ExpectReply</code>让<code>10.10.1.3</code>存在于dut的arp表中，之后再调用<code>GarpUpdate</code>更新mac，MAC地址由<code>00:06:07:08:09:0a</code>更新为<code>00:00:07:08:09:0a</code>。</p><p>对应的ARP包构造函数内容如下：</p><p><img src="https://rancho333.gitee.io/pictures/garpupdate.png"><br>这里面修改了<code>10.10.1.3</code>对应的MAC地址。</p><h2 id="其它三个测试文件说明"><a href="#其它三个测试文件说明" class="headerlink" title="其它三个测试文件说明"></a>其它三个测试文件说明</h2><p>对于<code>test_neighbor_mac_noptf.py</code>，ptf作为dut的邻居，针对ipv4和ipv6两种场景，分别测试在DUT的redis中和arp表中能不能找到另据的arp entry。<br>对于<code>test_neighbor_mac.py</code>，ptf作为dut的邻居，使用相同的ip(ipv4)，映射两个不同的mac地址，分别测试这两个mac在redis中存不存在。<br>对于<code>test_wr_arp.py</code>测试热重启过程中的arp功能，首先在ptf上开启ferret server，之后让dut进入warm-reboot，在此过程中，ptf发送arp request，25秒内没有收到arp reply测试失败。</p><h2 id="测试结果说明"><a href="#测试结果说明" class="headerlink" title="测试结果说明"></a>测试结果说明</h2><p>以<code>10.204.112.27:8080</code>上的<code>seastone-t0</code>为例说明，测试结果如下：</p><p><img src="https://rancho333.gitee.io/pictures/testbed_wrarp_seastone.png"></p><p>可以看到<code>test_wr_arp.py</code>测试失败了，结果不符合预期。wr_arp首先在ptf host上开启ferret服务，之后在dut上启动warm-reboot程序，当dut处于warm-reboot阶段时，向其vlan成员发送arp请求报文，25秒内任一vlan成没有响应则测试失败。</p><p>而在<code>seastone2-t0</code>上面，该项测试失败，但是原因不一样：</p><p><img src="https://rancho333.gitee.io/pictures/testbed_wrarp_seastone2.png"><br>此处是没有获取到ptf宣告的ip，这个网段应该由zebra下发到kernel，src字段为dut的loopback。</p>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      
      <comments>https://rancho333.github.io/2021/04/26/SONiC%E4%B8%ADARP%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%AE%80%E6%9E%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SONiC中OSPF使用简述</title>
      <link>https://rancho333.github.io/2021/04/23/SONiC%E4%B8%ADOSPF%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0/</link>
      <guid>https://rancho333.github.io/2021/04/23/SONiC%E4%B8%ADOSPF%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Fri, 23 Apr 2021 07:32:20 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;承接上文&lt;a href=&quot;https://rancho333.gitee.io/2021/04/08/SONiC%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/&quot;&gt;SONiC路由协议简述&lt;/a&gt;，这边文章记录SONiC上使能OSPF的过程。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>承接上文<a href="https://rancho333.gitee.io/2021/04/08/SONiC%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/">SONiC路由协议简述</a>，这边文章记录SONiC上使能OSPF的过程。</p><span id="more"></span><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="拓扑说明"><a href="#拓扑说明" class="headerlink" title="拓扑说明"></a>拓扑说明</h3><p>拓扑图如下：</p><p><img src="https://rancho333.gitee.io/pictures/ospf-topology.png"></p><p>实验预期：</p><ol><li>三台设备上能建立ospf邻居，完成LSDB交换，建立ospf路由</li><li><code>192.168.1.2</code>能够<code>ping</code>通<code>192.168.2.2</code></li></ol><h3 id="启动OSPF"><a href="#启动OSPF" class="headerlink" title="启动OSPF"></a>启动OSPF</h3><p>在<code>bgp</code>容器中启动<code>ospf</code>进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;frr&#x2F;ospfd -A 127.0.0.1 -d</span><br></pre></td></tr></table></figure><p>参照<code>bgpd</code>的启动过程，将ospf添加到supervisor中，并指定配置文件，在<code>/etc/supervisor/conf.d/supervisord.conf</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:ospfd]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;lib&#x2F;frr&#x2F;ospfd -A 127.0.0.1 -f &#x2F;etc&#x2F;frr&#x2F;ospfd.conf</span><br><span class="line">priority&#x3D;5</span><br><span class="line">stopsignal&#x3D;KILL</span><br><span class="line">autostart&#x3D;false</span><br><span class="line">autorestart&#x3D;false</span><br><span class="line">startsecs&#x3D;0</span><br><span class="line">stdout_logfile&#x3D;syslog</span><br><span class="line">stderr_logfile&#x3D;syslog</span><br></pre></td></tr></table></figure><p>在<code>/usr/bin/start.sh</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start ospfd</span><br></pre></td></tr></table></figure><p>创建ospf配置文件<code>/etc/frr/ospfd.conf</code>, 根据具体业务添加配置内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frr version 7.2.1-sonic</span><br><span class="line">frr defaults traditional</span><br><span class="line">hostname lambda</span><br><span class="line">router ospf</span><br><span class="line"> network 192.168.1.0&#x2F;24 area 0</span><br></pre></td></tr></table></figure><h3 id="配置接口IP"><a href="#配置接口IP" class="headerlink" title="配置接口IP"></a>配置接口IP</h3><p>在SONiC命令行中可配置接口ip，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config interface ip add 192.168.2.1&#x2F;24</span><br></pre></td></tr></table></figure><p>zebra会通过netlink获取接口配置，反之在vty中配置接口ip不能同步到sonic。也可将配置写到配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;INTERFACE&quot;: &#123;              </span><br><span class="line">        &quot;Ethernet1|192.168.1.1&#x2F;24&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Ethernet2|192.168.2.1&#x2F;24&quot;: &#123;&#125;                                                                                                                                                                                                                                                                               </span><br><span class="line">    &#125;,      </span><br></pre></td></tr></table></figure><p>配置完成之后，在vty中可以看到使能了ospf的接口：</p><p><img src="https://rancho333.gitee.io/pictures/ospf-interface.png"></p><p>注意将接口的mtu配置成1500或者在ospf中关闭mtu check。</p><h3 id="配置ASIC"><a href="#配置ASIC" class="headerlink" title="配置ASIC"></a>配置ASIC</h3><p>SONiC中默认ospf报文不送CPU，这可能和各家的SDK初始化实现有关。在broadcom下我们需要做一些配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fp qset add ipprotocol</span><br><span class="line">fp group create 20 21    (20是优先级， 21是group-id)</span><br><span class="line">fp entry create 21 3000    （3000是entry-id，这是一个全局的值，注意不能重叠）</span><br><span class="line">fp qual  3000 ipprotocol 89 0xffff(指定copy-to-cpu的协议特征)</span><br><span class="line">fp action add 3000 CopyToCpu 0 0（对匹配到特征的协议指定动作）</span><br><span class="line">fp entry install 3000（使能配置）</span><br><span class="line">fp show entry 3000                        （验证配置）</span><br></pre></td></tr></table></figure><p>应当在ASIC中看到使能的配置：</p><p><img src="https://rancho333.gitee.io/pictures/ospf-asic.png"></p><p>sonic中提供了copp功能配置sdk下发这些报文上CPU等的控制操作，受当前实验版本限制暂不做这方面深入研究。</p><h3 id="功能验证"><a href="#功能验证" class="headerlink" title="功能验证"></a>功能验证</h3><p>查看邻居状态：</p><p><img src="https://rancho333.gitee.io/pictures/ospf-neighbour.png"></p><p>查看数据库信息：</p><p><img src="https://rancho333.gitee.io/pictures/ospf-database.png"></p><p>查看路由表：</p><p><img src="https://rancho333.gitee.io/pictures/ospf-route.png"></p><p>ping测试：</p><p><img src="https://rancho333.gitee.io/pictures/ospf-ping.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当前SONiC上ospf功能使能需要做三方面的配置：</p><ol><li>ospf自身，包括功能启用以及协议参数配置</li><li>启用ospf协议的接口</li><li>配置ASIC，协议报文上CPU</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://rancho333.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</category>
      
      <category domain="https://rancho333.github.io/tags/SONiC/">SONiC</category>
      
      
      <comments>https://rancho333.github.io/2021/04/23/SONiC%E4%B8%ADOSPF%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
