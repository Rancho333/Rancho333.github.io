---
title: shell变量
date: 2021-02-22 16:28:14
tags: shell
---

- [shell变量](#shell变量)
- [变量相关的一些命令](#变量相关的一些命令)
- [特殊变量](#特殊变量)
- [常见环境变量](#常见环境变量)

# shell变量
标准的UNIX变量分为两类，环境变量和shell变量。广义上而言，`shell变量`只应用于当前的shell实例，是用来设置短期工作情况的; `环境变量`有更长远的意义，这些变量在登录时设置，在整个会话期都是有效的。一般约定，环境变量使用大写变量表示，shell变量使用小写表示。
<!--more-->

通过`printenv`命令列出所有的环境变量，`set`命令列出所有的shell变量。环境变量中存储的更多是永久性的变量,例如：
```
HOME=/home/rancho
```
这些变量很少改变，而shell变量存储本地的、临时性的、shell特有的变量,如：
```
PWD=/tmp            #切换到不同的文件夹下查看该变量，该变量的值就是pwd命令的打印
```

shell变量是shell专有的变量，不会被子进程继承，环境变量才会被继承。

# 变量相关的一些命令
对于几个关于变量的命令的说明：
- set             设置和显示shell变量（包括环境变量，shell变量，函数定义, 等效于declare
- env,printenv    显示环境变量
- export          将shell变量导出为环境变量, 显示导出成环境变量的shell变量，并显示变量属性，等效于declare -x

对于变量，其核心的点
- 变量对应的值
- 变量的作用域

其中，shell变量的值只能为字符串，可以用`declare -i`强制声明为数值、
关于变量作用域：
shell变量与环境变量的作用域差异主要体现在子shell继承上面；`source`或`.`与直接执行脚本的作用域差异主要体现在对当前shell环境的设置上面
shell命令行或shell脚本中定义的变量均为全局的，哪怕是在shell函数中定义的变量也是全局的shell变量，这与其它编程语言不同，在shell函数中使用内建命令`local`声明的变量作用域只在函数中，`local`命令也只能在函数中使用
同时，这一点也是很合理的，对于普通程序，如`ls`，程序执行完内存就释放了，所以里面的变量都没了；而`bash`本身也是一个程序，它并没有结束，所以里面的变量还在，如果你`exit`退出了，变量也就没了。
```
[rancho ~]$ type -t local
builtin
[rancho ~]$ local a=10
-bash: local: can only be used in a function
```
如果变量的作用域只想在脚本内生效，使用完之后用`unset`将之释放

此外，使用`var=value cmd`方式定义的变量作用域只在cmd的执行环境中。

# 特殊变量
shell上有一些特殊变量，这些变量由shell自身动态维护，不允许用户手动修改。

这些特殊变量没有变量名，而是使用变量引用去使用这些变量。
```
$1,$2,$N：          脚本的位置参数
$0:                 shell或shell脚本的名称，注意BASH_SOURCE变量
$*:                 扩展为位置参数，“$*”等价于“$1 $2 $3 ... $N”
$@:                 扩展为位置参数，“$@”等价于“$1” "$2" "$3" ... "$N"
$#:                 位置参数的个数
$$:                 当前shell进程的PID，在某些shell(如小括号开启的子shell)下会被继承。注意BASHPID变量
$?:                 最近一个前台命令的退出状态码
$!:                 最近一个后台命令的退出代码
$-:                 当前shell环境的一些特殊设置，如是否是交互式，一般是himBH, 比如可以设置set -x,变成himxBH，取消set +x
```

# 常见环境变量
`$TERM`变量表示终端类型，值会是以下之一：
- xterm             一般是这个值
- vt220             是xterm的子集，不支持颜色，可以top命令后输入z测试
- xterm-color       如果在老系统，并且屏幕颜色不对时用这个类型
- putty,konsole     使用终端模拟器
- screen            if running inside GNU screen（or tmux）
- linux             通过linux串口登录 ctrl+alt+f1
